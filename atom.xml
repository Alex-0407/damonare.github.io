<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damonare的个人博客</title>
  <subtitle>不念过去，不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://damonare.github.io/"/>
  <updated>2016-12-20T05:55:35.679Z</updated>
  <id>http://damonare.github.io/</id>
  
  <author>
    <name>Damonare</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React全家桶实现一个简易备忘录</title>
    <link href="http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://damonare.github.io/2016/12/19/React全家桶实现简易备忘录/</id>
    <published>2016-12-19T09:34:38.262Z</published>
    <updated>2016-12-20T05:55:35.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。</p>
<ul>
<li><p>代码地址：<a href="https://github.com/damonare/memos" target="_blank" rel="external">Github代码地址</a></p>
</li>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more">React全家桶实现一个简易备忘录</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生不失意，焉能暴己知。</strong></p>
<a id="more"></a>
<h3 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h3><blockquote>
<p>技术架构：本备忘录使用react+react-router+redux+less+ES6+webpack实现;</p>
<p>页面UI参照：<a href="http://www.todolist.cn/" target="_blank" rel="external">TodoList官网</a>实现;</p>
<p>在线演示地址：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a>;</p>
</blockquote>
<h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>支持回车添加新事项;</li>
<li>支持删除事项(点击X符号);</li>
<li>支持状态转换具体包括：<ul>
<li>新建事项-&gt;正在进行(点击checkbox选项)</li>
<li>正在进行-&gt;已完成(点击文字内容本身)</li>
<li>正在进行-&gt;新建事项(点击checkbox选项)</li>
<li>已完成-&gt;正在进行(点击文字本身)</li>
</ul>
</li>
<li>支持判断输入空字符，过长字符(20个汉字以内);</li>
<li>支持搜索;</li>
<li>支持本地化存储;</li>
<li>支持状态的展开隐藏(点击标题)</li>
<li>兼容手机端(iPhone6及以上)</li>
<li>支持路由切换</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-React浅谈"><a href="#1-React浅谈" class="headerlink" title="1. React浅谈"></a>1. React浅谈</h3><h4 id="1-1-组件化"><a href="#1-1-组件化" class="headerlink" title="1.1  组件化"></a>1.1  组件化</h4><p>​    毫无疑问，当谈到<code>React</code>的时候不能避免的会提到组件化思想。React刚开始想解决的问题只是UI这一层面的问题，也就是MVC中view层面的问题，不成想如今越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。对于<code>React</code>组件的理解同样要站在view层面的角度出发，一个完整的页面是由大大小小的组件堆叠而成，就好像搭积木，每一块积木都是一个组件，组件套组件组成了用户所能看到的完整的页面。</p>
<h4 id="1-2-JSX语法糖"><a href="#1-2-JSX语法糖" class="headerlink" title="1.2  JSX语法糖"></a>1.2  JSX语法糖</h4><p>​    使用<code>React</code>，不一定非要使用<code>JSX</code>语法，可以使用原生的JS进行开发。但是<code>React</code>作者强烈建议我们使用<code>JSX</code>，因为<code>JSX</code>在定义类似HTML这种树形结构时，十分的简单明了。这里简单的讲下<code>JSX</code>的由来。</p>
<p>​    比如，下面一个div元素，我们用HTML语法描述为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>   如果换做使用javascript描述这个元素呢？最好的方式可以简单的转化为<code>json</code>对象，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type:"div",</div><div class="line">  props:&#123;</div><div class="line">    className:"test",</div><div class="line">    children:&#123;</div><div class="line">      type:"span",</div><div class="line">      props:&#123;</div><div class="line">        children:"Test"</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   这样我们就可以在javascript中创建一个<code>Virtual DOM</code>（虚拟DOM）了。当然，这样是没法复用的，我们再把它封装一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div=&gt;(&#123;text&#125;)&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type:<span class="string">"div"</span>,</div><div class="line">    props:&#123;</div><div class="line">      className:<span class="string">"test"</span>,</div><div class="line">      children:&#123;</div><div class="line">        type:<span class="string">"span"</span>,</div><div class="line">        props:&#123;</div><div class="line">          children: text,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  接下来再实现这个div就可以直接调用Div(‘Test’)来创建。但上述结构看起来实在让人不爽，写起来也很容易写混，一旦结构复杂了，很容易让人找不着北，于是<code>JSX</code>语法应运而生。我们用写HTML的方式写这段代码，再经过翻译器转换成javascript后交给浏览器执行。上述代码用<code>JSX</code>重写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div =()=&gt;(</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"test"</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>多么简单明了！！！具体的<code>JSX语法</code>不多说了，学习更多戳这：<a href="http://reactjs.cn/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></p>
<h4 id="1-3-Virtual-DOM"><a href="#1-3-Virtual-DOM" class="headerlink" title="1.3  Virtual DOM"></a>1.3  Virtual DOM</h4><p>   其实上面已经提到了<code>Virtual DOM</code>，它的存在也是<code>React</code>长久不衰的原因之一，虚拟DOM的概念并不是FB首创却在FB的手上大火了起来(后台是多么重要)。</p>
<p>  我们知道真实的页面对应了一个DOM树，在传统页面的开发模式中，每次需要更新页面时，都需要对DOM进行更新，DOM操作十分昂贵，为减少对于真实DOM的操作，诞生了<code>Virtual DOM</code>的概念，也就是用javascript把真实的DOM树描述了一遍，使用的也就是我们刚刚说过的<code>JSX</code>语法。对比如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/1444448853198657.jpg" alt="Virtual DOM原理"></p>
<p>   每次数据更新之后，重新计算<code>Virtual DOM</code>，并和上一次的<code>Virtual DOM</code>对比，对发生的变化进行批量更新。React也提供了<code>shouldComponentUpdate</code>生命周期回调，来减少数据变化后不必要的<code>Virtual DOM</code>对比过程，提升了性能。</p>
<p> <code>Virtual DOM</code>虽然渲染方式比传统的DOM操作要好一些，但并不明显，因为对比DOM节点也是需要计算的，最大的好处在于可以很方便的和其它平台集成，比如<code>react-native</code>就是基于<code>Virtual DOM</code>渲染出原生控件。具体渲染出的是<code>Web DOM</code>还是<code>Android</code>控件或是<code>iOS</code>控件就由平台决定了。所以我们说<code>react</code>的出现是一场革命，一次对于<code>native app</code>的宣战,就像<code>react-native</code>那句口号——<strong>Learn Once,Write Anywhere</strong>.</p>
<h4 id="1-4-函数式编程"><a href="#1-4-函数式编程" class="headerlink" title="1.4 函数式编程"></a>1.4 函数式编程</h4><p>​    过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。</p>
<p>​   而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=&gt;遍历旧数组=&gt;给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。</p>
<h4 id="1-5-数据流"><a href="#1-5-数据流" class="headerlink" title="1.5 数据流"></a>1.5 数据流</h4><p>  在React中，数据的流动是单向的，即从父节点传递到子节点。也因此组件是简单的，他们只需要从父组件获取props渲染即可。如果顶层的props改变了，React会递归的向下遍历整个组件树，重新渲染所有使用这个属性的组件。那么父组件如何获取子组件数据呢？很简单，通过回调就可以了，父组件定义某个方法供给子组件调用，子组件调用方法传递给父组件数据，Over。</p>
<h3 id="2-React-router"><a href="#2-React-router" class="headerlink" title="2. React-router"></a>2. React-router</h3><p>这东西我觉得没啥难度，官方例子都很不错，跟着官方例子来一遍基本就明白到底是个啥玩意了，官方例子：<a href="https://github.com/reactjs/react-router-tutorial/tree/master/lessons" target="_blank" rel="external"><strong>react-router-tutorial。</strong></a></p>
<p>完事以后可以再看一下阮一峰老师的教程，主要是对一些API的讲解：<a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">React Router 使用教程</a>。</p>
<p>还有啥不明白的欢迎评论留言共同探讨。</p>
<h3 id="3-Redux"><a href="#3-Redux" class="headerlink" title="3. Redux"></a>3. Redux</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。乱！</p>
<p>这时候<code>Redux</code>就强势登场了，现在你可以把<code>React</code>的model看作是一个个的子民，每一个子民都有自己的一个状态，纷纷扰扰，各自维护着自己状态，我行我素，那哪行啊！太乱了，我们需要一个King来领导大家，我们就可以把<code>Redux</code>看作是这个King。网罗所有的组件组成一个国家，掌控着一切子民的状态！防止有人叛乱生事！</p>
<p>这个时候就把组件分成了两种：容器组件(King或是路由)和展示组件(子民)。</p>
<ul>
<li>容器组件：即<code>redux</code>或是<code>router</code>,起到了维护状态，出发action的作用，其实就是King高高在上下达指令。</li>
<li>展示组件：不维护状态，所有的状态由容器组件通过<code>props</code>传给他，所有操作通过回调完成。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">展示组件</th>
<th style="text-align:center">容器组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">描述如何展现（骨架、样式）</td>
<td style="text-align:center">描述如何运行（数据获取、状态更新）</td>
</tr>
<tr>
<td style="text-align:center">直接使用 Redux</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">数据来源</td>
<td style="text-align:center">props</td>
<td style="text-align:center">监听 Redux state</td>
</tr>
<tr>
<td style="text-align:center">数据修改</td>
<td style="text-align:center">从 props 调用回调函数</td>
<td style="text-align:center">向 Redux 派发 actions</td>
</tr>
<tr>
<td style="text-align:center">调用方式</td>
<td style="text-align:center">手动</td>
<td style="text-align:center">通常由 React Redux 生成</td>
</tr>
</tbody>
</table>
<p>Redux三大部分：<code>store</code>,<code>action</code>,<code>reducer</code>。相当于King的直系下属。</p>
<p>那么也可以看出<code>Redux</code>只是一个状态管理方案，完全可以单独拿出来使用，这个King不仅仅可以是React的，去Angular，Ember那里也是可以做King的。在React中维系King和组件关系的库叫做<code>react-redux</code>。</p>
<p>， 它主要有提供两个东西：<code>Provider</code> 和<code>connect</code>，具体使用文后说明。</p>
<p>提供几个Redux的学习地址：<a href="http://cn.redux.js.org/index.html" target="_blank" rel="external">官方教程-中文版</a>，<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一）：基本用法</a></p>
<h4 id="3-2-Store"><a href="#3-2-Store" class="headerlink" title="3.2 Store"></a>3.2 Store</h4><p>Store 就是保存数据的地方，它实际上是一个<code>Object tree</code>。整个应用只能有一个 Store。这个Store可以看做是King的首相，掌控一切子民(组件)的活动(state)。</p>
<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">const</span> store = createStore(func);</div></pre></td></tr></table></figure>
<p>createStore接受一个函数作为参数，返回一个Store对象(首相诞生记)</p>
<p>我们来看一下Store(首相)的职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#getState" target="_blank" rel="external"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<h4 id="3-3-action"><a href="#3-3-action" class="headerlink" title="3.3 action"></a>3.3 action</h4><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。即store的数据变化来自于用户操作。action就是一个通知，它可以看作是首相下面的邮递员，通知子民(组件)改变状态。它是 store 数据的<strong>唯一</strong>来源。一般来说会通过 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> action = &#123;</div><div class="line">  type: <span class="string">'ADD_TODO'</span>,</div><div class="line">  payload: <span class="string">'Learn Redux'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>Action创建函数</strong></p>
<p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做将使 action 创建函数更容易被移植和测试。</p>
<h4 id="3-4-reducer"><a href="#3-4-reducer" class="headerlink" title="3.4 reducer"></a>3.4 reducer</h4><p><strong>Action</strong> 只是描述了<strong>有事情发生了</strong>这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。也就是邮递员(action)只负责通知，具体你(组件)如何去做，他不负责，这事情只能是你们村长(reducer)告诉你如何去做才能符合社会主义核心价值观，如何做才能对建设共产主义社会有利。</p>
<p>专业解释: <strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</strong></p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">return</span> new_state;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="3-5-数据流"><a href="#3-5-数据流" class="headerlink" title="3.5 数据流"></a>3.5 数据流</h4><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。</p>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ul>
<li><strong>调用</strong> <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch(action)</code></a>。</li>
<li><strong>Redux store 调用传入的 reducer 函数。</strong></li>
<li><strong>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</strong></li>
<li><strong>Redux store 保存了根 reducer 返回的完整 state 树</strong>。</li>
</ul>
<p>工作流程图如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/6b3fb1df3ad9c95354280a332065941a_thumb.png" alt="redux工作原理图"></p>
<h4 id="3-6-Connect"><a href="#3-6-Connect" class="headerlink" title="3.6 Connect"></a>3.6 Connect</h4><p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
<p>尽管如此，Redux 还是和 <a href="http://facebook.github.io/react/" target="_blank" rel="external">React</a> 和 <a href="https://github.com/dekujs/deku" target="_blank" rel="external">Deku</a> 这类框架搭配起来用最好，因为这类框架允许你以 state 函数的形式来描述界面，Redux 通过 action 的形式来发起 state 变化。</p>
<p>Redux 默认并不包含 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React 绑定库</a>，需要单独安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react-redux</div></pre></td></tr></table></figure>
<p>当然，我们这个实例里是不需要的，所有需要的依赖已经在package.json里配置好了。</p>
<p><code>React-Redux</code> 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">const</span> TodoList = connect()(Memos);</div></pre></td></tr></table></figure>
<p>上面代码中<code>Memos</code>是个UI组件，<code>TodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p>
<p>而只是纯粹的这样把Memos包裹起来毫无意义，完整的connect方法这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">const</span> TodoList = connect(</div><div class="line">  mapStateToProps</div><div class="line">)(Memos)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h4 id="3-7-Provider"><a href="#3-7-Provider" class="headerlink" title="3.7 Provider"></a>3.7 Provider</h4><p> 这个Provider 其实是一个中间件，它是为了解决让容器组件拿到King的指令(<code>state</code>对象)而存在的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></div><div class="line"><span class="keyword">let</span> store = createStore(todoApp);</div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p>
<h3 id="4-实战备忘录"><a href="#4-实战备忘录" class="headerlink" title="4.实战备忘录"></a>4.实战备忘录</h3><h4 id="4-1目录结构"><a href="#4-1目录结构" class="headerlink" title="4.1目录结构"></a>4.1目录结构</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── app                 <span class="comment">#开发目录</span></div><div class="line">|<span class="string">   </span>|<span class="string">   </span></div><div class="line">|<span class="string">   ├──actions          #action的文件</span></div><div class="line">|<span class="string">   </span>|<span class="string">   </span></div><div class="line">|<span class="string">   ├──components       #展示组件</span></div><div class="line">|<span class="string">   </span>|<span class="string">   </span></div><div class="line">|<span class="string">   ├──containers       #容器组件,主页</span></div><div class="line">|<span class="string">   </span>|<span class="string">   </span></div><div class="line">|<span class="string">   ├──reducers         #reducer文件</span></div><div class="line">|<span class="string">   </span>|</div><div class="line">|<span class="string">   </span>|<span class="string">——routes		   #路由文件，容器组件</span></div><div class="line">|<span class="string">   </span>|</div><div class="line">|<span class="string">   </span>|<span class="string">——static           #静态文件</span></div><div class="line">|<span class="string">   </span>|</div><div class="line">|<span class="string">   ├──stores           #store配置文件</span></div><div class="line">|<span class="string">   </span>|</div><div class="line">|<span class="string">   </span>|<span class="string">——main.less        #路由样式</span></div><div class="line">|<span class="string">   </span>|</div><div class="line">|<span class="string">   └──main.js          #入口文件</span></div><div class="line">|<span class="string">      </span></div><div class="line">├── build                #发布目录</div><div class="line">├── node_modules        #包文件夹</div><div class="line">├── .gitignore     </div><div class="line">├── .jshintrc      </div><div class="line">├── webpack.production.config.js  #生产环境配置      </div><div class="line">├── webpack.config.js   #webpack配置文件</div><div class="line">├── package.json        #环境配置</div><div class="line">└── README.md		   #使用说明</div></pre></td></tr></table></figure>
<p>接下来，我们只关注app目录就好了。</p>
<h4 id="4-2入口文件"><a href="#4-2入口文件" class="headerlink" title="4.2入口文件"></a>4.2入口文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Route, IndexRoute, browserHistory, Router&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./container/App'</span>;</div><div class="line"><span class="keyword">import</span> AllMemosRoute <span class="keyword">from</span> <span class="string">'./routes/AllMemosRoute'</span>;</div><div class="line"><span class="keyword">import</span> TodoRoute <span class="keyword">from</span> <span class="string">'./routes/TodoRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoingRoute <span class="keyword">from</span> <span class="string">'./routes/DoingRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoneRoute <span class="keyword">from</span> <span class="string">'./routes/DoneRoute'</span>;</div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./stores'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./main.less'</span>;</div><div class="line"><span class="keyword">const</span> store = configureStore();</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">            &lt;Route path="/"  component=&#123;App&#125;&gt;</div><div class="line">                &lt;IndexRoute component=&#123;AllMemosRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/todo" component=&#123;TodoRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/doing" component=&#123;DoingRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/done" component=&#123;DoneRoute&#125;/&gt;</div><div class="line">            &lt;/Route&gt;</div><div class="line">        &lt;/Router&gt;</div><div class="line">   &lt;/Provider&gt;,</div><div class="line"> document.body.appendChild(document.createElement('div')))</div></pre></td></tr></table></figure>
<p>这里我们从<code>react-redux</code>中获取到 Provider 组件，我们把它渲染到应用的最外层。<br>他需要一个属性 store ，他把这个 store 放在context里，给Router(connect)用。</p>
<h4 id="4-3-Store"><a href="#4-3-Store" class="headerlink" title="4.3 Store"></a>4.3 Store</h4><blockquote>
<p> app/store/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'../reducers'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducer, initialState);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">    <span class="comment">// Enable Webpack hot module replacement for reducers</span></div><div class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'../reducers'</span>, () =&gt; &#123;</div><div class="line">      <span class="keyword">const</span> nextReducer = <span class="built_in">require</span>(<span class="string">'../reducers'</span>);</div><div class="line">      store.replaceReducer(nextReducer);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-Action-创建函数和常量"><a href="#4-4-Action-创建函数和常量" class="headerlink" title="4.4 Action 创建函数和常量"></a>4.4 Action 创建函数和常量</h4><blockquote>
<p>app/action/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @author Damonare 2016-12-10</div><div class="line"> * @version 1.0.0</div><div class="line"> * action 类型</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Add_Todo = <span class="string">'Add_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Todo_To_Doing = <span class="string">'Change_Todo_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Done = <span class="string">'Change_Doing_To_Done'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Done_To_Doing = <span class="string">'Change_Done_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Todo = <span class="string">'Change_Doing_To_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Search=<span class="string">'Search'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delete_Todo=<span class="string">'Delete_Todo'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * action 创建函数</div><div class="line"> * @method  addTodo添加新事项</div><div class="line"> * @param  &#123;String&#125; text 添加事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Add_Todo,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  search 查找事项</div><div class="line"> * @param  &#123;String&#125; text 查找事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Search,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeTodoToDoing 状态由todo转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeTodoToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Todo_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoneToDoing 状态由done转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoneToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Done_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToTodo 状态由doing转为todo</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Doing_To_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToDone 状态由doing转为done</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToDone</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Doing_To_Done,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  deleteTodo 删除事项</div><div class="line"> * @param  &#123;Number&#125; index 需要删除的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Delete_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明每一个返回 action 函数的时候，我们需要在头部声明这个 action 的 type，以便好组织管理。<br>每个函数都会返回一个 action 对象，所以在 容器组件里面调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">text =&gt;</div><div class="line">  dispatch(addTodo(text))</div></pre></td></tr></table></figure>
<p>就是调用<code>dispatch(action)</code> 。</p>
<h4 id="4-5-Reducers"><a href="#4-5-Reducers" class="headerlink" title="4.5 Reducers"></a>4.5 Reducers</h4><blockquote>
<p>app/reducers/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> todolist <span class="keyword">from</span> <span class="string">'./todos'</span>;</div><div class="line"><span class="comment">// import visibilityFilter from './visibilityFilter';</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</div><div class="line">  todolist</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</div></pre></td></tr></table></figure>
<blockquote>
<p>app/reducers/todos.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Add_Todo,</div><div class="line">    Delete_Todo,</div><div class="line">    Change_Todo_To_Doing,</div><div class="line">    Change_Doing_To_Done,</div><div class="line">    Change_Doing_To_Todo,</div><div class="line">    Change_Done_To_Doing,</div><div class="line">    Search</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span>;</div><div class="line"><span class="keyword">let</span> todos;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (localStorage.todos) &#123;</div><div class="line">        todos = <span class="built_in">JSON</span>.parse(localStorage.todos)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        todos = []</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todolist</span>(<span class="params">state = todos, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">        *  添加新的事项</div><div class="line">        *  并进行本地化存储</div><div class="line">        *  使用ES6展开运算符链接新事项和旧事项</div><div class="line">        *  JSON.stringify进行对象深拷贝</div><div class="line">        */</div><div class="line">        <span class="keyword">case</span> Add_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state, &#123;</div><div class="line">                    todo: action.text,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state, &#123;</div><div class="line">                    todo: action.text,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将todo转为doing状态，注意action.index的类型转换</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Todo_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为done状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Done:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将done转为doing状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Done_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为todo状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  删除某个事项</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Delete_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  搜索</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Search:</div><div class="line">        <span class="keyword">let</span> text=action.text;</div><div class="line">        <span class="keyword">let</span> reg=<span class="built_in">eval</span>(<span class="string">"/"</span>+text+<span class="string">"/gi"</span>);</div><div class="line">            <span class="keyword">return</span> state.filter(item=&gt; item.todo.match(reg));</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> todolist;</div></pre></td></tr></table></figure>
<p>具体的展示组件这里就不罗列代码了，感兴趣的可以戳这：<a href="https://github.com/damonare/memos/tree/master/app/components" target="_blank" rel="external">备忘录展示组件地址</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>严格来说，这个备忘录并不是使用的react全家桶，毕竟还有一部分less代码，不过这一个应用也算是比较全面的使用了react+react-router+redux，作为react全家桶技术学习的练手的小项目再适合不过了。如果您对这个小东西感兴趣，欢迎戳这:<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现简易备忘录</a>给个star。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/damonare/memos&quot;&gt;Github代码地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more&quot;&gt;React全家桶实现一个简易备忘录&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生不失意，焉能暴己知。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="React" scheme="http://damonare.github.io/tags/React/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>百度FE工程师实习offer到手记</title>
    <link href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/"/>
    <id>http://damonare.github.io/2016/12/13/我的Web面试经历-百度/</id>
    <published>2016-12-13T08:18:32.655Z</published>
    <updated>2016-12-13T12:10:18.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于<a href="http://www.xidian.edu.cn/" target="_blank" rel="external">西安电子科技大学</a>，现在是大三在读。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more">百度FE工程师实习offer到手记</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>没有什么能够阻挡，你对自由的向往。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>整个面试过程是略微曲折的，博主参加了百度两个部门的面试，一个部门拿到了实习offer，另一个部门挂在了二面。文后暂且称为部门甲和部门乙吧。</p>
</blockquote>
<h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p><strong>基础知识储备</strong></p>
<p>作为一个FE(front-end,也就是前端)工程师基础的扎实是十分重要的。基本的HTML，CSS，Javascript知识得懂吧，自己的技术栈得建立起来吧，毕竟前端框架层出不穷，起码要有一个稳定的路线支撑着自己研究下去啊。基础知识部分这里推荐两篇博主之前的博文：</p>
<ul>
<li><a href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/#more">前端面试题集</a></li>
<li><a href="http://damonare.github.io/2016/09/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/#more">前端面试大全</a></li>
</ul>
<p>有一篇是我自己总结的，一篇是转载大牛的，都可以看一下。</p>
<p><strong>简历与经历</strong></p>
<p>好的表达能力确实是很加分的，语言流畅，思路清晰，多说专业词汇，我觉得会给面试官留下很好的印象。将简历的内容完整的表达出来并不容易，每一个人在刚开始写简历的时候肯定都会尽量把自己忘好的方向写，但心里没有个尺度是不行的，太完美的人是不存在的，敢写就先要想好如果面试官问该怎么回答，或是会问什么问题，站在面试官的角度思考一下，某一方面到底有没有必要写在简历里。这个自己心里是要有数的。比如：关于某社团经历，组织过什么小活动，怎么组织的，时间地点人物安排的流程是什么样的，心里是要有准的;再比如：关于某项目经历，该项目的技术难点，遇到的问题以及解决方法，技术栈是啥，由几部分人组成，开发周期等信息心里是要有数的。</p>
<p>简历这块我总结如下，最基本的：</p>
<ul>
<li>姓名、电话、邮箱、学校、位置等必要信息</li>
<li>项目经历(技术栈，个人担任的角色，项目内容要说明白</li>
<li>获奖经历(别把高中得过三好学生这种的扯出来就好…)</li>
<li>个人性格(纯属凑字数)</li>
</ul>
<p>加分项：</p>
<ul>
<li>实习经历</li>
<li>Github开源项目</li>
<li>个人博客</li>
</ul>
<p><strong>投递地址</strong></p>
<p>可以找一些招聘网站投递简历，比如：</p>
<ul>
<li><a href="http://my.zhaopin.com/" target="_blank" rel="external">智联招聘</a></li>
<li><a href="http://my.51job.com/" target="_blank" rel="external">前程无忧</a></li>
<li><a href="http://passport.lagou.com/" target="_blank" rel="external">拉钩</a></li>
<li>相关企业的校招网站</li>
<li>大佬内推</li>
</ul>
<h3 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h3><p>博主先面试的是部门甲，一面面试官声音很好听，给人一种很放松的感觉。<br>下面是一面问的问题：</p>
<ul>
<li>自我介绍</li>
<li>拿手项目难点解决方法</li>
<li>gulp和webpack对比</li>
<li>git和svn对比</li>
<li>CSS居中方法</li>
<li>vue和react对比</li>
<li>如何用栈实现队列</li>
<li>取球算法问题</li>
<li>Es6你常用的特性</li>
<li>jquery和react对比</li>
<li>原生实现ajax</li>
<li>口述react单项数据流</li>
<li>react子组件如何传值给父组件</li>
</ul>
<p>一面太紧张了，很多问题回答的支支吾吾的，好在大佬给了二面机会，二面的面试官感觉性格也是很好的那种人，有说有笑的，问的问题如下：</p>
<ul>
<li>HTML5表单新特性</li>
<li>自己总结下编写html使用嵌套的注意点</li>
<li>scss的好处</li>
<li>写过什么复杂的数据交互的页面没，介绍下</li>
<li>无限级联动的注意点</li>
<li>描述下跨域使用场景，举例说明</li>
<li>gulp和webpack对比介绍</li>
<li>gulp和webpack原理区别</li>
<li>口述如何模拟radio，模拟下拉框</li>
</ul>
<p>然后参加了部门乙的一面，问题如下：</p>
<ul>
<li>CSS两栏布局</li>
<li>gulp和webpack对比</li>
<li>vue和react对比</li>
</ul>
<p>这次的一面博主忘记做记录了，很多问题想不起来了….十分抱歉，二面很简单，问题如下：</p>
<ul>
<li>分析下URL由哪几部分组成的</li>
<li>冒泡排序的时间复杂度，是否稳定</li>
<li>堆排序的时间复杂度，是否稳定</li>
<li>单链表反转</li>
</ul>
<p>博主自以为这四个问题答得还可以呢，以为应该过了，最后原来只是我以为…部门乙的面试石沉大海再无消息。</p>
<p>隔天,部门甲来电话说给我笔试题，让我做做看。用他们的技术栈实现一个备忘录，要求一周内完成。说是备忘录实际上就是稍微复杂一点的todolist。技术栈要求：react+redux+react-router+less+ES6。</p>
<p>这事似乎有门！博主抓紧查阅了资料学习。之前对于react是熟悉的但redux一直没怎么懂，另外博主平时使用较多的CSS预处理语言是scss，less没用过，又是一通查阅。好在博主小爆发了一下，两天时间写完了，交了上去。现在看看，感觉自己还是有潜力发掘的，人被逼急了大脑真是会疯狂运转。算是超预期完成了吧，加上了react-router和本地化存储以及一些小feature。下面是在线地址，感兴趣的话您可以去看看：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a></p>
<p>笔试题结束后，隔了几天(大佬看完了我的笔试题代码之后)，来了三面，三面的面试官也很和蔼，给人一种很亲切的感觉。大概聊了一下具体的时间安排以及我平时的一些活动和对于一些专业名词的理解。面试官说我技术面实际上表现的很不好，很多问题都答得不尽人意，但看我挺喜欢这行的，就给了我一次笔试的机会，好在我笔试过关了…(很后怕啊)</p>
<h3 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h3><p>技术面试流程我总结是这样的：</p>
<ul>
<li>自我介绍(必不可少啊，总得让面试官大概的了解自己吧)</li>
<li>基础知识阶段(广度阶段)</li>
<li>项目中遇到的难点以及解决方法</li>
<li>针对某一技术进行深度挖掘</li>
<li>你有什么要问我的</li>
</ul>
<p>我个人在最后的阶段，两个部门都问了一下他们现在所使用的的技术栈。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上能拿到这次百度的实习offer，您也能看出来很大一部分我靠的都是运气。部门甲的面试官们看了我的博客，同时他们在面试的时候也就几篇博文对我提了几个问题，可能也是从博客看出我对于FE的喜爱的吧。所以给了笔试的机会，否则我想部门甲的面试也会和部门乙一样挂掉。</p>
<p>但话说回来了，博客是自己搭的，博文是一篇一篇积累起来的，也不能说全是运气。</p>
<p>引用一句从一位现在在阿里工作的学长的一句话：<code>让别人知道你知道</code>。</p>
<p>让别人知道你知道，说起来好像很简单，但其实做起来并不容易，这个并不是只靠说的，嘴巴一张一合也只是让一个人知道了而已。想让更多人知道就得下点功夫了。不要在意别人的言语，包括博主自己现在某种程度上还是活在别人的眼里。那种过于在意别人的言语，渐渐把自己活成别人眼里的模样的人不是很可悲么。活出自己！过自己的生活，与他人何干。就像博主平时会码代码码到很晚，旁边也常传来一些不理解的话，诸如<code>码农</code>、<code>天天就知道写代码</code>。做自己！干自己喜欢的事！何必去理别人的看法呢！</p>
<p>另外，博主不是科班出身，不要以非科班或自己是个文科生去逃避，喜欢就去学，想做就做！Man一点好伐！诸如阮一峰，尤小右那样的大神不也是非科班一步步成就了现在的地位的么。</p>
<p>还有一点，如果您是一个现在在犹豫是否学习FE或是其他技术的人，请理智一点！千万不要拿我不喜欢技术这种枯燥的事为理由搪塞，谁告诉你技术枯燥的？！网络就是程序员的天下，所谓的程序员呆板钱多话少死得早都是程序员自黑的话，这种你也敢信？文字工作发泄情绪的平台是笔杆子，农民发泄情绪的平台是锄头，可悲的是这些并不会被大多数人看到，而程序员的自黑却会被整个网络的人看到。这点道理不明白？羡慕高薪就去学，学完了再去评论。没学过就说不感兴趣，那是愚蠢的！</p>
<p>最后，试着去推销自己吧，<code>让别人知道你知道</code>的方式有很多，诸如：做公众号，开专栏，写博客等方式。</p>
<p>当然为了不必要的烦恼，最好还是用昵称来经营自己。那么，博主选择方式就是写博客了。</p>
<p>就写博客这件事来说，一来可以作为自己学习的记录，二来可以作为一个学习笔记，三来可以作为一个知识分享的形式，一举三得，实在是个很好的方式。博主刚开始写的时候是没有人看的，当您正处在这个阶段的时候，不要放弃，坚持写，坚持记录，总有一天会有人发现某一篇博文的精彩的。不求带来多少经济利益，只为能给屏幕前的读者一丝帮助或是启迪。</p>
<p>总的来说，面试必需的三个要素我觉得如下：<code>礼貌</code>、<code>专业能力</code>、<code>运气</code>。一次面试的失败并没有什么，天时地利人和是很难凑齐的。不要灰心丧气，重整旗鼓，再战苍穹便是！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于&lt;a href=&quot;http://www.xidian.edu.cn/&quot;&gt;西安电子科技大学&lt;/a&gt;，现在是大三在读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more&quot;&gt;百度FE工程师实习offer到手记&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;没有什么能够阻挡，你对自由的向往。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实习" scheme="http://damonare.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="面试" scheme="http://damonare.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS三栏布局的四种方法</title>
    <link href="http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://damonare.github.io/2016/12/07/CSS三栏布局的四种方法/</id>
    <published>2016-12-07T13:15:42.218Z</published>
    <updated>2016-12-11T10:11:05.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more">CSS三栏布局的四种方法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>年华一去不复返，事业放弃再难成。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>所谓三栏布局就是指页面分为左中右三部分然后对中间一部分做自适应的一种布局方式。</p>
</blockquote>
<h3 id="1-绝对定位法"><a href="#1-绝对定位法" class="headerlink" title="1.绝对定位法"></a>1.绝对定位法</h3><p>HTML代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//简单的进行CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0px;</div><div class="line">    margin:0px;</div><div class="line">&#125;</div><div class="line">//左右绝对定位</div><div class="line">.left,.right&#123;</div><div class="line">    position: absolute;</div><div class="line">    top:0px;</div><div class="line">    background: red;</div><div class="line">    height:100%;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    left:0;</div><div class="line">    width:100px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    right:0px;</div><div class="line">    width:200px;</div><div class="line">&#125;</div><div class="line">//中间使用margin空出左右元素所占据的空间</div><div class="line">.main&#123;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">    height:100%;</div><div class="line">    background: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法有个明显的缺点，就是如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</p>
<h3 id="2-圣杯布局"><a href="#2-圣杯布局" class="headerlink" title="2. 圣杯布局"></a>2. 圣杯布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//习惯性的CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//父元素body空出左右栏位</div><div class="line">body &#123;</div><div class="line">    padding-left: 100px;</div><div class="line">    padding-right: 200px;</div><div class="line">&#125;</div><div class="line">//左边元素更改</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    position: relative;</div><div class="line">    left: -100px;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间部分</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">//右边元素定义</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    position: relative;</div><div class="line">    right: -200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关解释如下：</p>
<ul>
<li>(1)中间部分需要根据浏览器宽度的变化而变化，所以要用100%，这里设左中右向左浮动，因为中间100%，左层和右层根本没有位置上去</li>
<li>(2)把左层margin负100后，发现left上去了，因为负到出窗口没位置了，只能往上挪</li>
<li>(3)按第二步这个方法，可以得出它只要挪动窗口宽度那么宽就能到最左边了，利用负边距，把左右栏定位</li>
<li>(4)但由于左右栏遮挡住了中间部分，于是采用相对定位方法，各自相对于自己把自己挪出去，得到最终结果</li>
</ul>
<h3 id="3-双飞翼布局"><a href="#3-双飞翼布局" class="headerlink" title="3. 双飞翼布局"></a>3. 双飞翼布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">        Main</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    /*padding-left:100px;*/</div><div class="line">    /*padding-right:200px;*/</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    height: 100%;</div><div class="line">    /*position: relative;*/</div><div class="line">    /*left:-100px;*/</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    height: 100%;</div><div class="line">    /*position:relative;*/</div><div class="line">    /*right:-200px;*/</div><div class="line">&#125;</div><div class="line">//新增inner元素</div><div class="line">.inner &#123;</div><div class="line">    margin-left: 100px;</div><div class="line">    margin-right: 200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>圣杯布局实际看起来是复杂的后期维护性也不是很高，在淘宝UED的探讨下，出来了一种新的布局方式就是双飞翼布局，代码如上。增加多一个div就可以不用相对布局了，只用到了浮动和负边距。和圣杯布局差异的地方已经被注释。</p>
<h3 id="4-浮动"><a href="#4-浮动" class="headerlink" title="4. 浮动"></a>4. 浮动</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//左栏左浮动</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间自适应</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    height: 100%;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">&#125;</div><div class="line">//右栏右浮动</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: right;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式代码足够简洁与高效，也容易理解</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>四种方法其实只有圣杯布局和双飞翼布局较难理解，但实际上理解了圣杯布局，双飞翼布局自然就理解了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more&quot;&gt;CSS三栏布局的四种方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;年华一去不复返，事业放弃再难成。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(三)——集合</title>
    <link href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/"/>
    <id>http://damonare.github.io/2016/11/26/学习javascript数据结构（三）——集合/</id>
    <published>2016-11-26T05:24:45.261Z</published>
    <updated>2016-11-30T05:47:56.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more">学习javascript数据结构(三)——集合</a></li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生多风雨，何处无险阻。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h3><p>在上一篇<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a>中我们说了链表这种数据结构，但归根结底，不论是栈，队列亦或是链表都是线性结构。他们都是一种很规矩的数据结构，就像幼儿园的小朋友排队乖乖的站在那不会动一样。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224745616" alt="幼儿园小朋友排队"></p>
<hr>
<p>然而纷杂的数据并不会总是排队站在那里，幼儿园小朋友一旦下了课那可就撒欢了，乱糟糟一团。可我们的幼儿园老师却能分辨出这些小朋友，因为啥？因为每个小朋友都在一个班里，而且每一个小朋友都有自己的名字。老师自然很容易就找到小朋友了。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224928510" alt="幼儿园小朋友下课"></p>
<hr>
<p>而本篇博文要说的集合正是一堆<code>乱糟糟的数据</code>，唯一的共同点是这些数据隶属于同一个<code>集合</code>,看下百科给出的解释：</p>
<blockquote>
<p>由一个或多个元素所构成的叫做集合。</p>
</blockquote>
<p>此处的元素就是小朋友了，他们所在的集合就是他们的班级。其实我们在高中的时候也接触过集合的概念。那时候还没有套路这个名词，单纯的岁月，那个年代对于集合是这么解释的：</p>
<blockquote>
<p>集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素。</p>
</blockquote>
<p>然后又是这么分类的：</p>
<ul>
<li>空集：{}</li>
<li>有限集：{a,b,4}</li>
<li>无限集：{1,2,3,4…}</li>
</ul>
<p>不过，数据结构中集合是没有无限集这个概念的。再然后那时候的集合还有这么几个特性：</p>
<ul>
<li>确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。</li>
<li>互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。有时需要对同一元素出现多次的情形进行刻画，可以使用多重集，其中的元素允许出现多次。</li>
<li>无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。集合上可以定义序关系，定义了序关系后，元素之间就可以按照序关系排序。但就集合本身的特性而言，元素之间没有必然的序。</li>
</ul>
<p>想当年哥还是个数学学霸，如今却沦落为了一个码农……真是让人唏嘘啊。咳咳！接着说：</p>
<p>集合还有这几种常见的基本操作：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<p>而且我们数据结构中的集合基本是也符合高中时候的数学中的概念的。接下来我们是用ES5来实现集合，为啥子这么说呢……因为在ES6中已经新给出了Set，Map等几个集合类，更加方便快捷的锁定键值对。</p>
<h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><p>首先我们先声明一个集合类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> items=&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们需要给链表声明一些方法：</p>
<ul>
<li>add(value):向集合添加一个新的项</li>
<li>remove(value):从集合移除一个值</li>
<li>has(value):如果值在集合中，返回true,否则返回false</li>
<li>clear():移除集合中的所有项</li>
<li>size():返回集合所包含的元素数量，与数组的length属性相似</li>
<li>values():返回一个集合中所有值的数组</li>
<li>union(setName):并集，返回包含两个集合所有元素的新集合(元素不重复)</li>
<li>intersection(setName):交集，返回包含两个集合中共有的元素的集合、</li>
<li>difference(setName):差集，返回包含所有存在本集合而不存在setName集合的元素的新集合</li>
<li>subset(setName):子集，验证setName是否是本集合的子集</li>
</ul>
<p>下面是Set类的完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            items[value] = value;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            <span class="keyword">delete</span> items[value];</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.hasOwnProperty(value);</div><div class="line">        <span class="comment">//return value in items;</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = &#123;&#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * cross browser compatibility - legacy browsers</div><div class="line">     * for modern browsers use size function</div><div class="line">     * @returns &#123;number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key))</div><div class="line">                ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Array&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items); i&lt;keys.length; i++) &#123;</div><div class="line">            values.push(items[keys[i]]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.valuesLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key)) &#123;</div><div class="line">                values.push(items[key]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getItems = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> items;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        values = otherSet.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                intersectionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> intersectionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;    </div><div class="line">                differenceSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> differenceSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是ES6版本代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Set2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Set2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        add(value)&#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                items_[value] = value;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span>(value)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">delete</span> items_[value];</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        has(value)&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> items_.hasOwnProperty(value);</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items_).length;</div><div class="line">        &#125;</div><div class="line">        values()&#123;</div><div class="line">            <span class="keyword">let</span> values = [];</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items_); i&lt;keys.length; i++) &#123;</div><div class="line">                values.push(items_[keys[i]]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">        getItems()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        union(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            values = otherSet.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> unionSet;</div><div class="line">        &#125;</div><div class="line">        intersection(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                    intersectionSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intersectionSet;</div><div class="line">        &#125;</div><div class="line">        difference(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                    differenceSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> differenceSet;</div><div class="line">        &#125;;</div><div class="line">        subset(otherSet)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                    <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Set2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>集合是一种比较常见的数据结构，在JS中我们已经有了一种类似哈希表的东西：Object(对象)。但现在我们所说的集合只是以[value,value]形式存储数据，下一节我们使用[键，值]形式存储数据，和本文集合的实现略有不同。敬请期待：[学习javascript数据结构(四)——散列表]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more&quot;&gt;学习javascript数据结构(三)——集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生多风雨，何处无险阻。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本地存储小结</title>
    <link href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/16/Javascript本地存储小结/</id>
    <published>2016-11-16T03:35:51.573Z</published>
    <updated>2016-11-26T10:06:09.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括:</strong> 详细讲述<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>的区别和用法。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more">Javascript本地存储小结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生如画，岁月如歌。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-各种存储方案的简单对比"><a href="#1-各种存储方案的简单对比" class="headerlink" title="1. 各种存储方案的简单对比"></a>1. 各种存储方案的简单对比</h3><ul>
<li>Cookies：浏览器均支持，容量为4KB</li>
<li>UserData：仅IE支持，容量为64KB</li>
<li>Flash：100KB，非HTML原生，需要插件支持</li>
<li>Google Gears SQLite ：需要插件支持，容量无限制</li>
<li>LocalStorage：HTML5，容量为5M</li>
<li>SesstionStorage：HTML5，容量为5M</li>
<li>globalStorage：Firefox独有的，Firefox13开始就不再支持这个方法<blockquote>
<p>UserData仅IE支持， Google Gears SQLite需要插件，Flash已经伴随着HTML5的出现渐渐退出了历史舞台，因此今天我们的主角只有他们三个：<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>;</p>
</blockquote>
</li>
</ul>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><p>作为一个前端和Cookie打交道的次数肯定不会少了，Cookie算是比较古老的技术了<br>1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。</p>
<h4 id="2-1-Cookie的特点"><a href="#2-1-Cookie的特点" class="headerlink" title="2.1 Cookie的特点"></a>2.1 Cookie的特点</h4><p><strong>我们先来看下Cookie的特点：</strong></p>
<ul>
<li><p>1）cookie的大小受限制，cookie大小被限制在4KB，不能接受像大文件或邮件那样的大数据。</p>
</li>
<li><p>2）只要有请求涉及cookie，cookie就要在服务器和浏览器之间来回传送（这解释为什么本地文件不能测试cookie）。而且cookie数据始终在同源的http请求中携带（即使不需要），这也是Cookie不能太大的重要原因。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。</p>
</li>
<li><p>3）用户每请求一次服务器数据，cookie则会随着这些请求发送到服务器，服务器脚本语言如PHP等能够处理cookie发送的数据，可以说是非常方便的。当然前端也是可以生成Cookie的，用js对cookie的操作相当的繁琐，浏览器只提供document.cookie这样一个对象，对cookie的赋值，获取都比较麻烦。而在PHP中，我们可以通过setcookie()来设置cookie，通过$_COOKIE这个超全局数组来获取cookie。</p>
</li>
</ul>
<blockquote>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
</blockquote>
<h4 id="2-2-Session"><a href="#2-2-Session" class="headerlink" title="2.2 Session"></a>2.2 Session</h4><p>说到Cookie就不能不说Session。</p>
<blockquote>
<p>Session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。比如：<code>http://damonare.cn?sessionid=123456</code>还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"sessionid"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<h4 id="2-3-Cookie和Session简单对比"><a href="#2-3-Cookie和Session简单对比" class="headerlink" title="2.3 Cookie和Session简单对比"></a>2.3 Cookie和Session简单对比</h4><p><strong>Cookie和Session 的区别：</strong></p>
<ul>
<li><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li><p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>
</li>
<li><p>3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</p>
</li>
<li>4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>5）所以建议：<ul>
<li>将登陆信息等重要信息存放为SESSION</li>
<li>其他信息如果需要保留，可以放在cookie中</li>
</ul>
</li>
</ul>
<h4 id="2-4-document-cookie的属性"><a href="#2-4-document-cookie的属性" class="headerlink" title="2.4 document.cookie的属性"></a>2.4 document.cookie的属性</h4><p><strong>expires属性</strong></p>
<blockquote>
<p>指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。</p>
</blockquote>
<p><strong>path属性</strong></p>
<blockquote>
<p>它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。</p>
</blockquote>
<p><strong>domain属性</strong></p>
<blockquote>
<p>domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.damonare.cn的服务器能够读取catalog.damonare.cn设置的cookie值。如果catalog.damonare.cn的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.damonare.cn”，那么所有位于catalog.damonare.cn的网页和所有位于orlders.damonare.cn的网页，以及位于damonare.cn域的其他服务器上的网页都可以访问这个cookie。</p>
</blockquote>
<p><strong>secure属性</strong></p>
<blockquote>
<p>它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输</p>
</blockquote>
<h4 id="2-5-cookie实战"><a href="#2-5-cookie实战" class="headerlink" title="2.5 cookie实战"></a>2.5 cookie实战</h4><blockquote>
<p>这里我们使用javascript来写一段cookie,借用w3cschool的demo:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">c_name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        c_start=<span class="built_in">document</span>.cookie.indexOf(c_name + <span class="string">"="</span>)</div><div class="line">        <span class="keyword">if</span> (c_start!=<span class="number">-1</span>)&#123;</div><div class="line">            c_start=c_start + c_name.length+<span class="number">1</span></div><div class="line">            c_end=<span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>,c_start)</div><div class="line">            <span class="keyword">if</span> (c_end==<span class="number">-1</span>) c_end=<span class="built_in">document</span>.cookie.length</div><div class="line">            <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">document</span>.cookie.substring(c_start,c_end))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">c_name,value,expiredays</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> exdate=<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    exdate.setDate(exdate.getDate()+expiredays)</div><div class="line">    <span class="built_in">document</span>.cookie=c_name+ <span class="string">"="</span> +<span class="built_in">escape</span>(value)+</div><div class="line">            ((expiredays==<span class="literal">null</span>) ? <span class="string">""</span> : <span class="string">"; expires="</span>+exdate.toUTCString())</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    username=getCookie(<span class="string">'username'</span>)</div><div class="line">    <span class="keyword">if</span>(username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;alert(<span class="string">'Welcome again '</span>+username+<span class="string">'!'</span>)&#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        username=prompt(<span class="string">'Please enter your name:'</span>,<span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;</div><div class="line">            setCookie(<span class="string">'username'</span>,username,<span class="number">355</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意这里对Cookie的生存期进行了定义，也就是355天</p>
</blockquote>
<h3 id="3-localStorage"><a href="#3-localStorage" class="headerlink" title="3. localStorage"></a>3. localStorage</h3><blockquote>
<p>这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。<br>它也是采用Key - Value的方式存储数据，底层数据接口是sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。</p>
</blockquote>
<h4 id="3-1-localStorage的属性方法"><a href="#3-1-localStorage的属性方法" class="headerlink" title="3.1 localStorage的属性方法"></a>3.1 localStorage的属性方法</h4><p>下表是localStorge的一些属性和方法</p>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>localStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>localStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>localStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>localStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>localStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h4 id="3-2-localStorage的缺点"><a href="#3-2-localStorage的缺点" class="headerlink" title="3.2 localStorage的缺点"></a>3.2 localStorage的缺点</h4><ul>
<li>① localStorage大小限制在500万字符左右，各个浏览器不一致</li>
<li>② localStorage在隐私模式下不可读取</li>
<li>③ localStorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）</li>
<li>④ localStorage不能被爬虫爬取，不要用它完全取代URL传参</li>
</ul>
<h3 id="4-sessionStorage"><a href="#4-sessionStorage" class="headerlink" title="4. sessionStorage"></a>4. sessionStorage</h3><blockquote>
<p>和服务器端使用的session类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。使用方法（和localStorage完全相同）：</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>sessionStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>sessionStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>sessionStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>sessionStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h3 id="5-sessionStorage和localStorage的区别"><a href="#5-sessionStorage和localStorage的区别" class="headerlink" title="5. sessionStorage和localStorage的区别"></a>5. sessionStorage和localStorage的区别</h3><ul>
<li><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。</p>
</li>
<li><p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。</p>
</li>
</ul>
<h4 id="5-1-测试"><a href="#5-1-测试" class="headerlink" title="5.1 测试"></a>5.1 测试</h4><p><strong>sessionStorage:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (sessionStorage.pagecount)&#123;</div><div class="line">    sessionStorage.pagecount=<span class="built_in">Number</span>(sessionStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">      sessionStorage.pagecount=<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ sessionStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>测试过程：我们在控制台输入上述代码查看打印结果</strong></p>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>所谓的关闭窗口即销毁，就是这样，关闭窗口重新打开输入代码输出结果还是上面图片的样子，也就是说关闭窗口后sessionStorage.pagecount即被销毁，除非重心创建。或者从历史记录进入才会相关数据才会存在。好的，我们再来看下localStorge表现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (localStorage.pagecount)&#123;</div><div class="line">    localStorage.pagecount=<span class="built_in">Number</span>(localStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    localStorage.pagecount=<span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ localStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225028996" alt="localStorage测试结果1"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225040575" alt="localStorage测试结果2"></p>
<h3 id="6-web-Storage和cookie的区别"><a href="#6-web-Storage和cookie的区别" class="headerlink" title="6. web Storage和cookie的区别"></a>6. web Storage和cookie的区别</h3><p>Web Storage(localStorage和sessionStorage)的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p>
<p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>博主尽可能思路清晰的理了一遍cookie，session，localStorage，sessionStorage之间的区别和联系，希望可以帮到大家。<br>参考文章：</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">cookie 和session 的区别详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括:&lt;/strong&gt; 详细讲述&lt;code&gt;Cookie&lt;/code&gt;,&lt;code&gt;LocalStorge&lt;/code&gt;,&lt;code&gt;SesstionStorge&lt;/code&gt;的区别和用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more&quot;&gt;Javascript本地存储小结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生如画，岁月如歌。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML5" scheme="http://damonare.github.io/tags/HTML5/"/>
    
      <category term="Cookie" scheme="http://damonare.github.io/tags/Cookie/"/>
    
      <category term="缓存" scheme="http://damonare.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="localStorage" scheme="http://damonare.github.io/tags/localStorage/"/>
    
      <category term="sessionStorage" scheme="http://damonare.github.io/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>全面理解Git</title>
    <link href="http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/13/Git 命令总结/</id>
    <published>2016-11-13T15:17:56.608Z</published>
    <updated>2016-11-26T10:01:57.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>总括：</strong> 本文详细讲解了Git常用命令的技巧和使用方法。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#more">Git命令总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生贵知心，定交无暮早。</strong><br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1.Git简介"></a>1.Git简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Git的诞生确实是一个有趣的故事，我们知道，当年Linus创建了开源的Linux，从此，Linux系统不断发展，现在已经成为最大的服务器系统软件了。(请不要傻傻分不清Linus和Linux)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但是随着Linux的不断壮大，就需要各种版本控制了，起初Linus带着他的小弟们使用的是BitKeeper(商业版本控制系统),之后呢由于某种原因BitKeeper的公司不让他们使用了，于是Linus自己花了两周时间写出了Git并且开源了(BitKeeper已哭晕在厕所)，阿弥陀佛，幸亏BitKeeper不让Linus他们用了，要不然我们现在也不会有这么好用的Git了，博主更不会在这写这篇博文了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;之后的岁月里，渐渐有了github,coding等一些可以使用git存储的网站，Git的江湖地位变得无可替代了，如果你是个开发者却还不会使用Git那就太out了。</p>
<p>这里先引用一张图解释Git<br>工作原理：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="Git原理"></p>
<ul>
<li>Workspace:工作区，执行<code>git add *</code>命令就把改动提交到了暂存区，执行<code>git pull</code>命令将远程仓库的数据拉到当前分支并合并，执行<code>git checkout [branch-name]</code>切换分支</li>
<li>Index:暂存区，执行<code>git commit -m &#39;说明&#39;</code> 命令就把改动提交到了仓库区（当前分支）</li>
<li>Repository:仓库区（或本地仓库），执行<code>git push origin master</code>提交到远程仓库，执行<code>git clone 地址</code>将克隆远程仓库到本地</li>
<li>Remote:远程仓库，就是类似github，coding等网站所提供的仓库</li>
</ul>
<p><strong>注</strong>：实际操作命令和上述命令会有所不同，这里这是解释清楚命令和仓库的关系。</p>
<h4 id="1-1-Git-术语"><a href="#1-1-Git-术语" class="headerlink" title="1.1  Git 术语"></a>1.1  Git 术语</h4><table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>仓库（Repository）</td>
<td>一个仓库包括了所有的版本信息、所有的分支和标记信息。在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。</td>
</tr>
<tr>
<td>分支（Branches）</td>
<td>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支执行命令<code>git checkout branch</code>.</td>
</tr>
<tr>
<td>标记（Tags）</td>
<td>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态</td>
</tr>
<tr>
<td>提交（Commit）</td>
<td>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</td>
</tr>
<tr>
<td>修订（Revision）</td>
<td>用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长，16进制标识的字符串.。最新的版本可以通过HEAD来获取。之前的版本可以通过”HEAD~1”来获取，以此类推。</td>
</tr>
</tbody>
</table>
<h4 id="1-2-忽略特定的文件"><a href="#1-2-忽略特定的文件" class="headerlink" title="1.2 忽略特定的文件"></a>1.2 忽略特定的文件</h4><p>可以配置Git忽略特定的文件或者是文件夹。这些配置都放在<code>.gitignore</code>文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。<br>比如<code>.gitignore</code>内容可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">忽略某文件</div><div class="line">npm-debug.log</div><div class="line">忽略文件夹</div><div class="line">dist/</div><div class="line">node_modules/</div><div class="line">.idea/</div></pre></td></tr></table></figure>
<p> 同时Git也提供了全局的配置，core.excludesfile。</p>
<blockquote>
<p>忽略之后的文件或是文件夹Git就不去提交里面的内容了。</p>
</blockquote>
<h4 id="1-3-使用-gitkeep来追踪空的文件夹"><a href="#1-3-使用-gitkeep来追踪空的文件夹" class="headerlink" title="1.3 使用.gitkeep来追踪空的文件夹"></a>1.3 使用.gitkeep来追踪空的文件夹</h4><p>Git会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置<code>.gitkeep</code>文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。</p>
<h4 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 显示当前的Git配置</div><div class="line">$ git config --list</div><div class="line"># 编辑Git配置文件，只是配置用户信息的话直接看下面两行命令即可</div><div class="line">$ git config -e [--global]</div><div class="line"># 设置提交代码时的用户信息，是否加上全局--global自行决定，一般是直接设置全局的。另外用户邮箱需要注意最好使用gmail,QQ也可以，需要和你远程仓库保持一致不然你的contribution是不会被记录在远程仓库的</div><div class="line">$ git config [--global] user.name &quot;[name]&quot;</div><div class="line">$ git config [--global] user.email &quot;[email address]&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
</blockquote>
<p><strong>个人觉得git是需要认真学的，虽然是个工具但不学习很容易把自己弄糊涂，希望这篇博客可以在某些时候帮到您，让您大概理解git的工作原理并把基本命令串起来。那么下面就说一下Git重要的基本命令吧。</strong></p>
<h3 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h3><p><a href="https://git-for-windows.github.io/index.html" target="_blank" rel="external">Git-for-window</a></p>
<blockquote>
<p>下载安装这个不用多说吧….</p>
</blockquote>
<h3 id="3-创建仓库"><a href="#3-创建仓库" class="headerlink" title="3.创建仓库"></a>3.创建仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 在当前目录创建一个文件夹</div><div class="line">$ mkdir [project-name]</div><div class="line"># 在当前目录新建一个Git代码库</div><div class="line">$ git init</div><div class="line"># 新建一个目录，将其初始化为Git代码库</div><div class="line">$ git init [project-name]</div><div class="line"># 下载一个项目和它的整个代码历史（各个分支提交记录等）</div><div class="line">$ git clone [url]</div></pre></td></tr></table></figure>
<blockquote>
<p><code>git init</code>后会出现.git文件夹，里面有配置文件，如果没有git bash里面输入<code>ls -lah</code>就可以看到了</p>
</blockquote>
<p><strong>关于如何关联Git和远程仓库，比如Coding，github等，可以看这两篇文章</strong>：<br><a href="http://www.cnblogs.com/plinx/archive/2013/04/08/3009159.html" target="_blank" rel="external">Git链接到自己的Github</a>&nbsp;&nbsp;&nbsp;<a href="https://coding.net/help/doc/git/getting-started.html#git-1" target="_blank" rel="external">Coding帮助中心</a></p>
<h3 id="4-提交文件"><a href="#4-提交文件" class="headerlink" title="4.提交文件"></a>4.提交文件</h3><h4 id="4-1首次推送"><a href="#4-1首次推送" class="headerlink" title="4.1首次推送"></a>4.1首次推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加当前目录的所有文件到暂存区</div><div class="line">$ git add *</div><div class="line"># 提交暂存区到仓库区</div><div class="line">$ git commit -m [message]</div><div class="line"># 为远程Git更名为origin</div><div class="line">$ git remote add origin git@github.com:abcd/tmp.git</div><div class="line"># 推送此次修改，这是首次推送需要加上-u,之后推送就可以直接git push  origin master,origin是远程Git名字，这个可以自己定义，不过一般是用origin罢了，master是默认的分支，如果不在master分支提交需要写清楚分支名称</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<blockquote>
<p>首次推送成功后可以看下下面的命令：</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加指定文件到暂存区</span></div><div class="line"><span class="variable">$ </span>git add [file1] [file2] ...</div><div class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></div><div class="line"><span class="variable">$ </span>git add [dir]</div><div class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></div><div class="line"><span class="variable">$ </span>git add *</div><div class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></div><div class="line">对于同一个文件的多处变化，可以实现分次提交</div><div class="line"><span class="variable">$ </span>git add -p</div><div class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></div><div class="line"><span class="variable">$ </span>git rm [file1] [file2] ...</div><div class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></div><div class="line"><span class="variable">$ </span>git rm --cached [file]</div><div class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></div><div class="line"><span class="variable">$ </span>git mv [file-original] [file-renamed]</div><div class="line"><span class="comment"># 提交暂存区到仓库区</span></div><div class="line"><span class="variable">$ </span>git commit -m [message]</div><div class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></div><div class="line"><span class="variable">$ </span>git commit [file1] [file2] ... -m [message]</div><div class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></div><div class="line"><span class="variable">$ </span>git commit -a</div><div class="line"><span class="comment"># 提交时显示所有diff信息</span></div><div class="line"><span class="variable">$ </span>git commit -v</div><div class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></div><div class="line">如果代码没有任何新变化，则用来改写上一次commit的提交信息</div><div class="line"><span class="variable">$ </span>git commit --amend -m [message]</div><div class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></div><div class="line"><span class="variable">$ </span>git commit --amend [file1] [file2] ...</div><div class="line"><span class="comment"># 提交更改到远程仓库</span></div><div class="line"><span class="variable">$ </span>git push origin master</div><div class="line"><span class="comment"># 拉取远程更改到本地仓库默认自动合并</span></div><div class="line"><span class="variable">$ </span>git pull origin master</div></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只是维护自己的小项目的话，上面的命令已经够用了，自己一个人在master分支想咋折腾就咋折腾</p>
</blockquote>
<h4 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h4><blockquote>
<p>但如果是多人协作的话，git的魅力就开始提现出来了，每个人有自己的一个分支，各自在自己的分支上工作互不干扰。具体的看这：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">Git教程-创建合并分支</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># 列出所有本地分支</div><div class="line">$ git branch</div><div class="line"># 列出所有远程分支</div><div class="line">$ git branch -r</div><div class="line"># 列出所有本地分支和远程分支</div><div class="line">$ git branch -a</div><div class="line"># 新建一个分支，但依然停留在当前分支</div><div class="line">$ git branch [branch-name]</div><div class="line"># 新建一个分支，并切换到该分支</div><div class="line">$ git checkout -b [branch]</div><div class="line"># 新建一个分支，指向指定commit</div><div class="line">$ git branch [branch] [commit]</div><div class="line"># 新建一个分支，与指定的远程分支建立追踪关系</div><div class="line">$ git branch --track [branch] [remote-branch]</div><div class="line"># 切换到指定分支，并更新工作区</div><div class="line">$ git checkout [branch-name]</div><div class="line"># 切换到上一个分支</div><div class="line">$ git checkout -</div><div class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</div><div class="line">$ git branch --set-upstream [branch] [remote-branch]</div><div class="line"># 合并指定分支到当前分支，如果有冲突需要手动合并冲突（就是手动编辑文件保存咯），然后add,commit再提交</div><div class="line">$ git merge [branch]</div><div class="line"># 选择一个commit，合并进当前分支</div><div class="line">$ git cherry-pick [commit]</div><div class="line"># 删除分支</div><div class="line">$ git branch -d [branch-name]</div><div class="line"># 删除远程分支</div><div class="line">$ git push origin --delete [branch-name]</div><div class="line">$ git branch -dr [remote/branch]</div></pre></td></tr></table></figure>
<h4 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h4><blockquote>
<p>标签的作用主要是用来做版本回退的，关于版本回退，这也是Git的亮点之一，起到了后悔药的功能·</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 列出所有tag</div><div class="line">$ git tag</div><div class="line"># 新建一个tag在当前commit</div><div class="line">$ git tag [tag]</div><div class="line"># 新建一个tag在指定commit</div><div class="line">$ git tag [tag] [commit]</div><div class="line"># 删除本地tag</div><div class="line">$ git tag -d [tag]</div><div class="line"># 删除远程tag</div><div class="line">$ git push origin :refs/tags/[tagName]</div><div class="line"># 查看tag信息</div><div class="line">$ git show [tag]</div><div class="line"># 提交指定tag</div><div class="line">$ git push [remote] [tag]</div><div class="line"># 提交所有tag</div><div class="line">$ git push [remote] --tags</div><div class="line"># 新建一个分支，指向某个tag</div><div class="line">$ git checkout -b [branch] [tag]</div></pre></td></tr></table></figure>
<h4 id="7-后悔药"><a href="#7-后悔药" class="headerlink" title="7.后悔药"></a>7.后悔药</h4><blockquote>
<p>想一下在你写完N个文件代码后，commit到了本地仓库，突然发现整个应用崩溃了！咋整？Git给了我们吃后悔药<br>的机会：</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></div><div class="line"><span class="variable">$ </span>git checkout [file]</div><div class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></div><div class="line"><span class="variable">$ </span>git checkout [commit] [file]</div><div class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></div><div class="line"><span class="variable">$ </span>git checkout .</div><div class="line"><span class="comment"># 回退到上一个版本，在Git中，用HEAD表示当前版本</span></div><div class="line"><span class="variable">$ </span>git reset --hard HEAD^</div><div class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></div><div class="line"><span class="variable">$ </span>git reset [file]</div><div class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></div><div class="line"><span class="variable">$ </span>git reset --hard</div><div class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></div><div class="line"><span class="variable">$ </span>git reset [commit]</div><div class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></div><div class="line"><span class="variable">$ </span>git reset --hard [commit]</div><div class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></div><div class="line"><span class="variable">$ </span>git reset --keep [commit]</div><div class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></div><div class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></div><div class="line"><span class="variable">$ </span>git revert [commit]</div><div class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></div><div class="line"><span class="variable">$ </span>git stash</div><div class="line"><span class="variable">$ </span>git stash pop</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候标签的作用就体现出来了，因为commit号太冗长了，记起来太麻烦有了标签我们相当于自定义了commit号</p>
</blockquote>
<h4 id="8-文件信息"><a href="#8-文件信息" class="headerlink" title="8. 文件信息"></a>8. 文件信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># 显示当前分支的版本历史</div><div class="line">$ git log</div><div class="line"># 显示commit历史，以及每次commit发生变更的文件</div><div class="line">$ git log --stat</div><div class="line"># 搜索提交历史，根据关键词</div><div class="line">$ git log -S [keyword]</div><div class="line"># 显示某个commit之后的所有变动，每个commit占据一行</div><div class="line">$ git log [tag] HEAD --pretty=format:%s</div><div class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</div><div class="line">$ git log [tag] HEAD --grep feature</div><div class="line"># 显示某个文件的版本历史，包括文件改名</div><div class="line">$ git log --follow [file]</div><div class="line">$ git whatchanged [file]</div><div class="line"># 显示指定文件相关的每一次diff</div><div class="line">$ git log -p [file]</div><div class="line"># 显示过去5次提交</div><div class="line">$ git log -5 --pretty --oneline</div><div class="line"># 显示所有提交过的用户，按提交次数排序</div><div class="line">$ git shortlog -sn</div><div class="line"># 显示指定文件是什么人在什么时间修改过</div><div class="line">$ git blame [file]</div><div class="line"># 显示暂存区和工作区的差异</div><div class="line">$ git diff</div><div class="line"># 显示暂存区和上一个commit的差异</div><div class="line">$ git diff --cached [file]</div><div class="line"># 显示工作区与当前分支最新commit之间的差异</div><div class="line">$ git diff HEAD</div><div class="line"># 显示两次提交之间的差异</div><div class="line">$ git diff [first-branch]...[second-branch]</div><div class="line"># 显示今天你写了多少行代码</div><div class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div><div class="line"># 显示某次提交的元数据和内容变化</div><div class="line">$ git show [commit]</div><div class="line"># 显示某次提交发生变化的文件</div><div class="line">$ git show --name-only [commit]</div><div class="line"># 显示某次提交时，某个文件的内容</div><div class="line">$ git show [commit]:[filename]</div></pre></td></tr></table></figure>
<h3 id="8-其它命令"><a href="#8-其它命令" class="headerlink" title="8.其它命令"></a>8.其它命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git blame filepath</td>
<td>git blame清楚的记录某个文件的更改历史和更改人，简直是查看背锅人的利器，filepath是需要查看的文件路径</td>
</tr>
<tr>
<td>git status</td>
<td>显示有变更的文件</td>
</tr>
<tr>
<td>git reflog</td>
<td>显示当前分支的最近几次提交</td>
</tr>
</tbody>
</table>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>要想彻底熟练使用git那需要记住的命令多了去了，起码几百个吧，不过在日常使用中，本文涉及的命令应该是足够用了，有遗漏的常用命令欢迎提出补充。另外，诚心希望您能把参考文章好好读一下，阮老师和廖老师总结的十分到位。本文好多命令也都是使用的两位老师总结的。</p>
</blockquote>
<p>参考文章：</p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">Git命令清单</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详细讲解了Git常用命令的技巧和使用方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#more&quot;&gt;Git命令总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生贵知心，定交无暮早。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="Git" scheme="http://damonare.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(二)——链表</title>
    <link href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <id>http://damonare.github.io/2016/11/09/学习javascript数据结构（二）——链表/</id>
    <published>2016-11-09T07:58:46.661Z</published>
    <updated>2016-11-26T09:49:06.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文详解解释了数据结构中的链表的概念并阐述了如何在javascript中如何去创建一个链表。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生总是直向前行走，从不留下什么。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇博客-<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a>说了栈和队列在javascript中的实现,我们运用javascript提供的API很容易的实现了栈和队列，但这种数据结构有一个很明显的缺点，因为数组大小是固定的所以我们在移除或是添加一项数据的时候成本很高，基本都需要吧数据重排一次。(javascript的Array类方法虽然很方便但背后的原理同样是这样的)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;相比数组我们今天主角——链表就要来的随性的多，简单的理解可以是这样：在内存中，栈和队列（数组）的存在就是一个整体，如果想要对她内部某一个元素进行移除或是添加一个新元素就要动她内部所有的元素，所谓牵一发而动全身；而链表则不一样，每一个元素都是由元素本身数据和指向下一个元素的指针构成，所以添加或是移除某一个元素不需要对链表整体进行操作，只需要改变相关元素的指针指向就可以了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;链表在实际生活中的例子也有很多，比如自行车的链条，环环相扣，但添加或是移除某一个环节只需要对症下药，对相关环节进行操作就OK。再比如：火车，火车就是一个链表，每一节车厢就是元素，想要移除或是添加某一节车厢，只需要把连接车厢的链条改变一下就好了。那么，在javascript中又该怎么去实现链表结构呢？</p>
<h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><p>首先我们要创建一个链表类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//各种属性和方法的声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数据结构来保存链表里面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Node=<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.element=element;</div><div class="line">    <span class="keyword">this</span>.next=<span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Node类表示要添加的元素，他有两个属性，一个是element，表示添加到链表中的具体的值；另一个是next,表示要指向链表中下一个元素的指针。</span></div></pre></td></tr></table></figure>
<p>接下来，我们需要给链表声明一些方法：</p>
<ul>
<li>append(element):向链表尾部添加一个新的元素；</li>
<li>insert(position,element):向链表特定位置插入元素；</li>
<li>remove(element):从链表移除一项；</li>
<li>indexOf(element):返回链表中某元素的索引，如果没有返回-1；</li>
<li>removeAt(position):从特定位置移除一项；</li>
<li>isEmpty():判断链表是否为空，如果为空返回true,否则返回false;</li>
<li>size():返回链表包含的元素个数；</li>
<li>toString():重写继承自Object类的toString()方法，因为我们使用了Node类；</li>
</ul>
<h3 id="链表的完整代码："><a href="#链表的完整代码：" class="headerlink" title="链表的完整代码："></a>链表的完整代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//Node类声明</span></div><div class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//初始化链表长度</span></div><div class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化第一个元素</span></div><div class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="comment">//初始化添加的Node实例</span></div><div class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">            current;</div><div class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="comment">//第一个Node实例进入链表，之后在这个LinkedList实例中head就不再是null了</span></div><div class="line">            head = node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            current = head;</div><div class="line">            <span class="comment">//循环链表知道找到最后一项，循环结束current指向链表最后一项元素</span></div><div class="line">            <span class="keyword">while</span>(current.next)&#123;</div><div class="line">                current = current.next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//找到最后一项元素后，将他的next属性指向新元素node,j建立链接</span></div><div class="line">            current.next = node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新链表长度</span></div><div class="line">        length++;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>)</span>&#123;</div><div class="line">        <span class="comment">//检查是否越界，超过链表长度或是小于0肯定不符合逻辑的</span></div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current = head,</div><div class="line">                previous,</div><div class="line">                index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//在第一个位置添加</span></div><div class="line">                node.next = current;</div><div class="line">                head = node;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素</span></div><div class="line">                <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>)&#123;</span></span></div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">            &#125;</div><div class="line">            //更新链表长度</div><div class="line">            <span class="attr">length</span>++;</div><div class="line">            <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.removeAt</span> = <span class="string">function(position)&#123;</span></div><div class="line">        //检查是否越界，超过链表长度或是小于<span class="attr">0</span>肯定不符合逻辑的</div><div class="line">        <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>)&#123;</span></div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">                <span class="attr">previous</span>,</div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            //移除第一个元素</div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)&#123;</span></div><div class="line">                //移除第一项，相当于<span class="attr">head</span>=<span class="string">null;</span></div><div class="line">                <span class="attr">head</span> = <span class="string">current.next;</span></div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                //循环链表，找到正确位置，循环完毕，<span class="attr">previous</span>，<span class="attr">current</span>分别是被添加元素的前一个和后一个元素</div><div class="line">                <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>)&#123;</div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                //链接<span class="attr">previous</span>和<span class="attr">current</span>的下一个元素，也就是把<span class="attr">current</span>移除了</div><div class="line">                <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length--</span>;</div><div class="line">            <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.indexOf</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">        //循环链表找到元素位置</div><div class="line">        <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">element</span> === <span class="string">current.element)</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="attr">index</span>++;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.remove</span> = <span class="string">function(element)&#123;</span></div><div class="line">        //调用已经声明过的<span class="attr">indexOf</span>和<span class="attr">removeAt</span>方法</div><div class="line">        <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">        <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.isEmpty</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span> === <span class="string">0;</span></div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.size</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getHead</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">head</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.toString</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">string</span> = <span class="string">''</span>;</div><div class="line">        <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">            <span class="attr">string</span> += <span class="string">current.element</span> + (<span class="attr">current.next</span> ? ', ' <span class="attr">:</span> '');</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">string</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.print</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">//一个实例化后的链表，里面是添加的数个<span class="attr">Node</span>类的实例</div></pre></td></tr></table></figure>
<p>ES6版本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> LinkedList2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(element)&#123;</div><div class="line">            <span class="keyword">this</span>.element = element;</div><div class="line">            <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里我们使用WeakMap对象来记录长度状态</span></div><div class="line">    <span class="keyword">const</span> length = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="keyword">const</span> head = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkedList2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            length.set(<span class="keyword">this</span>, <span class="number">0</span>);</div><div class="line">            head.set(<span class="keyword">this</span>, <span class="literal">null</span>);</div><div class="line">        &#125;</div><div class="line">        append(element) &#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getHead() === <span class="literal">null</span>) &#123;</div><div class="line">                head.set(<span class="keyword">this</span>, node);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                current = <span class="keyword">this</span>.getHead();</div><div class="line">                <span class="keyword">while</span> (current.next) &#123;</div><div class="line">                    current = current.next;</div><div class="line">                &#125;</div><div class="line">                current.next = node;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> l = <span class="keyword">this</span>.size();</div><div class="line">            l++;</div><div class="line">            length.set(<span class="keyword">this</span>, l);</div><div class="line">        &#125;</div><div class="line">        insert(position, element) &#123;</div><div class="line">            <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= <span class="keyword">this</span>.size()) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                    current = <span class="keyword">this</span>.getHead(),</div><div class="line">                    previous,</div><div class="line">                    index = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</div><div class="line">                    node.next = current;</div><div class="line">                    head.set(<span class="keyword">this</span>, node);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></div><div class="line">                        <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                        <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">let</span> <span class="attr">l</span> = <span class="string">this.size();</span></div><div class="line">                <span class="attr">l</span>++;</div><div class="line">                <span class="attr">length.set</span>(<span class="attr">this</span>, <span class="attr">l</span>);</div><div class="line">                <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">removeAt</span>(<span class="attr">position</span>) &#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">this.size</span>()) &#123;</span></div><div class="line">                <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                    <span class="attr">previous</span>,</div><div class="line">                    <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">                <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)</span> &#123;</div><div class="line">                    <span class="attr">head.set</span>(<span class="attr">this</span>, <span class="attr">current.next</span>);</div><div class="line">                &#125; <span class="attr">else</span> &#123;</div><div class="line">                    <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>) &#123;</div><div class="line">                        <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                        <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">let</span> <span class="attr">l</span> = <span class="string">this.size();</span></div><div class="line">                <span class="attr">l--</span>;</div><div class="line">                <span class="attr">length.set</span>(<span class="attr">this</span>, <span class="attr">l</span>);</div><div class="line">                <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">remove</span>(<span class="attr">element</span>) &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">            <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">indexOf</span>(<span class="attr">element</span>) &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">                <span class="attr">if</span> (<span class="attr">element</span> === <span class="string">current.element)</span> &#123;</div><div class="line">                    <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="attr">index</span>++;</div><div class="line">                <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">isEmpty</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">this.size</span>() === <span class="string">0;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">size</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">length.get</span>(<span class="attr">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">getHead</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">head.get</span>(<span class="attr">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">toString</span>() &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                <span class="attr">string</span> = <span class="string">''</span>;</div><div class="line">            <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">                <span class="attr">string</span> += <span class="string">current.element</span> + (<span class="attr">current.next</span> ? ', ' <span class="attr">:</span> '');</div><div class="line">                <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">return</span> <span class="attr">string</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="attr">print</span>() &#123;</div><div class="line">            <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="attr">return</span> <span class="attr">LinkedList2</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//NEW</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//NEW</span></div><div class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">            current;</div><div class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>)&#123;</div><div class="line">            head = node;</div><div class="line">            tail = node; <span class="comment">//NEW</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//NEW</span></div><div class="line">            tail.next = node;</div><div class="line">            node.prev = tail;</div><div class="line">            tail = node;</div><div class="line">        &#125;</div><div class="line">        length++;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current = head,</div><div class="line">                previous,</div><div class="line">                index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span> (!head)&#123;       <span class="comment">//NEW</span></div><div class="line">                    head = node;</div><div class="line">                    tail = node;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    node.next = current;</div><div class="line">                    current.prev = node; <span class="comment">//NEW</span></div><div class="line">                    head = node;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (position === length) &#123; <span class="comment">////NEW</span></div><div class="line">                current = tail;   </div><div class="line">                current.next = node;</div><div class="line">                node.prev = current;</div><div class="line">                tail = node;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>)&#123;</span></span></div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">                <span class="attr">current.prev</span> = <span class="string">node;</span> //<span class="attr">NEW</span></div><div class="line">                <span class="attr">node.prev</span> = <span class="string">previous;</span> //<span class="attr">NEW</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length</span>++;</div><div class="line">            <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.removeAt</span> = <span class="string">function(position)&#123;</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>)&#123;</span></div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">                <span class="attr">previous</span>,</div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)&#123;</span> //<span class="attr">NEW</span></div><div class="line">                <span class="attr">if</span> (<span class="attr">length</span> === <span class="string">1)&#123;</span> //</div><div class="line">                    <span class="attr">tail</span> = <span class="string">null;</span></div><div class="line">                &#125; <span class="attr">else</span> &#123;</div><div class="line">                    <span class="attr">head.prev</span> = <span class="string">null;</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">length-1)&#123;</span>  //<span class="attr">NEW</span></div><div class="line">                <span class="attr">current</span> = <span class="string">tail;</span></div><div class="line">                <span class="attr">tail</span> = <span class="string">current.prev;</span></div><div class="line">                <span class="attr">tail.next</span> = <span class="string">null;</span></div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>)&#123;</div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">                <span class="attr">current.next.prev</span> = <span class="string">previous;</span> //<span class="attr">NEW</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length--</span>;</div><div class="line">            <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.remove</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">        <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.indexOf</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">index</span> = <span class="string">-1;</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">            <span class="attr">return</span> <span class="attr">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">index</span>++;</div><div class="line">        <span class="attr">while</span>(<span class="attr">current.next</span>)&#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">                <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            <span class="attr">index</span>++;</div><div class="line">        &#125;</div><div class="line">        //<span class="attr">check</span> <span class="attr">last</span> <span class="attr">item</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">            <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.isEmpty</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span> === <span class="string">0;</span></div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.</span> <span class="attr">size</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.toString</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">s</span> = <span class="string">current</span> ? <span class="attr">current.element</span> <span class="attr">:</span> '';</div><div class="line">        <span class="attr">while</span>(<span class="attr">current</span> &amp;&amp; <span class="attr">current.next</span>)&#123;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            <span class="attr">s</span> += <span class="string">', '</span> + <span class="attr">current.element</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">s</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.inverseToString</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">tail,</span></div><div class="line">            <span class="attr">s</span> = <span class="string">current</span> ? <span class="attr">current.element</span> <span class="attr">:</span> '';</div><div class="line">        <span class="attr">while</span>(<span class="attr">current</span> &amp;&amp; <span class="attr">current.prev</span>)&#123;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.prev;</span></div><div class="line">            <span class="attr">s</span> += <span class="string">', '</span> + <span class="attr">current.element</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">s</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.print</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.printInverse</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.inverseToString</span>());</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getHead</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">head</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getTail</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">tail</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单项比起来就是Node类多了一个prev属性，也就是每一个node不仅仅有一个指向它后面元素的指针也有一个指向它前面的指针。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;明白了前面的基础链表和双向链表之后这个肯定不在话下了，循环，其实就是整个链表实例变成了一个圈，在单项链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了单向循环链表。在双向链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了双向循环链表。就那么回事…</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>说到现在一直都是线性表，就是顺序数据结构，他们都是有顺序的，数据都是一条绳子上的蚂蚱。那么，如果数据是没有顺序的呢？那又该使用哪种数据结构呢？这个放到[学习javascript数据结构(三)——集合]中学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详解解释了数据结构中的链表的概念并阐述了如何在javascript中如何去创建一个链表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more&quot;&gt;学习javascript数据结构(二)——链表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生总是直向前行走，从不留下什么。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Internet协议入门</title>
    <link href="http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
    <id>http://damonare.github.io/2016/11/05/互联网协议入门/</id>
    <published>2016-11-05T04:00:49.017Z</published>
    <updated>2016-11-26T06:00:37.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 博主之前写过一篇博客：<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>,在这篇博客里通过抓包，具体的分析了不同网络协议的传送的数据和传送的方式。而此篇博客则用来作为一个大纲式的内容，按照层级划分，逐步介绍各层级的协议以及他们所起的作用。若有错误之处，欢迎批评指正。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/#more">internet协议入门</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>劳于读书，逸于作文。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</strong></p>
<h4 id="1-1-模型划分"><a href="#1-1-模型划分" class="headerlink" title="1.1 模型划分"></a>1.1 模型划分</h4><p>首先我们需要明白的事互联网的实现是分层级的，那么这个层级的划分根据不同的模型又有一些不同。其中又有两个模型的划分是我们最常见到的，一个是OSI七层划分，另一个是TCP/IP五层划分。他们分别把互联网分成了七层和五层。</p>
<blockquote>
<p>OSI和TCP/IP模型是很基础但又非常重要的网络基础知识</p>
</blockquote>
<p><strong>OSI七层模型</strong></p>
<table>
<thead>
<tr>
<th>OSI的层</th>
<th>功能</th>
<th>TCP/IP协议族</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>没有协议</td>
</tr>
<tr>
<td>会话层</td>
<td>解除或建立与别的接点的联系</td>
<td>没有协议</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据包选择路由</td>
<td>IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>传输有地址的帧以及错误检测功能</td>
<td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr>
<td>物理层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
<td>ISO2110，IEEE802，IEEE802.2</td>
</tr>
</tbody>
</table>
<h4 id="1-2-层与协议"><a href="#1-2-层与协议" class="headerlink" title="1.2 层与协议"></a>1.2 层与协议</h4><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br><br>大家都遵守的规则，就叫做”协议”（protocol）。<br><br>这个协议就是我们所说的<code>互联网协议</code>（internet protocol）,每一层都有若干个协议，他们共同构成了我们所要讲的互联网协议。<br><br>由以上表格我们可以看出，在<code>OSI七层协议</code>模型里会话层和表示层是没有协议的，这里我们取的是<code>TCP/IP</code>模型，分成五层也比较容易解释。<br><br>那么这五层又都是什么呢？从上到下分别是：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>网络设备</th>
</tr>
</thead>
<tbody>
<tr>
<td> 应用层</td>
<td>　也就是用户使用的应用了。</td>
</tr>
<tr>
<td> 传输层</td>
<td>四层交换机、也有工作在四层的路由器</td>
</tr>
<tr>
<td> 网络层</td>
<td>路由器、三层交换机</td>
</tr>
<tr>
<td> 数据链路层</td>
<td>网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</td>
</tr>
<tr>
<td> 物理层</td>
<td>网卡，光纤，CAT-5线，中继器、集线器、还有我们通常说的双绞线也工作在物理层</td>
</tr>
</tbody>
</table>
<p>如上表格所示，最底下的一层叫做<code>物理层</code>（Physical Layer），最上面的一层叫做<code>应用层</code>（Application Layer），中间的三层（自下而上）分别是<code>数据链路层</code>（Data Link Layer）、<code>网络层</code>（Network Layer）和<code>传输层</code>（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。下面来介绍每一层的功能，着重介绍每一层的主要协议</p>
<h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h3><blockquote>
<p>物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性 ——<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="external">物理层(维基百科)</a></p>
</blockquote>
<p>上面维基百科对于物理层的解释说白了就是要把电脑连在一块，方法呢，可以用光缆、电缆、双绞线、无线电波等方式。<br></p>
<p><img src="http://img.blog.csdn.net/20161105225615088" alt="物理层连接"></p>
<p><strong><code>物理层</code>就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>
<h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h3><blockquote>
<p>在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。 ——<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="external">数据链路层(维基百科)</a></p>
</blockquote>
<h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>上面说的网络实体也就是我们日常用到的手机电脑等联网设备了，我们刚刚了解到不同网络实体之间通过一些物理手段（光缆，双绞线，无线电波等）连接在了一起，来进行传输0和1电信号。单纯的传输0和1没有任何意义，肯定是要规定电信号的解读方式，多少个电信号是一组？每一组代表的意义又是什么？</p>
<p><strong>这就是数据链路层的功能，规定这些电信号的分组方式。</strong></p>
<h4 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h4><p>刚刚开始的时候，每一家公司都有自己的一套对于电信号的解读方式，后来随着时间的推移，一种叫做<code>以太网</code>(Ethernet)的协议，占据了主导地位。</p>
<p><strong>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</strong></p>
<p><img src="http://img.blog.csdn.net/20161105231008204" alt="以太网数据包"></p>
<p><code>标头</code>包含数据包的一些说明项，比如发送者、接受者、数据类型等等；<code>数据</code>则是数据包的具体内容。</p>
<p><code>标头</code>的长度，固定为18字节。<code>数据</code>的长度，最短为46字节，最长为1500字节。因此，整个<code>帧</code>最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个<code>帧</code>进行发送。</p>
<h4 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h4><p>我想在日常上网过程中，最为熟悉的就是用一根网线连接端口和电脑了吧，网线连接电脑实际上是连接的这个玩意儿：</p>
<p><img src="http://img.blog.csdn.net/20161105225723932" alt="网卡"></p>
<p>上面就是我们所说的网卡了，它在物理层和数据链路层两个层级工作，正所谓能力越大责任越大，网卡的重要性自然不言而喻了。前面说，以太网规定每一个数据包都有一个<code>标头</code>（Head）来说明发送者，接受者信息，数据类型等信息。而网卡就是以太网规定的来标明发送者和接受者信息的工具。</p>
<p><strong>网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</strong></p>
<p>这个Mac地址自然就是发送者，接受者信息的了，通过这个每台电脑独一无二的地址计算机就能通过一些方式找到另一台电脑了。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<h4 id="3-4-广播"><a href="#3-4-广播" class="headerlink" title="3.4 广播"></a>3.4 广播</h4><p>我们现在有了网卡，也知道每一块网卡都有一个世界上独一无二的Mac地址，那发送者应该怎么去找接受者这台设备呢，换句话说发送者怎么才能知道接受者的Mac地址呢？这就需要另一个协议了叫做ARP协议，这个协议留在后面介绍。这里我们只需要知道，发送者必须要知道接受者的Mac地址才能准确的发送数据。</p>
<p>以太网采用了一种广撒网的方式，发送者发送的数据包会发送给本网络内所有的计算机，然后由接收到数据包的计算机来判断自己是不是接收方。</p>
<p><img src="http://img.blog.csdn.net/20161105192250885" alt="广播"></p>
<p>图片来自<a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF" target="_blank" rel="external">维基百科广播</a>)，如图所示，红色主机是发送方，绿色某一台是接收方，数据包会发送给同一个子网络的所有绿色主机，然后由绿色主机根据数据包的标头来判断自己是不是接收方。如果是，就接受这个包，不是则丢弃。这种发送数据的方式就是<code>广播</code>。</p>
<p>综上，有了对于数据包的定义，网卡的Mac地址，广播的发送方式，数据链路层基本就算完整了，然后不同计算机之间就可以传送数据了。</p>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><blockquote>
<p>网络层使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。  ——<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82" target="_blank" rel="external">网络层(维基百科)</a></p>
</blockquote>
<h4 id="4-1-网络层的产生"><a href="#4-1-网络层的产生" class="headerlink" title="4.1 网络层的产生"></a>4.1 网络层的产生</h4><p>走到这里我们实现的只是在一个子网络里传送数据。但我们知道，互联网实际上是由大大小小的子网络组成的：</p>
<p><img src="http://it.dgzx.net/zxkt/gaoerji/2005-2006-1N/images/lesson06_01.gif" alt="互联网"></p>
<p>大到一个ISP（因特网服务提供商，国内较大的比如移动电信等），小到一个公司的局域网，正事这些大大小小的子网络组成了庞大的互联网体系。但实际上，广播的方式只能在子网络内进行，不同子网络之间广播方式是行不通的。</p>
<p>因此我们需要一种方法能够判断两台主机是否在同一个子网络之内，如果在同一个子网络就以广播的方式传输数据，如果不在同一个子网络就以<code>路由</code>的方式传输（路由是个比较大的概念，本文不涉及），关于路由协议的了解<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">戳这里</a>，MAC地址做不到这一点，它只和厂商有关，和计算机所处的网络并没有关系。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>网址的出现，使得每台计算机都有了两个地址，一个是出生就带着不会改变的Mac地址，一个是后期网络管理员分配的可变的网络地址。网址判断两台计算机是否在同一个子网络，Mac地址则是将数据准确的传递到目标计算机中。因此逻辑上可以判断必定是先处理网络地址，再处理Mac地址。</p>
<h4 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2  IP协议"></a>4.2  IP协议</h4><p><strong>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</strong></p>
<p>现在广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成，IPV6则是64个二进制组成。</p>
<p><img src="http://img.blog.csdn.net/20161105200554600" alt="IP地址"></p>
<p>由于IPV6还没有广泛应用，这里还是用IPV4讲解。一般我们用分成四段（IPV6分成八段）的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。这个地址分成两部分，前一部分是网络部分，后一部分代表主机。But!!!网络部分具体是前16位还是前24位，我们没法从IP地址进行判断，这是我们就需要另一参数叫做<code>子网掩码</code>。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p>那么问题来了，IP地址放在哪里存储呢？是的，我们可以直接存储在前面提到的以太网数据包的Data部分。</p>
<p>IP地址长这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231405610" alt="IP数据包"></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。<br>现在把它加到以太网数据包里面：</p>
<p><img src="http://img.blog.csdn.net/20161105231536033" alt="以太网数据包"></p>
<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h4 id="4-3-ARP协议"><a href="#4-3-ARP协议" class="headerlink" title="4.3 ARP协议"></a>4.3 ARP协议</h4><p>现在为止我们必须知道两个地址，一个是IP地址，一个是Mac地址才能把数据发送到目标主机，那么IP地址是已知的（后文解释），MAC地址怎么获取呢？</p>
<p>我们需要一种能通过IP地址得知MAC地址的机制，这个极致就是ARP协议。</p>
<p>那么，这里又分成两种情况，一种是两台计算机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
<p>另一种情况是两台计算机不在同一个子网络，<br>那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关（后文解释）去处理。</p>
<h4 id="4-4总结"><a href="#4-4总结" class="headerlink" title="4.4总结"></a>4.4总结</h4><p>这一层为止，如果目标主机和本机在同一个子网络，我们通过IP地址，子网掩码比较得出在同一个子网络的结果，在通过ARP协议得到目标主机的Mac地址，发送！Success！</p>
<p>如果目标主机和本机不在同一个子网络，我们通过IP地址，子网掩码比较得出在同一个子网络的结果，然后交给本网络的网关A处理，网关A根据路由协议得到目标主机所在子网络的网关B，网关B再通过IP地址判断得出和目标主机在同一个子网络，然后再通过ARP协议获取Mac地址，发送！Success!</p>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h3><blockquote>
<p>该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。——<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="external">传输层（维基百科）</a></p>
</blockquote>
<h4 id="5-1-传输层的产生"><a href="#5-1-传输层的产生" class="headerlink" title="5.1 传输层的产生"></a>5.1 传输层的产生</h4><p>我们现在成功的实现了主机和主机之间的通信，那么问题又来了，主机之间不同的程序该怎么区分这个数据是不是发送给自己的呢。要知道，当你正在QQ聊天的时候，微信发送过来的消息内容呈现在了QQ界面，这会让计算机懵逼的！太混乱了！</p>
<p>这个时候我们就需要一个新的参数了！这个参数就是<code>端口</code>。</p>
<blockquote>
<p>可连接两个或两个以上不同之电路装置使之能够传递电子或任何形式讯号之装置.——<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">端口（维基百科）</a></p>
</blockquote>
<p>它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>不同的程序在计算机中所占用的端口是不同的，确切的说是不能相同的，否则就混乱了。比如，HTTP所占用的端口一般是80，HTTPS所占用的端口一般是443。</p>
<p><code>端口</code>是0到65535之间的一个整数，正好16个二进制位。0到1023的<code>端口</code>被系统占用，用户只能选用大于1023的<code>端口</code>。不管是浏览网页还是在线聊天，应用程序会随机选用一个<code>端口</code>，然后与服务器的相应<code>端口</code>联系。</p>
<p><strong>确切的说，传输层实现的是端对端的服务，网络层实现的仅仅是主机到主机之间的服务。</strong>只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。</p>
<h4 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h4><p>现在又出了一个新的数据，就是端口信息。现在以太网数据包里已经包括发送者，接受者信息，数据类型，IP地址数据包，UDp数据包。</p>
<p>UDP数据包同样是由标头和数据组成：</p>
<p><img src="http://img.blog.csdn.net/20161105231649143" alt="UDP数据包"></p>
<p><code>标头</code>部分主要定义了发出端口和接收端口，<br><code>数据</code>部分定义了具体的内容。然后把它放在IP地址数据包的数据部分，前面我们说过IP数据包是放在以太网数据包的数据里面的，那么现在整个以太网数据包就成了这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231743213" alt="以太网数据包"></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，一个IP数据包正好可以容纳。</p>
<h4 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h4><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。<br>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<p>关于TCP协议的三次握手和四次挥手过程博主在<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>这篇博客里有较为详细的说明。</p>
<h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h3><blockquote>
<p>应用层直接和应用程序接口并提供常见的网络应用服务。 ——<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="external">应用层（维基百科）</a></p>
</blockquote>
<h4 id="6-1-应用层介绍"><a href="#6-1-应用层介绍" class="headerlink" title="6.1 应用层介绍"></a>6.1 应用层介绍</h4><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231821409" alt="以太网数据包"></p>
<p>上面买的坑改填了，我们前面说过，我们对于目标主机的IP地址肯定知道的，为什么呢？还有就是当两台计算机不在同一个子网络的时候，我们需要通过本机所在子网络的网关A，再通过路由协议得到目标主机子网络的网关B，由网关B将我们要发送给目标主机的数据包发送给目标主机。那么，网关又是什么呢？</p>
<h4 id="6-2-DNS协议"><a href="#6-2-DNS协议" class="headerlink" title="6.2 DNS协议"></a>6.2 DNS协议</h4><p>我们都知道由于IP地址不方便记忆，我们创造了域名这个概念。</p>
<p>DNS（网域名称系统，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<p>例如，damonare.cn是一个域名，和IP地址119.29.180.47相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打damonare的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如 damonare.cn）转化成便于机器识别的IP地址（如119.29.180.47）。</p>
<p>已知DNS服务器为8.8.8.8（这个和IP地址一样管理员告知或是通过自行设置的），于是我们向这个地址发送一个DNS数据包（53端口）：</p>
<p><img src="http://img.blog.csdn.net/20161105231856550" alt="以太网数据包"></p>
<p>DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p>
<h4 id="6-2-网关"><a href="#6-2-网关" class="headerlink" title="6.2 网关"></a>6.2 网关</h4><blockquote>
<p>网关要区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（英语：Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。</p>
</blockquote>
<p><img src="http://image.beekka.com/blog/201206/bg2012061101.jpg" alt="网关作用"></p>
<p>前面我们已经说过发送以太网数据包，需要知道两个地址：</p>
<ul>
<li>对方的MAC地址</li>
<li>对方的IP地址</li>
</ul>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>
<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>
<h4 id="6-3-DHCP协议"><a href="#6-3-DHCP协议" class="headerlink" title="6.3 DHCP协议"></a>6.3 DHCP协议</h4><p>新买的电脑通常你必须做一些设置，才能上网，有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。如下图Window静态IP上网设置界面：</p>
<p><img src="http://nic.ysu.edu.cn/images/13/03/18/44mhv9wgmi/20112261000564.gif" alt=""></p>
<p>这样的设置很专业，但普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>
<p>动态IP地址上网使用的协议就是<code>DHCP协议</code>，这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的<code>MAC地址</code>和<code>IP地址</code>，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p><code>DHCP协议</code>做了一些巧妙的规定。</p>
<p>首先DHCP协议是建立在UDP协议之上，所以整个数据包是这样的：</p>
<p><img src="http://img.blog.csdn.net/20161105231939732" alt="以太网数据包"></p>
<ul>
<li>(1).最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</li>
<li>(2).后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</li>
<li>(3).最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</li>
</ul>
<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>
<p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
<h4 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h4><p>应用层比较重要的协议还有大名鼎鼎的HTTP协议，这个在博主的<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>这篇博客里对于TCP/HTTP协议有较为详细的分析，在这里就不多做介绍了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过整篇博客分析，我想整个互联网的层级划分就很清楚了，也应该明白了数据是如何发送的，大概的过程就是如此，但互联网协议浩如烟海究极一生可能也无法真正理解。此篇博客仅仅作为一个入门，也算是一个大致的思路。关于数据包数据具体的形式，路由，以及其他协议就需要读者自己去进一步发掘理解了。</p>
<p>参考文章：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">互联网协议入门（一）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 博主之前写过一篇博客：&lt;a href=&quot;http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more&quot;&gt;网络协议分析&lt;/a&gt;,在这篇博客里通过抓包，具体的分析了不同网络协议的传送的数据和传送的方式。而此篇博客则用来作为一个大纲式的内容，按照层级划分，逐步介绍各层级的协议以及他们所起的作用。若有错误之处，欢迎批评指正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/#more&quot;&gt;internet协议入门&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;劳于读书，逸于作文。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="网络协议" scheme="http://damonare.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="HTTP" scheme="http://damonare.github.io/tags/HTTP/"/>
    
      <category term="TCP" scheme="http://damonare.github.io/tags/TCP/"/>
    
      <category term="IP" scheme="http://damonare.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 核心功能一览</title>
    <link href="http://damonare.github.io/2016/11/03/JavaScript%20ES6%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A7%88/"/>
    <id>http://damonare.github.io/2016/11/03/JavaScript ES6 核心功能一览/</id>
    <published>2016-11-03T13:22:28.392Z</published>
    <updated>2016-11-26T10:04:59.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文属于转载文章</p>
</blockquote>
<ul>
<li>原文地址：<a href="http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/" target="_blank" rel="external">Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)</a></li>
<li>原文作者：<a href="http://adrianmejia.com/#about" target="_blank" rel="external">Adrian Mejia</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/L9m" target="_blank" rel="external">L9m</a></li>
<li>校对者：<a href="https://github.com/Tina92" target="_blank" rel="external">Tina92</a>，<a href="https://github.com/luoyaqifei" target="_blank" rel="external">luoyaqifei</a>，<a href="https://github.com/theJian" target="_blank" rel="external">theJian</a></li>
</ul>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）"><a href="#JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）" class="headerlink" title="JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）"></a>JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）</h3><p>JavaScript 在过去几年里发生了很大的变化。这里介绍 12 个你马上就能用的新功能。</p>
<h3 id="JavaScript-历史"><a href="#JavaScript-历史" class="headerlink" title="JavaScript 历史"></a>JavaScript 历史</h3><p>新的语言规范被称作 ECMAScript 6。也称为 ES6 或 ES2015+ 。</p>
<p>自从 1995 年 JavaScript 诞生以来，它一直在缓慢地发展。每隔几年就会增加一些新内容。1997 年，ECMAScript 成为 JavaScript 语言实现的规范。它已经有了好几个版本，比如 ES3 , ES5 , ES6 等等。</p>
<p><img src="http://adrianmejia.com/images/history-javascript-evolution-es6.png" alt="" title="JavaScript 发展史"></p>
<p>如你所见，ES3，ES5 和 ES6 之间分别存在着 10 年和 6 年的间隔。像 ES6 那样一次进行大幅修改的模式被逐年渐进式的新模式所替代。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>所有现代浏览器和环境都已支持 ES6。</p>
<p><img src="http://adrianmejia.com/images/es6-javascript-support.png" alt="" title="ES6 Support"></p>
<p>来源: <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a></p>
<p>Chrome，MS Edge，Firefox，Safari，Node 和许多其他的环境都已内置支持大多数的 JavaScript ES6 功能。所以，在本教程中你学到的每个知识，你都可以马上开始应用。</p>
<p>让我们开始学习 ECMAScript 6 吧！</p>
<h3 id="核心-ES6-功能"><a href="#核心-ES6-功能" class="headerlink" title="核心 ES6 功能"></a>核心 ES6 功能</h3><p>你可以在浏览器的控制台中测试所有下面的代码片段。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-classes-on-browser-console.png" alt="" title="Testing Javascript ES6 classes on browser console"></p>
<p>不要笃信我的话，而是要亲自去测试每一个 ES5 和 ES6 示例。让我们开始动手吧 💪</p>
<h4 id="变量的块级作用域"><a href="#变量的块级作用域" class="headerlink" title="变量的块级作用域"></a>变量的块级作用域</h4><p>使用 ES6，声明变量我们可以用 <code>var</code> ，也可以用 <code>let</code> 或 <code>const</code>。</p>
<p><code>var</code> 有什么不足？</p>
<p>使用 <code>var</code> 的问题是变量会漏入其他代码块中，诸如 <code>for</code> 循环或 <code>if</code> 代码块。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> x = <span class="string">'outer'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(inner)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (inner) &#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="string">'inner'</span>; <span class="comment">// 作用于整个 function</span></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> x; <span class="comment">// 因为第四行的声明提升，被重新定义</span></div><div class="line">&#125;</div><div class="line">test(<span class="literal">false</span>); <span class="comment">// undefined 😱</span></div><div class="line">test(<span class="literal">true</span>); <span class="comment">// inner</span></div></pre></td></tr></table></figure>
<p>对于 <code>test(fasle)</code> ，你期望返回 <code>outer</code>，<strong>但是</strong>，你得到的是 <code>undefined</code>。</p>
<p>为什么？</p>
<p>因为尽管没有执行 <code>if</code> 代码块，第四行中的表达式 <code>var x</code> 也会被提升。</p>
<blockquote>
<p>var <strong>提升</strong>：</p>
<ul>
<li><code>var</code> 是函数作用域。在整个函数中甚至是声明语句之前都是可用的。</li>
<li>声明被提升。所以你能在声明之前使用一个变量。</li>
<li>初始化是不被提升的。如果你使用 <code>var</code> 声明变量，请总是将它放在顶部。</li>
<li>在应用了声明提升规则之后，我们就能更容易地理解发生了什么：</li>
</ul>
<pre><code><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> x = <span class="string">'outer'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(inner)</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x; <span class="comment">// 声明提升</span></div><div class="line">    <span class="keyword">if</span> (inner) &#123;</div><div class="line">        x = <span class="string">'inner'</span>; <span class="comment">// 初始化不被提升</span></div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>ECMAScript 2015 找到了解决的办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">let</span> x = <span class="string">'outer'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">inner</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (inner) &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="string">'inner'</span>;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> x; <span class="comment">// 从第一行获取到预期结果</span></div><div class="line">&#125;</div><div class="line">test(<span class="literal">false</span>); <span class="comment">// outer</span></div><div class="line">test(<span class="literal">true</span>); <span class="comment">// inner</span></div></pre></td></tr></table></figure>
<p>将 <code>var</code> 改为 <code>let</code>，代码将像期望的那样运行。如果 <code>if</code> 代码块没有被调用，<code>x</code> 变量也就不会在代码块外被提升。</p>
<blockquote>
<p>let <strong>提升</strong> 和“暂存死区（temporal dead zone）”</p>
<ul>
<li>在 ES6 中，<code>let</code> 将变量提升到代码块的顶部（不是像 ES5 那样的函数顶部）。</li>
<li>然而，代码块中，在变量声明之前引用它会导致 <code>ReferenceError</code> 错误。</li>
<li><code>let</code> 是块级作用域。你不能在它被声明之前引用它。</li>
<li>“暂存死区（Temporal dead zone）”是指从代码块开始直到变量被声明之间的区域。</li>
</ul>
</blockquote>
<p><strong>IIFE</strong></p>
<p>在解释 IIFE 之前让我们看一个例子。来看一下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">var</span> <span class="keyword">private</span> = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">console.<span class="keyword">log</span>(<span class="keyword">private</span>); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>如你所见，<code>private</code> 漏出(代码块)。你需要使用 IIFE（immediately-invoked function expression，立即执行函数表达式）来包含它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> private2 = <span class="number">1</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(private2); <span class="comment">// Uncaught ReferenceError</span></div></pre></td></tr></table></figure>
<p>如果你看一看 jQuery/loadsh 或其他开源项目，你会注意到他们用 IIFE 来避免污染全局环境而且只在全局中定义了诸如 <code>_</code>，<code>$</code>和<code>jQuery</code>。</p>
<p>在 ES6 上则一目了然，我们可以只用代码块和 <code>let</code>，也不再需要使用 IIFE了。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> private3 = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">console.<span class="built_in">log</span>(private3); <span class="comment">// Uncaught ReferenceError</span></div></pre></td></tr></table></figure>
<p><strong>Const</strong></p>
<p>如果你想要一个变量保持不变（常量），你也可以使用 <code>const</code>。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-const-variables-example.png" alt="" title="const variable example"></p>
<blockquote>
<p>总之：用 <code>let</code>，<code>const</code> 而不是 <code>var</code></p>
<ul>
<li>对所有引用使用 <code>const</code>；避免使用 <code>var</code>。</li>
<li>如果你必须重新指定引用，用 <code>let</code> 替代 <code>const</code>。</li>
</ul>
</blockquote>
<h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>有了模板字面量，我们就不用做多余的嵌套拼接了。来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> first = <span class="string">'Adrian'</span>;</div><div class="line"><span class="keyword">var</span> last = <span class="string">'Mejia'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Your name is '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span>);</div></pre></td></tr></table></figure>
<p>现在你可以使用反引号 (`) 和字符串插值 <code>${}</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">const</span> first = <span class="string">'Adrian'</span>;</div><div class="line"><span class="keyword">const</span> last = <span class="string">'Mejia'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>);</div></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>我们再也不需要添加 + <code>\n</code> 来拼接字符串了：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> template = '&lt;<span class="keyword">li</span> *ngFor=<span class="string">"let todo of todos"</span> [ngClass]=<span class="string">"&#123;completed: todo.isDone&#125;"</span> &gt;\<span class="keyword">n</span>' +</div><div class="line">'  &lt;div <span class="keyword">class</span>=<span class="string">"view"</span>&gt;\<span class="keyword">n</span>' +</div><div class="line">'    &lt;<span class="keyword">input</span> <span class="keyword">class</span>=<span class="string">"toggle"</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> [checked]=<span class="string">"todo.isDone"</span>&gt;\<span class="keyword">n</span>' +</div><div class="line">'    &lt;<span class="keyword">label</span>&gt;&lt;/<span class="keyword">label</span>&gt;\<span class="keyword">n</span>' +</div><div class="line">'    &lt;button <span class="keyword">class</span>=<span class="string">"destroy"</span>&gt;&lt;/button&gt;\<span class="keyword">n</span>' +</div><div class="line">'  &lt;/div&gt;\<span class="keyword">n</span>' +</div><div class="line">'  &lt;<span class="keyword">input</span> <span class="keyword">class</span>=<span class="string">"edit"</span> value=<span class="string">""</span>&gt;\<span class="keyword">n</span>' +</div><div class="line">'&lt;/<span class="keyword">li</span>&gt;';</div><div class="line">console.<span class="built_in">log</span>(template);</div></pre></td></tr></table></figure>
<p>在 ES6 上， 我们可以同样使用反引号来解决这个问题：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">const</span> template = `&lt;<span class="keyword">li</span> *ngFor=<span class="string">"let todo of todos"</span> [ngClass]=<span class="string">"&#123;completed: todo.isDone&#125;"</span> &gt;</div><div class="line">  &lt;div <span class="keyword">class</span>=<span class="string">"view"</span>&gt;</div><div class="line">    &lt;<span class="keyword">input</span> <span class="keyword">class</span>=<span class="string">"toggle"</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> [checked]=<span class="string">"todo.isDone"</span>&gt;</div><div class="line">    &lt;<span class="keyword">label</span>&gt;&lt;/<span class="keyword">label</span>&gt;</div><div class="line">    &lt;button <span class="keyword">class</span>=<span class="string">"destroy"</span>&gt;&lt;/button&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;<span class="keyword">input</span> <span class="keyword">class</span>=<span class="string">"edit"</span> value=<span class="string">""</span>&gt;</div><div class="line">&lt;/<span class="keyword">li</span>&gt;`;</div><div class="line">console.<span class="built_in">log</span>(template);</div></pre></td></tr></table></figure>
<p>两段代码的结果是完全一样的。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>ES6 的解构不仅实用而且很简洁。如下例所示：</p>
<p><strong>从数组中获取元素</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line"><span class="built_in">var</span> <span class="built_in">array</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">var</span> <span class="built_in">first</span> = <span class="built_in">array</span>[<span class="number">0</span>];</div><div class="line"><span class="built_in">var</span> <span class="built_in">third</span> = <span class="built_in">array</span>[<span class="number">2</span>];</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">first</span>, <span class="built_in">third</span>); // <span class="number">1</span> <span class="number">3</span></div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const<span class="built_in"> array </span>= [1, 2, 3, 4];<span class="built_in"></span></div><div class="line">const [first, ,third] = array;</div><div class="line">console.log(first, third); // 1 3</div></pre></td></tr></table></figure>
<p><strong>交换值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> tmp = a;</div><div class="line">a = b;</div><div class="line">b = tmp;</div><div class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2 1</span></div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line">[a, b] = [b, a];</div><div class="line">console.<span class="built_in">log</span>(a, b); <span class="comment">// 2 1</span></div></pre></td></tr></table></figure>
<p><strong>多个返回值的解构</strong></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function margin() &#123;</div><div class="line">  var <span class="built_in">left</span>=<span class="number">1</span>, <span class="built_in">right</span>=<span class="number">2</span>, <span class="built_in">top</span>=<span class="number">3</span>, <span class="built_in">bottom</span>=<span class="number">4</span>;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="built_in">left</span>: <span class="built_in">left</span>, <span class="built_in">right</span>: <span class="built_in">right</span>, <span class="built_in">top</span>: <span class="built_in">top</span>, <span class="built_in">bottom</span>: <span class="built_in">bottom</span> &#125;;</div><div class="line">&#125;</div><div class="line">var data = margin();</div><div class="line">var <span class="built_in">left</span> = data.<span class="built_in">left</span>;</div><div class="line">var <span class="built_in">bottom</span> = data.<span class="built_in">bottom</span>;</div><div class="line">console.log(<span class="built_in">left</span>, <span class="built_in">bottom</span>); // <span class="number">1</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<p>在第 3 行中，你也可以用一个像这样的数组返回（同时省去了一些编码）：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> [<span class="built_in">left</span>, <span class="built_in">right</span>, <span class="built_in">top</span>, <span class="built_in">bottom</span>];</div></pre></td></tr></table></figure>
<p>但另一方面，调用者需要考虑返回数据的顺序。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="attribute">left</span> = data[<span class="number">0</span>];</div><div class="line"><span class="selector-tag">var</span> <span class="attribute">bottom</span> = data[<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>用 ES6，调用者只需选择他们需要的数据即可（第 6 行）：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line"></div><div class="line">function margin() &#123;</div><div class="line">  const <span class="built_in">left</span>=<span class="number">1</span>, <span class="built_in">right</span>=<span class="number">2</span>, <span class="built_in">top</span>=<span class="number">3</span>, <span class="built_in">bottom</span>=<span class="number">4</span>;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="built_in">left</span>, <span class="built_in">right</span>, <span class="built_in">top</span>, <span class="built_in">bottom</span> &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; <span class="built_in">left</span>, <span class="built_in">bottom</span> &#125; = margin();</div><div class="line">console.log(<span class="built_in">left</span>, <span class="built_in">bottom</span>); // <span class="number">1</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<p><em>注意：</em> 在第 3 行中，我们使用了一些其他的 ES6 功能。我们将 <code>{ left: left }</code> 简化到只有 <code>{ left }</code>。与 ES5 版本相比，它变得如此简洁。酷不酷？</p>
<p><strong>参数匹配的解构</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> user = &#123;firstName: <span class="string">'Adrian'</span>, lastName: <span class="string">'Mejia'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">var</span> lastName = user.lastName;</div><div class="line">  <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(getFullName(user)); <span class="comment">// Adrian Mejia</span></div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">const</span> user = &#123;firstName: <span class="string">'Adrian'</span>, lastName: <span class="string">'Mejia'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(getFullName(user)); <span class="comment">// Adrian Mejia</span></div></pre></td></tr></table></figure>
<p><strong>深度匹配</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">settings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; display: &#123; color: <span class="string">'red'</span> &#125;, keyboard: &#123; layout: <span class="string">'querty'</span>&#125; &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> tmp = settings();</div><div class="line"><span class="keyword">var</span> displayColor = tmp.display.color;</div><div class="line"><span class="keyword">var</span> keyboardLayout = tmp.keyboard.layout;</div><div class="line"><span class="built_in">console</span>.log(displayColor, keyboardLayout); <span class="comment">// red querty</span></div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line">function settings() &#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="string">display:</span> &#123; <span class="string">color:</span> <span class="string">'red'</span> &#125;, <span class="string">keyboard:</span> &#123; <span class="string">layout:</span> <span class="string">'querty'</span>&#125; &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; <span class="string">display:</span> &#123; <span class="string">color:</span> displayColor &#125;, <span class="string">keyboard:</span> &#123; <span class="string">layout:</span> keyboardLayout &#125;&#125; = settings();</div><div class="line">console.log(displayColor, keyboardLayout); <span class="comment">// red querty</span></div></pre></td></tr></table></figure>
<p>这也称作对象的解构。</p>
<p>如你所见，解构是非常实用的而且有利于促进良好的编码风格。</p>
<blockquote>
<p>最佳实践:</p>
<ul>
<li>使用数组解构去获取元素或交换值。它可以避免创建临时引用。</li>
<li>不要对多个返回值使用数组解构，而是要用对象解构。</li>
</ul>
</blockquote>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>用 ECMAScript 6，我们从“构造函数”🔨 来到了“类”🍸。</p>
<blockquote>
<p>在 JavaScript 中，每个对象都有一个原型对象。所有的 JavaScript 对象都从它们的原型对象那里继承方法和属性。</p>
</blockquote>
<p>在 ES5 中，为了实现面向对象编程（OOP），我们使用构造函数来创建对象，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  MyConstructor.prototype.speak = <span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> MyConstructor;</div><div class="line">&#125;)();</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'animal'</span>);</div><div class="line">animal.speak(); <span class="comment">// animal makes a noise.</span></div></pre></td></tr></table></figure></p>
<p>ES6 中有了一些语法糖。通过像 <code>class</code> 和 <code>constructor</code> 这样的关键字和减少样板代码，我们可以做到同样的事情。另外，<code>speak()</code> 相对照 <code>constructor.prototype.speak = function ()</code>  更加清晰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">  speak() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal(<span class="string">'animal'</span>);</div><div class="line">animal.speak(); <span class="comment">// animal makes a noise.</span></div></pre></td></tr></table></figure>
<p>正如你所见，两种式样（ES5 与 6）在幕后产生相同的结果而且用法一致。</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>总是使用 <code>class</code> 语法并避免直接直接操纵 <code>prototype</code>。为什么？因为它让代码更加简洁和易于理解。</li>
<li>避免使用空的构造函数。如果没有指定，类有一个默认的构造函数。</li>
</ul>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>基于前面的 <code>Animal</code> 类。 让我们扩展它并定义一个 <code>Lion</code> 类。</p>
<p>在 ES5 中，它更多的与原型继承有关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> Lion = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyConstructor</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    Animal.call(<span class="keyword">this</span>, name);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 原型继承</span></div><div class="line">  MyConstructor.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</div><div class="line">  MyConstructor.prototype.constructor = Animal;</div><div class="line">  MyConstructor.prototype.speak = <span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Animal.prototype.speak.call(<span class="keyword">this</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' roars 🦁'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> MyConstructor;</div><div class="line">&#125;)();</div><div class="line"><span class="keyword">var</span> lion = <span class="keyword">new</span> Lion(<span class="string">'Simba'</span>);</div><div class="line">lion.speak(); <span class="comment">// Simba makes a noise.</span></div><div class="line"><span class="comment">// Simba roars.</span></div></pre></td></tr></table></figure>
<p>我不会重复所有的细节，但请注意：</p>
<ul>
<li>第 3 行中，我们添加参数显式调用了 <code>Animal</code> 构造函数。</li>
<li>第 7-8 行，我们将 <code>Lion</code> 原型指派给 <code>Animal</code> 原型。</li>
<li>第 11行中，我们调用了父类 <code>Animal</code> 的 <code>speak</code> 方法。</li>
</ul>
<p>在 ES6 中，我们有了新关键词 <code>extends</code> 和 <code>super</code> <img src="http://adrianmejia.com/images/superman_shield.svg" width="25" height="25" alt="superman shield" style="display:inline-block;" data-pin-nopin="true">。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  speak() &#123;</div><div class="line">    <span class="keyword">super</span>.speak();</div><div class="line">    console.log(<span class="keyword">this</span>.name + ' roars 🦁');</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const lion = <span class="keyword">new</span> <span class="type">Lion</span>(<span class="symbol">'Simb</span>a');</div><div class="line">lion.speak(); <span class="comment">// Simba makes a noise.</span></div><div class="line"><span class="comment">// Simba roars.</span></div></pre></td></tr></table></figure>
<p>虽然 ES6 和 ES5 的代码作用一致，但是 ES6 的代码显得更易读。更胜一筹！</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>使用  <code>extends</code> 内置方法实现继承。</li>
</ul>
</blockquote>
<h4 id="原生-Promises"><a href="#原生-Promises" class="headerlink" title="原生 Promises"></a>原生 Promises</h4><p>从回调地狱 👹 到 promises 🙏。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAfterTimeout</span>(<span class="params">string, timeout, done</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    done(<span class="built_in">string</span>);</div><div class="line">  &#125;, timeout);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(<span class="string">'Hello '</span>, <span class="number">2e3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">  <span class="comment">// 嵌套回调</span></div><div class="line">  printAfterTimeout(result + <span class="string">'Reader'</span>, <span class="number">2e3</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(result);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们有一个接收一个回调的函数，当 <code>done</code> 时执行。我们必须一个接一个地执行它两次。这也是为什么我们在回调中第二次调用  <code>printAfterTimeout</code> 的原因。</p>
<p>如果你需要第 3 次或第 4 次回调，可能很快就会变得混乱。来看看我们用 promises 的写法：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> ES6</div><div class="line">function printAfterTimeout(string, timeout)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      resolve(string);</div><div class="line">    &#125;, timeout);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(<span class="string">'Hello '</span>, <span class="number">2e3</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(result)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">  <span class="keyword">return</span> printAfterTimeout(result + <span class="string">'Reader'</span>, <span class="number">2e3</span>);</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(result)</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如你所见，使用 promises 我们能在函数完成后进行一些操作。不再需要嵌套函数。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 没有移除函数表达式，但是新增了一种，叫做箭头函数。</p>
<p>在 ES5 中，对于 <code>this</code> 我们有一些问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> _this = <span class="keyword">this</span>; <span class="comment">// 保持一个引用</span></div><div class="line">$(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  _this.sendData(); <span class="comment">// 引用的是外层的 this</span></div><div class="line">&#125;);</div><div class="line">$(<span class="string">'.input'</span>).on(<span class="string">'change'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.sendData(); <span class="comment">// 引用的是外层的 this</span></div><div class="line">&#125;.bind(<span class="keyword">this</span>)); <span class="comment">// 绑定到外层的 this</span></div></pre></td></tr></table></figure>
<p>你需要使用一个临时的 <code>this</code> 在函数内部进行引用或用 <code>bind</code> 绑定。在 ES6 中，你可以用箭头函数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="comment">// 引用的是外部的那个 this</span></div><div class="line">$(<span class="string">'.btn'</span>).click((<span class="keyword">event</span>) =&gt;  <span class="keyword">this</span>.sendData());</div><div class="line"><span class="comment">// 隐式返回</span></div><div class="line"><span class="keyword">const</span> ids = [<span class="number">291</span>, <span class="number">288</span>, <span class="number">984</span>];</div><div class="line"><span class="keyword">const</span> messages = ids.map(<span class="keyword">value</span> =&gt; `ID <span class="keyword">is</span> $&#123;<span class="keyword">value</span>&#125;`);</div></pre></td></tr></table></figure>
<h4 id="For…of"><a href="#For…of" class="headerlink" title="For…of"></a>For…of</h4><p>从 <code>for</code> 到 <code>forEach</code> 再到 <code>for...of</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="comment">// for</span></div><div class="line"><span class="keyword">var</span> <span class="keyword">array</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</div><div class="line">  <span class="keyword">var</span> element = <span class="keyword">array</span>[i];</div><div class="line">  console.log(element);</div><div class="line">&#125;</div><div class="line"><span class="comment">// forEach</span></div><div class="line"><span class="keyword">array</span>.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;</div><div class="line">  console.log(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ES6 的 for…of 同样可以实现迭代。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="comment">// for ...of</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">array</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element of <span class="built_in">array</span>) &#123;</div><div class="line">    console.<span class="built_in">log</span>(element);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>从检查一个变量是否被定义到重新指定一个值再到 <code>default parameters</code>。<br>你以前写过类似这样的代码吗？</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span>(<span class="params">x, y, isFlag</span>)</span>&#123;</div><div class="line">  x = x || <span class="number">0</span>;</div><div class="line">  y = y || <span class="number">-1</span>;</div><div class="line">  isFlag = isFlag || <span class="literal">true</span>;</div><div class="line">  <span class="built_in">console</span>.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 0 -1 true 😱</span></div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>) <span class="comment">// 0 -1 true 😱😱</span></div><div class="line"><span class="built_in">point</span>(<span class="number">1</span>) <span class="comment">// 1 -1 true</span></div><div class="line"><span class="built_in">point</span>() <span class="comment">// 0 -1 true</span></div></pre></td></tr></table></figure>
<p>可能有过，这是一种检查变量是否赋值的常见模式，不然则分配一个默认值。然而，这里有一些问题：</p>
<ul>
<li>第 8 行中，我们传入 <code>0, 0</code> 返回了 <code>0, -1</code>。</li>
<li>第 9 行中， 我们传入 <code>false</code> 但是返回了 <code>true</code>。</li>
</ul>
<p>如果你传入一个布尔值作为默认参数或将值设置为 0，它不能正常起作用。你知道为什么吗？在讲完 ES6 示例后我会告诉你。</p>
<p>用 ES6，现在你可以用更少的代码做到更好！</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span>(<span class="params">x = 0, y = -1, isFlag = true</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 0 0 true</span></div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>) <span class="comment">// 0 0 false</span></div><div class="line"><span class="built_in">point</span>(<span class="number">1</span>) <span class="comment">// 1 -1 true</span></div><div class="line"><span class="built_in">point</span>() <span class="comment">// 0 -1 true</span></div></pre></td></tr></table></figure>
<p>请注意第 5 行和第 6 行，我们得到了预期的结果。ES5 示例则无效。首先检查是否等于 <code>undefined</code>，因为 <code>false</code>，<code>null</code>，<code>undefined</code> 和 <code>0</code> 都是假值，我们可以避开这些数字，</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">point</span>(<span class="params">x, y, isFlag</span>)</span>&#123;</div><div class="line">  x = x || <span class="number">0</span>;</div><div class="line">  y = <span class="keyword">typeof</span>(y) === <span class="string">'undefined'</span> ? <span class="number">-1</span> : y;</div><div class="line">  isFlag = <span class="keyword">typeof</span>(isFlag) === <span class="string">'undefined'</span> ? <span class="attribute">true</span> : isFlag;</div><div class="line">  <span class="built_in">console</span>.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 0 0 true</span></div><div class="line"><span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>) <span class="comment">// 0 0 false</span></div><div class="line"><span class="built_in">point</span>(<span class="number">1</span>) <span class="comment">// 1 -1 true</span></div><div class="line"><span class="built_in">point</span>() <span class="comment">// 0 -1 true</span></div></pre></td></tr></table></figure>
<p>当我们检查是否为 <code>undefined</code> 后，获得了期望的结果。</p>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>从参数到剩余参数和扩展操作符。</p>
<p>在 ES5 中，获取任意数量的参数是非常麻烦的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printf</span>(<span class="params">format</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> params = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'params: '</span>, params);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'format: '</span>, format);</div><div class="line">&#125;</div><div class="line">printf(<span class="string">'%s %d %.2f'</span>, <span class="string">'adrian'</span>, <span class="number">321</span>, <span class="built_in">Math</span>.PI);</div></pre></td></tr></table></figure>
<p>我们可以用 rest 操作符 <code>...</code> 做到同样的事情。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printf</span><span class="params">(format, <span class="rest_arg">...params</span>)</span> </span>&#123;</div><div class="line">  console.log(<span class="string">'params: '</span>, params);</div><div class="line">  console.log(<span class="string">'format: '</span>, format);</div><div class="line">&#125;</div><div class="line">printf(<span class="string">'%s %d %.2f'</span>, <span class="string">'adrian'</span>, <span class="number">321</span>, Math.PI);</div></pre></td></tr></table></figure>
<h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>从 <code>apply()</code> 到展开运算符。我们同样用 <code>...</code> 来解决：</p>
<blockquote>
<p>提醒：我们使用 <code>apply()</code> 将数组转换为一列参数。例如，<code>Math.max()</code> 作用于一列参数，但是如果我们有一个数组，我们就能用 <code>apply</code> 让它生效。</p>
</blockquote>
<p><img src="http://adrianmejia.com/images/javascript-math-apply-arrays.png" alt="" title="JavaScript Math apply for arrays"></p>
<p>正如我们较早之前看过的，我们可以使用 <code>apply</code> 将数组作为参数列表传递：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line">Math.max.apply(Math, [<span class="number">2</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">43</span>]) <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line">Math.max(...[<span class="number">2</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">43</span>]) <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>同样，从 <code>concat</code> 数组到使用展开运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> array1 = [<span class="number">2</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">43</span>];</div><div class="line"><span class="keyword">var</span> array2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line"><span class="keyword">var</span> array3 = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</div><div class="line"><span class="built_in">console</span>.log(array1.concat(array2, array3));</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符来压平嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">const</span> array1 = [<span class="number">2</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">43</span>];</div><div class="line"><span class="keyword">const</span> array2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line"><span class="keyword">const</span> array3 = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</div><div class="line"><span class="built_in">console</span>.log([...array1, ...array2, ...array3]);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 经历了相当多的修改。这篇文章涵盖了每个 JavaScript 开发者都应该了解的大多数核心功能。同样，我们也介绍了一些让你的代码更加简洁，易于理解的最佳实践。</p>
<p>如果你认为还有一些没有提到的<strong>必知</strong>的功能，请在下方留言，我会更新这篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文属于转载文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/&quot;&gt;Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://adrianmejia.com/#about&quot;&gt;Adrian Mejia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/L9m&quot;&gt;L9m&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/Tina92&quot;&gt;Tina92&lt;/a&gt;，&lt;a href=&quot;https://github.com/luoyaqifei&quot;&gt;luoyaqifei&lt;/a&gt;，&lt;a href=&quot;https://github.com/theJian&quot;&gt;theJian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="转载" scheme="http://damonare.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="ES6" scheme="http://damonare.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(一)——栈和队列</title>
    <link href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://damonare.github.io/2016/11/01/学习javascript数据结构（一）——栈和队列/</id>
    <published>2016-11-01T13:16:54.812Z</published>
    <updated>2016-11-26T09:51:16.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>只要你不计较得失，人生还有什么不能想法子克服的。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。javascript也有数组类型，而数组呢，其实就是一种特殊的栈或是队列，利用javascript&nbsp;Array所内置的API可以很方便的模拟栈和队列。</p>
<blockquote>
<p>我想对于数组每一个学过编程语言的都不会陌生吧，我们知道，我们可以在数组的任意位置添加或是删除元素，然而，有时候我们还需要一种在添加或是删除元素的时候有更多控制的数据结构。有两种数据结构类似于数组。但在添加或是删除元素的时候更为的可控。他们就是栈和队列。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或是待删除的元素都保存在栈的末尾。我们称作栈顶，而另一端我们称作栈底。</strong><br><br><br>在现实生活中就有很多栈的例子，比如下图的书本，这一摞书如果要取肯定是先去最上面的那一本，但它是最后一个放上去的，也就是栈顶的元素都是待添加或是待删除的。这就是后进先出的实际例子。<br></p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145616341" alt="栈"></p>
</blockquote>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><p>首先我们先创建一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//各种属性和方法的声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数据结构来保存栈里面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来，我们需要给栈声明一些方法：</p>
<ul>
<li>push(element):添加一个或是几个新元素到栈顶。</li>
<li>pop():移除栈顶的元素，同时返回被移除元素。</li>
<li>peek():返回栈顶的元素，但并不对栈顶的元素做出任何的修改。</li>
<li>isEmpty():检查栈内是否有元素，如果有返回true，没有返回false。</li>
<li>clear():清除栈里的元素。</li>
<li>size():返回栈的元素个数。</li>
<li>print():打印栈里的元素。</li>
</ul>
<h4 id="栈的完整代码"><a href="#栈的完整代码" class="headerlink" title="栈的完整代码"></a>栈的完整代码</h4><p>我们通过javascript提供的API，实现栈如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.pop();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[items.length<span class="number">-1</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.toString();</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _items = <span class="built_in">Symbol</span>();</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack2</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    push(element)&#123;</div><div class="line">        <span class="keyword">this</span>[_items].push(element);</div><div class="line">    &#125;</div><div class="line">    pop()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].pop();</div><div class="line">    &#125;</div><div class="line">    peek()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items][<span class="keyword">this</span>[_items].length<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    isEmpty()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    size()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length;</div><div class="line">    &#125;</div><div class="line">    clear()&#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    print()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">    toString()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>创建完了栈，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack=<span class="keyword">new</span> Stack();</div><div class="line"><span class="built_in">console</span>.log(stack.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">stack.push(<span class="number">1</span>);</div><div class="line">stack.push(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(stack.peek());</div><div class="line"><span class="comment">//输出栈顶元素3</span></div><div class="line"><span class="built_in">console</span>.log(stack.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<p>其余方法调用读者可自行尝试。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>我们已经接触了栈，接下来要说的队列和栈十分相似，他们都是线性表，元素都是有序的<br>。队列和栈不同的是，队列遵循的是FIFO，也就是先进先出的原则。队列从尾部添加新元素，从顶部移除元素，最新添加的元素必须排列在队列的末尾。</strong><br><br><br>在现实生活中，最常见的队列就是排队，如下图，先进入队列的先接受服务，后进入队列的必须排在队列末尾。</p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145601043" alt="队列"></p>
</blockquote>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><p>首先我们声明一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是队列的属性和方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们同样创建一个保存元素的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来声明一些队列可用的方法：</p>
<ul>
<li>enqueue(element):向队列尾部添加一个（或是多个）元素。</li>
<li>dequeue():移除队列的第一个元素，并返回被移除的元素。</li>
<li>front():返回队列的第一个元素——最先被添加的也是最先被移除的元素。队列不做任何变动。</li>
<li>isEmpty():检查队列内是否有元素，如果有返回true，没有返回false。</li>
<li>size():返回队列的长度。</li>
<li>print():打印队列的元素。</li>
</ul>
<h4 id="队列的完整代码"><a href="#队列的完整代码" class="headerlink" title="队列的完整代码"></a>队列的完整代码</h4><p>我们通过javascript提供的API，实现队列如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.shift();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Queue2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        enqueue(element) &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            q.push(element);</div><div class="line">        &#125;</div><div class="line">        dequeue() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">let</span> r = q.shift();</div><div class="line">            <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        front() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        isEmpty()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).length == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q.length;</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        print()&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">        &#125;</div><div class="line">        toString()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Queue2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>创建完了队列，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> Queue();</div><div class="line"><span class="built_in">console</span>.log(queue.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">queue.enqueue(<span class="number">1</span>);</div><div class="line">queue.enqueue(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(queue.front());</div><div class="line"><span class="comment">//返回队列的第一个元素1</span></div><div class="line"><span class="built_in">console</span>.log(queue.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>这篇博客使用javascript实现了栈和队列这两种数据结构。关于具体的应用的有机会补上。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more&quot;&gt;学习javascript数据结构(一)——栈和队列&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只要你不计较得失，人生还有什么不能想法子克服的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>详解Javascript的类(单身狗请自觉进入)</title>
    <link href="http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/"/>
    <id>http://damonare.github.io/2016/11/01/详解javascript的类/</id>
    <published>2016-11-01T03:11:18.192Z</published>
    <updated>2016-11-26T09:45:40.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文详细讲述了javascript中类的由来实现以及一些类知识的延伸。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/#more">详解javascript的类</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>生活有度，人生添寿。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>&nbsp;&nbsp;Javascript从当初的一个“弹窗语言”，一步步发展成为现在前后端通吃的庞然大物。javascript的受欢迎程度也是与日俱增，今年最受欢迎编程语言又是花落javascript，这实在是一个充满了活力的语言。如今，随随便一个网页javascript代码量都不下数千行，要是node后端那更不止几千行了。（WTF）代码量的增加给编程带来的首要的问题就是如何去编写和维护如此庞大的代码呢？答案就是模块化思想，其实就是面向对象（OOP）编程，如今比较流行的三大前端框架（angular,react,vue）基本都实现了组件化编程，但组件化和我们所说的模块化又有所不同，应该可以这么理解，组件化是模块化的升级版，模块化是组件化的基础。那么，问题来了，javascript怎么面向对象编程呢？我想这很多老鸟也不定说的清楚吧，前端杂而活跃的各种社区，很多前端er一度依赖各种插件，根本不需要去了解这些深层的东西却照样能完成任务。但我想作为一个有追求的前端er还是很有必要去学习这些看似用不着的东西的，别的不说，就单单因为我们是前端er,只会用jquery一个稍微厉害的后端都能代替你。好吧，废话不多说，到底如何面向对象coding呢…..<br><br><br>&nbsp;&nbsp;很不幸，es5中并没有给出明确的定义‘类’的概念，所以传统的面向对象编程似乎是行不通的，那么又该肿么办呢？值得庆幸的是，前辈们通过不断探索总结，成功的用javascript模拟出了“类”。那么，javascript的类又该怎么定义呢？<br><br></p>
</blockquote>
<p><strong>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。</strong></p>
<blockquote>
<p>说到javascript中的“类”就不得不说原型链和继承了，因为javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。</p>
</blockquote>
<h4 id="1-原型链和继承"><a href="#1-原型链和继承" class="headerlink" title="1. 原型链和继承"></a>1. 原型链和继承</h4><p>“<br>    在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。<br>”<br></p>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><blockquote>
<p>实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。那么我们都是如何定义一个对象的呢，博主总结的方法如下几个：</p>
</blockquote>
<p>先初步来个demo具体解释下原型链是咋回事吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__  属性（现已弃用）。。从 ES6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个方法可以放心使用博主亲测，主流浏览器已经支持了</span></div><div class="line"><span class="comment">// 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下:</span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125;---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div></pre></td></tr></table></figure>
<p><strong>来来来，撸袖子搞出个对象！！！（马上狗节，单身狗请自觉阅读完此篇博客）</strong></p>
<ul>
<li><strong>使用普通方法来创建一个对象</strong></li>
</ul>
<p><strong>demo如下:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o=&#123;</div><div class="line">    a:<span class="number">0</span>,</div><div class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个对象</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//o---&gt;Object.prototype---&gt;null</span></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</div><div class="line"><span class="comment">//创建一个数组对象</span></div><div class="line"><span class="comment">//(indexOf, forEach等方法都是从它继承而来).</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//a---&gt;Array.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个函数对象</span></div><div class="line"><span class="comment">//(call, bind等方法都是从它继承而来):</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">//创建一个日期对象</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//date---&gt;Date.prototype---&gt;Object.pprototype---&gt;null</span></div></pre></td></tr></table></figure>
<ul>
<li>使用构造函数的方法</li>
</ul>
<blockquote>
<p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。——MDN</p>
</blockquote>
<p><strong>demo如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.propA=<span class="string">'prop'</span>;</div><div class="line">    <span class="keyword">this</span>.propB=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">fun.prototype=&#123;</div><div class="line">    methodA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.propA)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> fun();</div><div class="line">o.methodA();<span class="comment">//prop</span></div><div class="line"></div><div class="line"><span class="comment">// o是生成的对象,他的自身属性有'propA'和'propB'.</span></div><div class="line"><span class="comment">// 在o被实例化时,o.[[Prototype]]指向了fun.prototype.</span></div></pre></td></tr></table></figure>
<ul>
<li>使用Object.create创建对象</li>
</ul>
<blockquote>
<p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;a: <span class="number">1</span>&#125;;</div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)继承概念下面会讲</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure>
<ul>
<li>使用 class 关键字</li>
</ul>
<blockquote>
<p>ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义一个类Polygon</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;<span class="comment">//使用super引用父类</span></div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用extends定义Squeare继承父类Polygon</span></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);<span class="comment">//实例对象</span></div><div class="line"></div><div class="line"><span class="comment">//此时的原型链为：</span></div><div class="line"><span class="comment">//square---&gt;Square.prototype---&gt;Polygon.prototype---&gt;Object.prototype---&gt;null</span></div><div class="line"><span class="comment">//如果不理解为什么是这样，不要紧接着往下看类的说明</span></div></pre></td></tr></table></figure>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>其实在上面讲原型链的时候难以避免的也提到了继承，比如来自MDN的这个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：（someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__  属性（现已弃用）。。从 ES6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。）</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下:</span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></div><div class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></div><div class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></div><div class="line"><span class="comment">// o.[[Prototype]]上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></div><div class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// o.[[Prototype]].[[Prototype]]为null，停止搜索，</span></div><div class="line"><span class="comment">// 没有d属性，返回undefined</span></div></pre></td></tr></table></figure>
<p><strong>—-以上内容来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">MDN继承与原型链</a></strong></p>
<p>我想看到这里还是有些似懂非懂吧，那么来个例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object1=&#123;</div><div class="line">    a:<span class="number">1</span>,</div><div class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义一个对象</span></div><div class="line"><span class="keyword">var</span> object2=<span class="built_in">Object</span>.create(object1);</div><div class="line"><span class="comment">//调用Object.create来创建一个新对象,新对象的原型就是调用 create 方法时传入的第一个参数,现在的原型链是：</span></div><div class="line"><span class="comment">//object2---&gt;object1---&gt;object1.prototype---&gt;null</span></div><div class="line">object2.d=<span class="number">4</span>;</div><div class="line">object2.a;</div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//继承了object1的属性a</span></div><div class="line">object2.b();</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//继承了object1的方法b</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(object2);</div><div class="line"><span class="comment">//object1得到object2的原型object1</span></div></pre></td></tr></table></figure>
<p>我想现在应该是明白了吧，再不明白博主也是无能为力了，表达能力实在有限。</p>
<h4 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h4><blockquote>
<p>总算说到类了，由于javascript的类基于原型链和继承，因此在上面的内容中就已经定义了很多的类。咱们javascript的类同样能实现传统类的多态，封装，继承等特性，这里主要讲解了继承这个概念，但实际上很多时候不经意可能就用了这三个特性。很好玩不是么</p>
</blockquote>
<p>首先，我们先看下在ES5中定义一个类的形式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Animal(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.sleep = function() &#123;</div><div class="line">        console.log(this.name+'正在睡觉');</div><div class="line">    &#125;</div><div class="line">&#125;//定义Animal类</div><div class="line">Animal.prototype = &#123;</div><div class="line">    eat: function(food) &#123;</div><div class="line">        console.log(this.name+"正在吃"+food);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function Cat() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Cat.prototype = new Animal('Tom');</div><div class="line">var Tom = new Cat('Tom');/Cat实例对象</div><div class="line">Tom.eat('猫粮');</div><div class="line">//Tom正在吃猫粮</div><div class="line">//继承Animal方法</div><div class="line">Tom.sleep();</div><div class="line">//Tom正在睡觉</div><div class="line">//继承Animal方法</div><div class="line">//现在的原型链：</div><div class="line">//Tom(Cat实例对象)---&gt;Cat.prototype(Animal实例对象)---&gt;Animal.prototype---&gt;Object.prototype---&gt;null</div></pre></td></tr></table></figure>
<p>好的，然后我们看下在ES6中改写上面的类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sleep() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' 正在睡觉'</span>);</div><div class="line">  &#125;</div><div class="line">  eat(food)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'正在吃'</span>+food)  </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Tom = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</div><div class="line">Tom.eat(<span class="string">'猫粮'</span>);</div><div class="line"><span class="comment">//Tom正在吃猫粮</span></div><div class="line"><span class="comment">//继承Animal方法</span></div><div class="line">Tom.sleep();</div><div class="line"><span class="comment">//Tom正在睡觉</span></div><div class="line"><span class="comment">//继承Animal方法</span></div><div class="line"><span class="comment">//现在的原型链：</span></div><div class="line"><span class="comment">//Tom(Cat实例对象)---&gt;Cat.prototype(Animal实例对象)---&gt;Animal.prototype---&gt;Object.prototype---&gt;null</span></div></pre></td></tr></table></figure>
<p>定义一个类的方法实际上也是上面所说的定义一个对象的方法，类本身就是一个对象，只不过这个对象里面的方法和属性可以供许多实例对象调用而已。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>总的来说对于类的理解还是需要不断探索的，路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详细讲述了javascript中类的由来实现以及一些类知识的延伸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/#more&quot;&gt;详解javascript的类&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;生活有度，人生添寿。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="深度玄学" scheme="http://damonare.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>http://damonare.github.io/2016/10/30/前端跨域整理/</id>
    <published>2016-10-30T07:24:24.028Z</published>
    <updated>2016-12-01T13:57:50.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more">前端跨域总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生在勤，不索何获。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h3><blockquote>
<p> 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">URL                      说明       是否允许通信</div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名下   允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/lab/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/script/b.js 同一域名下不同文件夹 允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com:8000/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名，不同端口  不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">https:<span class="comment">//www.a.com/b.js 同一域名，不同协议 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//70.32.92.74/b.js 域名和域名对应ip 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.cnblogs.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js 不同域名 不允许</span></div></pre></td></tr></table></figure>
<p><strong>这里我们需要注意两点:</strong></p>
<ol>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ol>
<h3 id="2-通过document-domain跨域"><a href="#2-通过document-domain跨域" class="headerlink" title="2. 通过document.domain跨域"></a>2. 通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。 第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('￼ifame');</div><div class="line">        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。" target="_blank" rel="external">http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>
</blockquote>
<ul>
<li>在页面<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 中设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'￼iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在页面<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a> 中也设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>修改document.domain的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="3-通过location-hash跨域"><a href="#3-通过location-hash跨域" class="headerlink" title="3. 通过location.hash跨域"></a>3. 通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明：</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。</p>
<ul>
<li>a.html传送数据到b.html<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
<li><p>b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”<a href="http://www.baidu.com/proxy.html#data" target="_blank" rel="external">http://www.baidu.com/proxy.html#data</a>“</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
</ul>
<p>b.html页面的关键代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">    parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></div><div class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy.html页面的关键代码如下 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h3 id="4-通过HTML5的postMessage方法跨域"><a href="#4-通过HTML5的postMessage方法跨域" class="headerlink" title="4. 通过HTML5的postMessage方法跨域"></a>4. 通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信</p>
</blockquote>
<p>A页面通过postMessage方法发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);  </div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">"http://www.google.com"</span>;  </div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'hello world!'</span>, targetOrigin);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>postMessage的使用方法：</p>
<ul>
<li><p>otherWindow.postMessage(message, targetOrigin);</p>
<ul>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message:   是要发送的消息，类型为 String、Object (IE8、9 不支持)</li>
<li>targetOrigin:   是限定消息接收范围，不限制请使用 ‘*</li>
</ul>
</li>
</ul>
<p>B页面通过message事件监听并接受消息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </div><div class="line">  <span class="keyword">var</span> data = event.data;<span class="comment">//消息  </span></div><div class="line">  <span class="keyword">var</span> origin = event.origin;<span class="comment">//消息来源地址  </span></div><div class="line">  <span class="keyword">var</span> source = event.source;<span class="comment">//源Window对象  </span></div><div class="line">  <span class="keyword">if</span>(origin==<span class="string">"http://www.baidu.com"</span>)&#123;  </div><div class="line"><span class="built_in">console</span>.log(data);<span class="comment">//hello world!  </span></div><div class="line">  &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage, <span class="literal">false</span>);  </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="comment">//for ie  </span></div><div class="line">  <span class="built_in">window</span>.attachEvent(<span class="string">'onmessage'</span>, onmessage);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="5-通过jsonp跨域"><a href="#5-通过jsonp跨域" class="headerlink" title="5.通过jsonp跨域"></a>5.通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://damonare.cn/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="external">http://damonare.cn/data.php,那么a.html中的代码就可以这样：</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function dosomething(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<a href="http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦" target="_blank" rel="external">http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦</a>):</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></div><div class="line">$data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<ul>
<li>JSONP的优缺点<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
</li>
</ul>
<h3 id="6-通过CORS跨域"><a href="#6-通过CORS跨域" class="headerlink" title="6. 通过CORS跨域"></a>6. 通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"POST"</span>, <span class="string">"/damonare"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"￼GET"</span>, <span class="string">"http://segmentfault.com/u/trigkit4/"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></p>
<ul>
<li><p>CORS和JSONP对比</p>
<ul>
<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>
</li>
<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
</li>
<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</p>
</li>
</ul>
</li>
</ul>
<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>
<h3 id="7-通过window-name跨域"><a href="#7-通过window-name跨域" class="headerlink" title="7. 通过window.name跨域"></a>7. 通过window.name跨域</h3><blockquote>
<p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
</blockquote>
<p>比如：我们在任意一个页面输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">"My window's name"</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.location.href = <span class="string">"http://damonare.cn/"</span>;</div><div class="line">&#125;,<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>进入damonare.cn页面后我们再检测再检测 window.name :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name; <span class="comment">// My window's name</span></div></pre></td></tr></table></figure>
<p>可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。<br>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p>
<blockquote>
<p>由于安全原因，浏览器始终会保持 window.name 是string 类型。</p>
</blockquote>
<p>同样这个方法也可以应用到和iframe的交互来：<br>比如：我的页面(<a href="http://damonare.cn/index.html)中内嵌了一个iframe：" target="_blank" rel="external">http://damonare.cn/index.html)中内嵌了一个iframe：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.google.com/iframe.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>我们在 index.html 中写了下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    data = iframe.contentWindow.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Boom!报错！肯定的，因为两个页面不同源嘛，想要解决这个问题可以这样干：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        data = iframe.contentWindow.name;</div><div class="line">    &#125;</div><div class="line">    iframe.src = <span class="string">'about:blank'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</strong></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>其它诸如中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp）不作讨论。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<ul>
<li><p><a href="https://segmentfault.com/a/1190000000718840#articleHeader1" target="_blank" rel="external">详解js跨域问题</a></p>
</li>
<li><p><a href="http://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="external">前端解决跨域问题的8种方案（最新最全）</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more&quot;&gt;前端跨域总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生在勤，不索何获。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="跨域" scheme="http://damonare.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/"/>
    <id>http://damonare.github.io/2016/09/16/十大经典排序算法总结（javascript描述）/</id>
    <published>2016-09-16T06:39:04.538Z</published>
    <updated>2016-12-20T04:29:55.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more">十大经典排序算法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生有情泪沾衣，江水江花岂终极。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>读者自行尝试可以<a href="https://github.com/damonare/Sorts" target="_blank" rel="external">想看源码戳这</a>，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦</p>
<blockquote>
<ul>
<li>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，<mark>JavaScript可谓风头无两，已经坐上了头把交椅。</mark></li>
<li>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（<mark>十大排序算法或是和十大排序算法同等难度的</mark>），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</li>
<li>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。<br><img src="http://img.blog.csdn.net/20160916152402267" alt="大大"></li>
</ul>
</blockquote>
<h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an<br>输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="external">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="http://img.blog.csdn.net/20160916153212716" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong><br>n: 数据规模<br>k:“桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="http://img.blog.csdn.net/20160916154036887" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>.重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进冒泡排序:</strong>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">var</span> i = arr.length<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></div><div class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j= <span class="number">0</span>; j&lt; i; j++)</div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                pos= j; <span class="comment">//记录交换的位置</span></div><div class="line">                <span class="keyword">var</span> tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></div><div class="line">     &#125;</div><div class="line">     <span class="built_in">console</span>.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">     <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort3</span>(<span class="params">arr3</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> high= arr.length<span class="number">-1</span>; <span class="comment">//设置变量的初始值</span></div><div class="line">    <span class="keyword">var</span> tmp,j;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        --high;                 <span class="comment">//修改high值, 前移一位</span></div><div class="line">        <span class="keyword">for</span> (j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        ++low;                  <span class="comment">//修改low值,后移一位</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr3;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p>三种方法耗时对比：</p>
<p><img src="http://img.blog.csdn.net/20160916163126374" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916160748389" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>.n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916164754013" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>.将新元素插入到该位置后；</5></li>
<li><6>.重复步骤2~5。</6></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i];</div><div class="line">            <span class="keyword">var</span> j = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            array[j + <span class="number">1</span>] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</div><div class="line">                <span class="keyword">if</span> (key &lt; array[middle]) &#123;</div><div class="line">                    right = middle - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">            &#125;</div><div class="line">            array[left] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(binaryInsertionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160916174656100" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916173802597" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明；<br>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">5</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">5</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">5</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916235203417" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>.对这两个子序列分别采用归并排序；</2></li>
<li><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left.length)</div><div class="line">        result.push(left.shift());</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (right.length)</div><div class="line">        result.push(right.shift());</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(mergeSort(arr));</div></pre></td></tr></table></figure>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160917001326254" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：快速排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="comment">//方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt;= x) &#123;</div><div class="line">                    i++;</div><div class="line">                    temp = array[i];</div><div class="line">                    array[i] = array[j];</div><div class="line">                    array[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            quickSort(array, left, i - <span class="number">1</span>);</div><div class="line">            quickSort(array, i + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array or left or right is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">var</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">return</span> quickSort2(left).concat([pivot], quickSort2(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div><div class="line"><span class="built_in">console</span>.log(quickSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917003004906" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：堆排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="comment">//建堆</span></div><div class="line">        <span class="keyword">var</span> heapSize = array.length, temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            heapify(array, i, heapSize);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            temp = array[<span class="number">0</span>];</div><div class="line">            array[<span class="number">0</span>] = array[j];</div><div class="line">            array[j] = temp;</div><div class="line">            heapify(array, <span class="number">0</span>, --heapSize);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*方法说明：维护堆的性质</span></div><div class="line">@param  arr 数组</div><div class="line">@param  x   数组下标</div><div class="line">@param  len 堆大小*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, x, len</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</div><div class="line"><span class="built_in">console</span>.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></div></pre></td></tr></table></figure>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917105502853" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>. 找出待排序的数组中最大和最小的元素；</1></li>
<li><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = array.length,</div><div class="line">        B = [],</div><div class="line">        C = [],</div><div class="line">        min = max = array[<span class="number">0</span>];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</div><div class="line">        C[array[k]]--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(countingSort(arr)); <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></div></pre></td></tr></table></figure>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="http://img.blog.csdn.net/20160917110641479" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.设置一个定量的数组当作空桶；</1></li>
<li><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></li>
<li><3>.对每个不是空的桶进行排序；</3></li>
<li><4>.从不是空的桶里把排好序的数据拼接起来。</4></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：桶排序</span></div><div class="line">@param  array 数组</div><div class="line">@param  num   桶的数量*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class="number">0</span>;</div><div class="line">    num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + <span class="number">1</span>) / num;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></div><div class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917111945979" alt="这里写图片描述"></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html" target="_blank" rel="external">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.取得数组中的最大数，并取得位数；</1></li>
<li><2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></li>
<li><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @author damonare</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line"><span class="comment">//LSD Radix Sort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</div><div class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> counter = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</div><div class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917123313659" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more&quot;&gt;十大经典排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生有情泪沾衣，江水江花岂终极。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://damonare.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Chrome控制台实用指南</title>
    <link href="http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/09/09/Chrome控制台使用总结/</id>
    <published>2016-09-09T12:43:11.000Z</published>
    <updated>2016-11-26T09:57:13.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/#more">Chrome控制台实用指南</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生何适不艰难，赖是胸中万斛宽</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear"></a>console.clear</h3><blockquote>
<p>console.clear();清空控制台，这个应该和console.log知名度一样高吧。</p>
</blockquote>
<h3 id="console-log家族"><a href="#console-log家族" class="headerlink" title="console.log家族"></a>console.log家族</h3><blockquote>
<p>先简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台</p>
</blockquote>
<p>如果你是一位开发者，我想console.log肯定是经常使用的了，我们主要看看console.log的几个兄弟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span><span class="built_in">console</span>.log (<span class="string">'普通信息'</span>)</div><div class="line"><span class="number">2.</span><span class="built_in">console</span>.info (<span class="string">'提示性信息'</span>)</div><div class="line"><span class="number">3.</span><span class="built_in">console</span>.error (<span class="string">'错误信息'</span>)</div><div class="line"><span class="number">4.</span><span class="built_in">console</span>.warn (<span class="string">'警示信息'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909211537532" alt="控制台"></p>
<p><strong>大家都会用log，但很少有人能够很好地利用console.error , console.warn 等将输出到控制台的信息进行分类整理。他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。</strong></p>
<blockquote>
<p>如果再配合console.group 与console.groupEnd，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.bundle"</span>);</div><div class="line"><span class="built_in">console</span>.warn(<span class="string">"来自bundle模块的警告信息1"</span>);<span class="built_in">console</span>.warn(<span class="string">"来自bundle模块的警告信息2"</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.bundle"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"来自bundle模块的信息1"</span>);<span class="built_in">console</span>.log(<span class="string">"来自bundle模块的信息2"</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909212018524" alt="这里写图片描述"></p>
<p><strong>这样的控制台信息看上去就一目了然了，就不用再为了找这是属于那一行代码输出的再翻一遍源码了。</strong></p>
<blockquote>
<p>另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,\n;看下面这个炫酷的效果：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>, <span class="string">'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909213512650" alt="这里写图片描述"></p>
<p><strong>当然，图片也是可以的，读者可以自行尝试，修改上述代码即可。</strong></p>
<blockquote>
<p>另外，console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<p><img src="http://img.blog.csdn.net/20160909215338908" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h3><blockquote>
<p>看着这种“黑魔法”是不是有种坑分的感觉呢，其实还不止哦！console.table可以让我们输出表格,示例：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;code:<span class="number">200</span>,content:[&#123;<span class="string">'品名'</span>: <span class="string">'杜雷斯'</span>, <span class="string">'数量'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'品名'</span>: <span class="string">'冈本'</span>, <span class="string">'数量'</span>: <span class="number">3</span>&#125;]&#125;;</div><div class="line"><span class="built_in">console</span>.table(data.content);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909214911953" alt="这里写图片描述"></p>
<p><strong>有的时候后端传回来一大串数据，是不是觉得直接console.log或是通过抓包工具查看都会让人晕头转向呢，这个时候正事console.table发挥作用的时候了，以表格的形式呈现数据，自然一目了然。</strong></p>
<h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert"></a>console.assert</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isDebug=<span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.assert(isDebug,<span class="string">'开发中的log信息。。。'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。</p>
<p><img src="http://img.blog.csdn.net/20160909215637362" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count"></a>console.count</h3><blockquote>
<p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的console.count可以很地胜任这样的任务.</p>
<p><img src="http://img.blog.csdn.net/20160909215931738" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir"></a>console.dir</h3><blockquote>
<p>将DOM结点以JavaScript对象的形式输出到控制台<br>而console.log是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://img.blog.csdn.net/20160909220149156" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time &amp; console.timeEnd"></a>console.time &amp; console.timeEnd</h3><blockquote>
<p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。比如需要考量一段代码执行的耗时情况时，可以用console.time与 console.timeEnd来做此事。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">"Array耗时"</span>);</div><div class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array耗时"</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909220932148" alt="这里写代码片"></p>
<blockquote>
<p>当想要查看CPU使用相关的信息时，可以使用console.profile配合 console.profileEnd来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是Profile。使用方法和console.time基本一样，其实time开发者工具里也有个tab就是timeline。关于console.prefile博主就不做多余的介绍了。想要做更多了解的读者可以看<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="$"></a>$</h3><blockquote>
<p>讲真，米国程序员们真的很喜欢money啊（谁又不是呢），看看PHP就知道了,满屏的$符号。而在Chrome的控制台里，$用处同样是蛮多且方便的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>+<span class="number">2</span><span class="comment">//回车，再</span></div><div class="line">$_+<span class="number">1</span><span class="comment">//回车得5</span></div></pre></td></tr></table></figure>
<blockquote>
<p>上面的</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$_</div></pre></td></tr></table></figure>
<blockquote>
<p>需要领悟其奥义才能使用得当，而</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$<span class="number">0</span>~$<span class="number">4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>则代表了最近5个你选择过的DOM节点。<br>什么意思呢？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909222120965" alt="这里写图片描述"></p>
<blockquote>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节点，多么滴熟悉。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'body'</span>);</div><div class="line">$$(<span class="string">'div'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909223159417" alt="这里写图片描述"></p>
<blockquote>
<p>$(selector)返回的是满足选择条件的首个DOM元素。<br>剥去她伪善的外衣，其实$(selector)是原生JavaScript document.querySelector() 的封装。<br>同时另一个命令$$(selector)返回的是所有满足选择条件的元素的一个集合，是对document.querySelectorAll() 的封装。</p>
</blockquote>
<h3 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h3><blockquote>
<p>将所匹配的节点放在一个数组里返回</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x(<span class="string">"//p"</span>);</div><div class="line">$x(<span class="string">"//p[a]"</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909232110728" alt="这里写图片描述"></p>
<blockquote>
<p>$x(“//p”)匹配所有的p节点，$x(“//p[a]”);匹配所有子节点包含a的p节点</p>
</blockquote>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">copy(<span class="built_in">document</span>.body)</div></pre></td></tr></table></figure>
<blockquote>
<p>然后你就可以Ctrl+v了。</p>
</blockquote>
<p><strong>注意：他不依附于任何全局变量比如window，所以其实在JS代码里是访问不了这个copy方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~这样我们就可以通过js代码进行复制操作而不用再依赖Flash插件了。</strong></p>
<h3 id="keys-amp-values"><a href="#keys-amp-values" class="headerlink" title="keys &amp; values"></a>keys &amp; values</h3><blockquote>
<p>这是一对基友。前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。具体请看下面的例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tfboy=&#123;name:<span class="string">'wayou'</span>,gender:<span class="string">'unknown'</span>,hobby:<span class="string">'opposite to the gender'</span>&#125;;</div><div class="line">keys(tfboy);</div><div class="line">values(tfboy);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909225910811" alt="这里写图片描述"></p>
<h3 id="monitor-amp-unmonitor"><a href="#monitor-amp-unmonitor" class="headerlink" title="monitor &amp; unmonitor"></a>monitor &amp; unmonitor</h3><blockquote>
<p>monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。而unmonitor(function)便是用来停止这一监听。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello,'</span>+name);</div><div class="line">&#125;</div><div class="line">monitor(sayHello);</div><div class="line">sayHello(<span class="string">'damonare'</span>);</div><div class="line">sayHello(<span class="string">'tjz'</span>);</div><div class="line">unmonitor(sayHello);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909230648805" alt="这里写图片描述"></p>
<h3 id="debug-amp-undebug"><a href="#debug-amp-undebug" class="headerlink" title="debug &amp; undebug"></a>debug &amp; undebug</h3><blockquote>
<p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。而undebug 则是解除该断点。而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909231322130" alt=""></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><strong>本博文依据<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">Console API文档</a>和<a href="https://developers.google.com/web/tools/chrome-devtools/debug/command-line/command-line-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#debugfunction" target="_blank" rel="external">Commond API</a>书写。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/#more&quot;&gt;Chrome控制台实用指南&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生何适不艰难，赖是胸中万斛宽&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="工具" scheme="http://damonare.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Clip-Path</title>
    <link href="http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/"/>
    <id>http://damonare.github.io/2016/09/09/聊聊clip-path/</id>
    <published>2016-09-09T08:51:00.000Z</published>
    <updated>2016-11-26T06:00:47.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/#more">聊聊clip-path</a></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生如画，岁月如歌。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Flilter"><a href="#Flilter" class="headerlink" title="Flilter"></a>Flilter</h3><blockquote>
<p>filter有十种特效来处理图片，博主只放几种特效的样例给大家看一下：</p>
<p>照片反色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104748479" alt="照片反色"></p>
<p>照片褐色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104803642" alt="照片褐色"></p>
<p>照片阴影效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104818298" alt="阴影"></p>
</blockquote>
<p><strong>十种特效源码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-webkit-filter:opacity(.6);//透明度</div><div class="line">filter:opacity(.6);</div><div class="line">-webkit-filter:blur(10px);//照片模糊</div><div class="line">filter:blur(10px);</div><div class="line">-webkit-filter:invert(1);</div><div class="line">filter:invert(1);</div><div class="line">-webkit-filter:saturate(3);//照片饱和度</div><div class="line">filter:saturate(3);</div><div class="line">-webkit-filter:grayscale(1);//照片灰度</div><div class="line">filter:grayscale(1);</div><div class="line">-webkit-filter:sepia(1);//照片褐色</div><div class="line">filter:sepia(1);</div><div class="line">-webkit-filter:hue-rotate(90deg);//色相旋转</div><div class="line">filter:hue-rotate(90deg);</div><div class="line">-webkit-filter:brightness(.5);//亮度</div><div class="line">filter:brightness(.5);</div><div class="line">-webkit-filter:contrast(2);//对比度</div><div class="line">filter:contrast(2);</div><div class="line">-webkit-filter:drop-shadow(10px 10px 10px #ccc);//阴影</div><div class="line">filter:drop-shadow(10px 10px 10px #ccc);</div></pre></td></tr></table></figure>
<blockquote>
<p>但实际上这个属性兼容性很低：</p>
<p><img src="http://img.blog.csdn.net/20160910105340845" alt="can I use"></p>
</blockquote>
<p><strong>截止博主发文日期，Filter的兼容性如上图，我们可以看到IE是完全不支持的，Edge也是部分支持。这可能也是Filter没法用在项目中的原因之一了。感兴趣的读者可以Copy博主代码本地测试一下，或是参照<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter#blur%28%29_2" target="_blank" rel="external">MDN|Filter</a>了解。博主不在这里做过多的说明了。</strong></p>
<h3 id="clip-amp-clip-path"><a href="#clip-amp-clip-path" class="headerlink" title="clip&amp;clip-path"></a>clip&amp;clip-path</h3><blockquote>
<p>这两个属性正是今天的重头戏，博主曾在<a href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more">从隐藏元素谈起</a>提起过，但并没做深入解释。是的，它可以用来隐藏元素，当然也就能处理图片了。</p>
</blockquote>
<ul>
<li>clip</li>
</ul>
<blockquote>
<p>clip这个属性我相信会有很大一部分人不知道，因为这个属性使用率非常的低，因为很多情况下我们会直接重新切一张新图出来代替而不会去剪裁已有的图片，但实际上这个属性用在CSS sprite简直就如同神器一般，因为在很多情况下background-position并不符合我们的需求，比如,有时我们希望Sprite图片可以延迟滚动加载，或者是可以很轻松的右键图片另存为…或是其它background-position没法满足的情景。<br>废话不多说，看样例：<br><img src="http://img.blog.csdn.net/20160910144129604" alt="这里写图片描述"></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</div><div class="line"><span class="selector-tag">clip</span><span class="selector-pseudo">:rect(50px</span> 250<span class="selector-tag">px</span> 250<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>); <span class="comment">/* IE6, IE7 */</span></div><div class="line"><span class="selector-tag">clip</span><span class="selector-pseudo">:rect(50px</span>,250<span class="selector-tag">px</span>,250<span class="selector-tag">px</span>,50<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160910182933393" alt="这里写图片描述"></p>
<p><strong>注意，元素定位position必须是absolute或是fixed的，兼容IE6，IE7需要将值之间的逗号去掉。另外，react（top,right,bottom,left）；四个值分别是相对于图片左上角为原点的坐标值。Clip基本所有的浏览器都支持，可以放心使用。</strong></p>
<blockquote>
<p>让人放弃它的原因无外乎：</p>
<ul>
<li>clip 只对绝对定位的元素有效对于position:relative和position:static无效</li>
<li>clip 只能用于矩形，即rect()函数</li>
</ul>
</blockquote>
<ul>
<li>clip-path</li>
</ul>
<blockquote>
<p>其实clip在HTML5中已经被废弃了(依然可用)，取而代之的是clip-path。本来clip还有一个circle(圆)，但基本没有浏览器实现这个属性值，只有rect()可是使用，可能W3C也是等不下去了吧，直接推出了一个更牛逼的属性——clip-path,这个属性起初是SVG里面的然后被挪用到了CSS里面。关于SVG博主有时间会再另外介绍，这里按下不表。效果图：<br><img src="http://img.blog.csdn.net/20160910165910381" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160910165924100" alt="这里写图片描述"></p>
</blockquote>
<p><strong>读者可以在<a href="http://bennettfeely.com/clippy/" target="_blank" rel="external">这里自行体验</a></strong></p>
<blockquote>
<p>兼容：现在为止IE 和 Edge 不支持这个属性，Firefox 仅部分支持 clip-path ，<br>Chrome、Safari 和 Opera 需要使用 -webkit- 前缀支持此属性。<br><img src="http://img.blog.csdn.net/20160910172318567" alt="这里写图片描述"><br><strong>clip-path兼容性甚至比前面说到的filter还差，所以很难真正使用起来。更多使用效果<a href="http://codepen.io/wenbin5243/pen/iheHF" target="_blank" rel="external">戳这里</a>和<a href="http://species-in-pieces.com/#" target="_blank" rel="external">这里</a></strong></p>
</blockquote>
<p><strong>说一下它的四个属性值：</strong></p>
<ul>
<li>clip-source: 可以是内、外部的SVG的clipPath元素的URL引用;</li>
</ul>
<ul>
<li><p>basic-shape: 使用一些基本的形状函数创建的一个形状。主要包括circle()、ellipse()、inset()和polygon()。</p>
</li>
<li><p>geometry-box: 是可选参数。此参数和basic-shape函数一起使用时，可以为basic-shape的裁剪工作提供参考盒子。如果geometry-box由自身指定，那么它会使用指定盒子形状作为裁剪的路径，包括任何(由border-radius提供的)的角的形状。</p>
</li>
</ul>
<p><strong>开始使用clip-path</strong></p>
<blockquote>
<p>在开始使用clip-path绘制图形，或者说裁剪图形之前，有两点需要大家注意：</p>
<ul>
<li><p>使用clip-path要从同一个方向绘制，如果顺时针绘制就一律顺时针，逆时针就一律逆时针，因为polygon是一个连续线段，若线段彼此有交集，裁剪区域就会有相减的情况发生，当然如果你特意需要这样的效果除外。</p>
</li>
<li><p>如果绘制时采用比例的方式绘制，长宽就必须要先行设定，不然有可能绘制出来的长宽和我们想像的就会有差距，使用像素绘制就不会有这样的现象。</p>
</li>
</ul>
<p>我们就拿上面途中的六边形作为polygon()函数示例：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-clip-path</span>: <span class="selector-tag">polygon</span>(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%);</div><div class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%);</div></pre></td></tr></table></figure>
<p><strong>效果图:</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174638529" alt="效果图"></p>
<p><strong>讲解：</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174656822" alt="这里写图片描述"></p>
<blockquote>
<p>每个点的第一个坐标值决定了它在 x 轴上的位置，第二个坐标值指定了它在 y 轴的位置，所有点是顺时针绘制的。其实一个 polygon（）就能满足所有的形状需要了，有自定义的API用更加方便不是么。</p>
</blockquote>
<p><strong>注意：inset()这个真的坑，按说同样裁剪成方形应该是和clip的rect一样用法，可不一样！</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Clip的rect</div><div class="line">position:absolute;</div><div class="line">clip:rect(50px 250px 250px 50px);</div><div class="line">//clip-path</div><div class="line">clip-path: inset(50px 50px 50px 50px);</div><div class="line">-webkit-clip-path: inset(50px 50px 50px 50px);</div></pre></td></tr></table></figure>
<p><strong>本文使用图片是300*300的。</strong></p>
<blockquote>
<p>很明显：</p>
</blockquote>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clip:rect(50px 250px 250px 50px);</div><div class="line">=clip-path: inset(50px 50px 50px 50px);</div></pre></td></tr></table></figure>
<p>好大的一个坑….</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>相信随着时代发展，clip-path会慢慢被浏览器厂商接受的。<br>本文有任何错误，欢迎评论留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/#more&quot;&gt;聊聊clip-path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生如画，岁月如歌。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS3" scheme="http://damonare.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>如何看待&quot;罗一笑，你给我站住&quot;营销事件</title>
    <link href="http://damonare.github.io/2016/09/09/%E7%BD%97%E4%B8%80%E7%AC%91%E4%BA%8B%E4%BB%B6/"/>
    <id>http://damonare.github.io/2016/09/09/罗一笑事件/</id>
    <published>2016-09-09T08:00:00.000Z</published>
    <updated>2016-11-30T06:43:56.120Z</updated>
    
    <content type="html"><![CDATA[<p>关于”罗一笑事件”的一点思考</p>
<a id="more"></a>
<p><img src="http://img.blog.csdn.net/20161130140949429" alt="营销"></p>
<p>今天一大早起床，按照惯例刷了会朋友圈，发现整个朋友圈都被一个题目为’罗一笑，你给我站住’的文章占领了！我滴个乖乖！什么情况，出于好奇进去看看吧。文章说的是一位父亲为病重的女儿所写的鼓励的文字，看朋友圈里的人都在说是在卖文赚钱救女。感动！泪点满分！但总觉得还是有猫腻，点赞10W+让我觉得很不像是正常的公益活动。果不其然，当我洗漱完毕的时候，朋友圈已经有人在辟谣了！这又是一次赤裸裸的营销操作！</p>
<p>附上朋友圈转发时都会附带的一段话：</p>
<blockquote>
<p>「深圳本土作家罗尔5岁多的爱女罗一笑，被检查出白血病，住进了深圳市儿童医院。医疗费每天1至3万。父亲心急如焚，但他没有选择公益捐款，而是选择＂卖文＂，大家每转发一次，小铜人公司向罗尔定向捐赠1元；保底捐赠两万元，上限五十万元；截止11月30日零时。」</p>
</blockquote>
<p>讲真的，这次营销活动着实是成功的，10W+的点赞数量足够让背后的团队赚的盆满钵满。</p>
<p>本身罗一笑小同学的了白血病，实在让人可怜，却被人利用成为了一次全国性的营销事件。别的不说，作为父亲的罗尔这么做实在让人心寒。如果说你没能力治病还则罢了，事实却是是个并不差钱的主儿。我们来看下最近几个小时网友的爆料：</p>
<h3 id="爆料一：事件背后有人营销"><a href="#爆料一：事件背后有人营销" class="headerlink" title="爆料一：事件背后有人营销"></a>爆料一：事件背后有人营销</h3><p><img src="http://img.blog.csdn.net/20161130141646496" alt="这里写图片描述"></p>
<h3 id="爆料2：赶走前妻，迷上交际花"><a href="#爆料2：赶走前妻，迷上交际花" class="headerlink" title="爆料2：赶走前妻，迷上交际花"></a>爆料2：赶走前妻，迷上交际花</h3><p><img src="http://img.blog.csdn.net/20161130142146136" alt="这里写图片描述"></p>
<h3 id="爆料3：捐款已经足够"><a href="#爆料3：捐款已经足够" class="headerlink" title="爆料3：捐款已经足够"></a>爆料3：捐款已经足够</h3><p><img src="http://img.blog.csdn.net/20161130142218154" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161130142529468" alt="这里写图片描述"></p>
<h3 id="爆料4：小铜人公司的恶意营销"><a href="#爆料4：小铜人公司的恶意营销" class="headerlink" title="爆料4：小铜人公司的恶意营销"></a>爆料4：小铜人公司的恶意营销</h3><p><img src="http://img.blog.csdn.net/20161130142324888" alt="这里写图片描述"></p>
<h3 id="一点个人思考"><a href="#一点个人思考" class="headerlink" title="一点个人思考"></a>一点个人思考</h3><p>其实站在转发者的角度思考，一个可怜的小女孩得了白血病，无钱治疗，已经够可怜了，再加上作者罗尔文字的渲染，自然而然让人想要转发帮助罗一笑。因为啥？因为转发对于自己没坏处！而且转发之后还可能给罗一笑更大的帮助！</p>
<p>营销者恰恰抓住了这点，利用人们的同情心，殊不知全国每天都有像罗一笑一样可怜的孩子，可悲的是我们不知道，也从来没去主动关注过。</p>
<p>舆论的焦点不该在此的，同情别人的同时也该去思考下事情的本源，按理说这应该算是诈骗吧，法律去哪了…继续如此，后果只会是继续有人诈骗，捐钱人信任危机该得到帮助的人一分钱也得不到帮助。</p>
<p>文后：如果真想救助贫苦，那就每天多走两步吧，腾讯公益，阿里公益起码目前还是值得信任的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于”罗一笑事件”的一点思考&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="思考" scheme="http://damonare.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>记秋招</title>
    <link href="http://damonare.github.io/2016/09/07/%E5%86%99%E5%9C%A8%E7%A7%8B%E6%8B%9B%E4%B9%8B%E9%99%85/"/>
    <id>http://damonare.github.io/2016/09/07/写在秋招之际/</id>
    <published>2016-09-07T14:09:22.232Z</published>
    <updated>2016-11-26T09:47:25.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>总括：</strong> 不知不觉已经过去很长时间了好像，身边的每一个人似乎都在改变着，我说着自己不想变。却抵不住这改变的大潮浪势。有时候会想就这样吧，不要再试图改变了，也许你就是这样的人，就是这样平庸，面对赤裸裸的现实连反抗都不敢的懦夫。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/09/07/%E5%86%99%E5%9C%A8%E7%A7%8B%E6%8B%9B%E4%B9%8B%E9%99%85/#more">记秋招</a></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生总是会存在那么些说不清道不明的关系。</strong></p>
<a id="more"></a>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><ul>
<li><h4 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h4></li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果说秋招会让大四的崩溃，那么即将到来的春招就好像让我再经历一次高考一样，心里胆战心惊，毫无把握。是的，我想去杭州，不知道为啥就是想去，没有原因的想去。听蘑菇街的学长说合并之后导致HC太多，进蘑菇街的难度基本等同于阿里了。做项目，写博客，说真的，整个暑假过来也没休息过一天。唯一的原因可能就是觉得自己太菜吧。心里哈市想去阿里的，这是一定要去的，如果校招不行那就过几年通过社招，阿里是有情结在里面的，虽然深知阿里工作压力也很大，但同样，别的公司其实压力也是如此不是吗？要试一下的，今晚阿里笔试，考了很多react知识点，不知道明年还会不会考react呢，一切都是未知数啊，所以充满了不确定性。</p>
</blockquote>
<p><br></p>
<ul>
<li><h4 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h4></li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;曾经我以为那个人就是我的全部，我有一个很明确的目标，就是让她过上简简单单的幸福生活。可惜到头来把自己弄的伤痕累累。人呐，真是受过伤才能长大。<strong>越是在意的东西往往越容易失去，不管你期望值放多高，来往始终是相互的，既然做不到礼尚往来，不如各自安好。</strong>感谢你在我生命中的出现让我真正看清了人性，谢谢你的离开。</p>
</blockquote>
<p><br></p>
<ul>
<li><h4 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h4></li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;无数次幻想过那个真正愿意和我风雨同舟的人到底是什么样子，她出现了么，或是出现了我不知道？心里还是存在一丝的希冀。可如今，似乎现实了点，不会再去想象，或许是因为曾经有一段时间我觉得自己找到了那个人吧，可现实却又一次打在了脸上，很多事不是一个人能控制的，尤其感情。自己能控制的只有自己的内心，可真正能控制自己内心的还是在少数啊……可能这就是<strong>尽人事，听天命</strong>的深层含义吧。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<mark>面对无能为力的事，也只能信命。我居然会说出这样的话，估计也是受伤太多次了。<br>那么，以后会怎样？<br>—-听天由命﻿</mark></p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>20岁，我，不服！</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 不知不觉已经过去很长时间了好像，身边的每一个人似乎都在改变着，我说着自己不想变。却抵不住这改变的大潮浪势。有时候会想就这样吧，不要再试图改变了，也许你就是这样的人，就是这样平庸，面对赤裸裸的现实连反抗都不敢的懦夫。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/07/%E5%86%99%E5%9C%A8%E7%A7%8B%E6%8B%9B%E4%B9%8B%E9%99%85/#more&quot;&gt;记秋招&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生总是会存在那么些说不清道不明的关系。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Fighting" scheme="http://damonare.github.io/tags/Fighting/"/>
    
      <category term="感悟" scheme="http://damonare.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题集</title>
    <link href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>http://damonare.github.io/2016/09/07/前端面试题集/</id>
    <published>2016-09-07T14:06:38.001Z</published>
    <updated>2016-11-26T09:37:43.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文涵盖了前端面试中会涉及的方方面面题目。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/#more">前端面试题集</a></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生大病，只是一“傲”字。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="一些开放性题目"><a href="#一些开放性题目" class="headerlink" title="一些开放性题目"></a>一些开放性题目</h4><pre><code>1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。

2.项目介绍

3.如何看待前端开发？

4.平时是如何学习前端开发的？

5.未来三到五年的规划是怎样的？
</code></pre><h4 id="position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="position的值， relative和absolute分别是相对于谁进行定位的？"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h4><ul>
<li><p><code>absolute</code> :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</p>
</li>
<li><p><code>fixed</code> （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</p>
</li>
<li><p><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
</li>
<li><p><code>static</code>  默认值。没有定位，元素出现在正常的流中</p>
</li>
<li><p><code>sticky</code> 生成粘性定位的元素，容器的位置根据正常文档流计算得出</p>
</li>
</ul>
<p><br></p>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><blockquote>
<p>JSONP：</p>
</blockquote>
<p>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入。</p>
<p>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把JSON填充到一个盒子里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">        oScript.type = <span class="string">'text/javascript'</span>;</div><div class="line">        oScript.src = sUrl;</div><div class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createJs(<span class="string">'jsonp.js'</span>);</div><div class="line"></div><div class="line">    box(&#123;</div><div class="line">       <span class="string">'name'</span>: <span class="string">'test'</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">        alert(json.name);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>CORS</p>
</blockquote>
<p>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问。</p>
<blockquote>
<p>通过修改document.domain来跨子域</p>
</blockquote>
<p>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域</p>
<p>主域相同的使用<code>document.domain</code></p>
<blockquote>
<p>使用window.name来进行跨域</p>
</blockquote>
<p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</p>
<blockquote>
<p>使用HTML5中新引进的<code>window.postMessage</code>方法来跨域传送数据</p>
</blockquote>
<p>还有flash、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>
<h4 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a><code>XML</code>和<code>JSON</code>的区别？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(1).数据体积方面。</div><div class="line"></div><div class="line">JSON相对于XML来讲，数据的体积小，传递的速度更快些。</div><div class="line"></div><div class="line">(2).数据交互方面。</div><div class="line"></div><div class="line">JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</div><div class="line"></div><div class="line">(3).数据描述方面。</div><div class="line"></div><div class="line">JSON对数据的描述性比XML较差。</div><div class="line"></div><div class="line">(4).传输速度方面。</div><div class="line"></div><div class="line">JSON的速度要远远快于XML。</div></pre></td></tr></table></figure>
<h4 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h4><p><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的<code>HTML、Javascript、CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p>
<p><code>webpack</code>的两大特色：</p>
<pre><code>1.code splitting（可以自动完成）

2.loader 可以处理各种类型的静态文件，并且支持串联操作
</code></pre><p><code>webpack</code> 是以<code>commonJS</code>的形式来书写脚本滴，但对 <code>AMD/CMD</code> 的支持也很全面，方便旧项目进行代码迁移。</p>
<p><code>webpack</code>具有<code>requireJs</code>和<code>browserify</code>的功能，但仍有很多自己的新特性：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 对 CommonJS 、 AMD 、ES6的语法做了兼容</div><div class="line"></div><div class="line"><span class="number">2.</span> 对js、css、图片等资源文件都支持打包</div><div class="line"></div><div class="line"><span class="number">3.</span> 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</div><div class="line"></div><div class="line"><span class="number">4.</span> 有独立的配置文件webpack.config.js</div><div class="line"></div><div class="line"><span class="number">5.</span> 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</div><div class="line"></div><div class="line"><span class="number">6.</span> 支持 SourceUrls 和 SourceMaps，易于调试</div><div class="line"></div><div class="line"><span class="number">7.</span> 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</div><div class="line"></div><div class="line"><span class="number">8.</span>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</div></pre></td></tr></table></figure>
<h4 id="说说TCP传输的三次握手四次挥手策略"><a href="#说说TCP传输的三次握手四次挥手策略" class="headerlink" title="说说TCP传输的三次握手四次挥手策略"></a>说说TCP传输的三次握手四次挥手策略</h4><p> 为了准确无误地把数据送达目标处，<code>TCP</code>协议采用了三次握手策略。用TCP协议把数据包送出去后，<code>TCP</code>不会对传送    后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：<code>SYN</code>和<code>ACK</code>。</p>
<p>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p>
<p><br></p>
<blockquote>
<p>断开一个TCP连接则需要“四次握手”：</p>
</blockquote>
<ul>
<li><p>第一次挥手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
</li>
<li><p>第二次挥手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</p>
</li>
<li><p>第三次挥手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
</li>
<li><p>第四次挥手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</li>
</ul>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p>
<p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h4 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h4><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的。</p>
<h4 id="创建ajax过程"><a href="#创建ajax过程" class="headerlink" title="创建ajax过程"></a>创建ajax过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</div><div class="line"></div><div class="line">(<span class="number">2</span>)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</div><div class="line"></div><div class="line">(<span class="number">3</span>)设置响应HTTP请求状态变化的函数.</div><div class="line"></div><div class="line">(<span class="number">4</span>)发送HTTP请求.</div><div class="line"></div><div class="line">(<span class="number">5</span>)获取异步调用返回的数据.</div><div class="line"></div><div class="line">(<span class="number">6</span>)使用JavaScript和DOM实现局部刷新.</div></pre></td></tr></table></figure>
<h4 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h4><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<h4 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h4><blockquote>
<p>sql注入原理</p>
</blockquote>
<p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>总的来说有以下几点：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<span class="string">"-"</span>进行转换等。</div><div class="line"></div><div class="line"><span class="number">2.</span>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</div><div class="line"></div><div class="line"><span class="number">3.</span>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</div><div class="line"></div><div class="line"><span class="number">4.</span>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</div></pre></td></tr></table></figure>
<blockquote>
<p>XSS原理及防范</p>
</blockquote>
<p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 <code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个</p>
<p>看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，</p>
<p>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>
<blockquote>
<p>XSS防范方法</p>
</blockquote>
<p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p>
<p>首先，避免直接在<code>cookie</code> 中泄露用户隐私，例如email、密码等等。</p>
<p>其次，通过使<code>cookie</code> 和系统<code>ip</code> 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的<code>cookie</code> 没有实际价值，不可能拿来重放。</p>
<p>如果网站不需要再浏览器端对<code>cookie</code> 进行操作，可以在<code>Set-Cookie</code> 末尾加上<code>HttpOnly</code> 来防止<code>javascript</code> 代码直接获取<code>cookie</code> 。</p>
<p>尽量采用<code>POST</code> 而非<code>GET</code> 提交表单</p>
<blockquote>
<p>XSS与CSRF有什么区别吗？</p>
</blockquote>
<p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p>
<p>要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">登录受信任网站<span class="keyword">A</span>，并在本地生成Cookie。</div><div class="line"></div><div class="line">在不登出<span class="keyword">A</span>的情况下，访问危险网站B。</div></pre></td></tr></table></figure>
<blockquote>
<p>CSRF的防御</p>
</blockquote>
<ul>
<li><p>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p>
</li>
<li><p>通过验证码的方法</p>
</li>
</ul>
<h4 id="Web-Worker-和webSocket"><a href="#Web-Worker-和webSocket" class="headerlink" title="Web Worker 和webSocket"></a>Web Worker 和webSocket</h4><blockquote>
<p>worker主线程:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>通过 worker = <span class="keyword">new</span> Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</div><div class="line"></div><div class="line"><span class="number">2.</span>通过worker.postMessage( data ) 方法来向worker发送数据。</div><div class="line"></div><div class="line"><span class="number">3.</span>绑定worker.onmessage方法来接收worker发送过来的数据。</div><div class="line"></div><div class="line"><span class="number">4.</span>可以使用 worker.terminate() 来终止一个worker的执行。</div></pre></td></tr></table></figure>
<p><code>WebSocket</code>是<code>Web</code>应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个<code>HTML5</code>协议，<code>WebSocket</code>的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p><code>HTTP</code>协议通常承载于TCP协议之上，在<code>HTTP</code>和<code>TCP</code>之间添加一个安全协议层（<code>SSL</code>或<code>TSL</code>），这个时候，就成了我们常说的HTTPS。</p>
<p>默认HTTP的端口号为80，<code>HTTPS</code>的端口号为443。</p>
<h4 id="为什么HTTPS安全"><a href="#为什么HTTPS安全" class="headerlink" title="为什么HTTPS安全"></a>为什么<code>HTTPS</code>安全</h4><p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<code>HTTPS</code>，密钥在你和终点站才有。<code>https</code>之所以比<code>http</code>安全，是因为他利用<code>ssl/tls</code>协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>
<h4 id="对前端模块化的认识"><a href="#对前端模块化的认识" class="headerlink" title="对前端模块化的认识"></a>对前端模块化的认识</h4><blockquote>
<p>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。</p>
<p>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<blockquote>
<p>CMD模块方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 模块代码</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Javascript垃圾回收方法"><a href="#Javascript垃圾回收方法" class="headerlink" title="Javascript垃圾回收方法"></a>Javascript垃圾回收方法</h4><blockquote>
<p>标记清除（mark and sweep）</p>
</blockquote>
<p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
<blockquote>
<p>引用计数(reference counting)</p>
</blockquote>
<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及<code>BOM</code>及DOM就会出现循环引用问题。</p>
<h4 id="你觉得前端工程的价值体现在哪"><a href="#你觉得前端工程的价值体现在哪" class="headerlink" title="你觉得前端工程的价值体现在哪"></a>你觉得前端工程的价值体现在哪</h4><pre><code>为简化用户使用提供技术支持（交互部分）

为多个浏览器兼容性提供支持

为提高用户浏览速度（浏览器性能）提供支持

为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持

为展示数据提供支持（数据接口）
</code></pre><h4 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h4><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</p>
<p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p>
<p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p>
<p>请求带宽：压缩文件，开启GZIP，</p>
<blockquote>
<p>代码层面的优化</p>
</blockquote>
<ul>
<li><p>用<code>hash-table</code>来优化查找</p>
</li>
<li><p>少用全局变量</p>
</li>
<li><p>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</p>
</li>
<li><p>用<code>setTimeout</code>来避免页面失去响应</p>
</li>
<li><p>缓存DOM节点查找的结果</p>
</li>
<li><p>避免使用CSS Expression</p>
</li>
<li><p>避免全局查询</p>
</li>
<li><p>避免使用with(with会创建自己的作用域，会增加作用域链长度)</p>
</li>
<li><p>多个变量声明合并</p>
</li>
<li><p>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p>
</li>
<li>尽量避免写在HTML标签中写Style属性</li>
</ul>
<h4 id="移动端性能优化"><a href="#移动端性能优化" class="headerlink" title="移动端性能优化"></a>移动端性能优化</h4><ul>
<li>尽量使用css3动画，开启硬件加速。</li>
<li>适当使用<code>touch</code>事件代替<code>click</code>事件。</li>
<li>避免使用<code>css3</code>渐变阴影效果。</li>
<li>可以用<code>transform: translateZ(0)</code>来开启硬件加速。</li>
<li>不滥用Float。Float在渲染时计算量比较大，尽量减少使用</li>
<li>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</li>
<li>合理使用requestAnimationFrame动画代替setTimeout</li>
<li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</li>
<li>PC端的在移动端同样适用</li>
</ul>
<blockquote>
<p>相关阅读：<a href="https://github.com/cssmagic/blog/issues/20" target="_blank" rel="external">如何做到一秒渲染一个移动页面</a></p>
</blockquote>
<h4 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h4><p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。<br></p>
<p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到  <code>200 OK</code>(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p>
<p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和<code>Etag</code></p>
<p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据<code>Etag</code>，判断文件内容自上一次请求之后，有没有发生变化</p>
<p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发<code>index.html</code>的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code>，此时浏览器就会从本地缓存中获取<code>index.html</code>的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。<br></p>
<p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</p>
<p><br></p>
<p>① 只有get请求会被缓存，post请求不会</p>
<h4 id="Expires和Cache-Control"><a href="#Expires和Cache-Control" class="headerlink" title="Expires和Cache-Control"></a>Expires和Cache-Control</h4><p><code>Expires</code>要求客户端和服务端的时钟严格同步。<code>HTTP1.1</code>引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Cache-Control: no-cache, private, max-age=<span class="number">0</span></div><div class="line"></div><div class="line">ETag: abcde</div><div class="line"></div><div class="line">Expires: Thu, <span class="number">15</span> Apr <span class="number">2014</span> <span class="number">20</span>:<span class="number">00</span>:<span class="number">00</span> GMT</div><div class="line"></div><div class="line">Pragma: private</div><div class="line"></div><div class="line">Last-Modified: $now <span class="comment">// RFC1123 format</span></div></pre></td></tr></table></figure>
<h4 id="ETag应用"><a href="#ETag应用" class="headerlink" title="ETag应用:"></a>ETag应用:</h4><p><code>Etag</code>由服务器端生成，客户端通过<code>If-Match</code>或者说<code>If-None-Match</code>这个条件判断请求来验证资源是否修改。常见的是使用<code>If-None-Match</code>。请求一个文件的流程可能如下：</p>
<p>====第一次请求===</p>
<pre><code>1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200
</code></pre><p>====第二次请求===</p>
<pre><code>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
</code></pre><p>答案是同时使用，也就是说在完全匹配<code>If-Modified-Since</code>和<code>If-None-Match</code>即检查完修改时间和<code>Etag</code>之后，</p>
<p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p>
<p>为什么使用Etag请求头?</p>
<p>Etag 主要为了解决 <code>Last-Modified</code> 无法解决的一些问题。</p>
<h4 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h4><pre><code>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除
</code></pre><h4 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h4><pre><code>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。

堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。
</code></pre><h4 id="快速-排序的思想并实现一个快排？"><a href="#快速-排序的思想并实现一个快排？" class="headerlink" title="快速 排序的思想并实现一个快排？"></a>快速 排序的思想并实现一个快排？</h4><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>
<p>　　（1）在数据集之中，找一个基准点</p>
<p>　　（2）建立两个数组，分别存储左边和右边的数组</p>
<p>　　（3）利用递归进行下次比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></div><div class="line">        <span class="keyword">var</span> left = [];</div><div class="line">        <span class="keyword">var</span> right = [];</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i]&lt;numValue)&#123;</div><div class="line">                left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">               right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<h4 id="你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="你觉得jQuery或zepto源码有哪些写的好的地方"></a>你觉得jQuery或zepto源码有哪些写的好的地方</h4><p>(答案仅供参考)</p>
<p><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当<code>jquery</code>中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问<code>window</code>对象。同样，传入<code>undefined</code>参数，可以缩短查找undefined时的作用域链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">//用一个函数域包起来，就是所谓的沙箱</span></div><div class="line"></div><div class="line">     <span class="comment">//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span></div><div class="line"></div><div class="line">     <span class="comment">//把当前沙箱需要的外部变量通过函数参数引入进来</span></div><div class="line"></div><div class="line">     <span class="comment">//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></div><div class="line"></div><div class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line"></div><div class="line">&#125;)( <span class="built_in">window</span> );</div></pre></td></tr></table></figure>
<p>jquery将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法。</p>
<p>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。</p>
<p><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>
<h4 id="ES6的了解"><a href="#ES6的了解" class="headerlink" title="ES6的了解"></a>ES6的了解</h4><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值<code>Inputs=&gt;outputs</code>。）、<code>for-of</code>（用来遍历数据—例如数组中的值。）<code>arguments</code>对象可被不定参数和默认参数完美代替。<code>ES6</code>将<code>promise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。增加了<code>let</code>和<code>const</code>命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，属于全局对象的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。。还有就是引入<code>module</code>模块的概念</p>
<h4 id="js继承方式及其优缺点"><a href="#js继承方式及其优缺点" class="headerlink" title="js继承方式及其优缺点"></a>js继承方式及其优缺点</h4><blockquote>
<p>原型链继承的缺点</p>
</blockquote>
<pre><code>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。
</code></pre><blockquote>
<p>借用构造函数（类式继承）</p>
</blockquote>
<pre><code>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承
</code></pre><blockquote>
<p>组合式继承</p>
</blockquote>
<pre><code>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
</code></pre><p>具体请看：<a href="http://segmentfault.com/a/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<h4 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h4><p><code>HTTP/2</code>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
<p><code>HTTP/2</code>提供更多的加密支持</p>
<p><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。</p>
<p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p>
<p><br></p>
<h4 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h4><blockquote>
<p>defer并行加载js文件，会按照页面上script标签的顺序执行<br>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</p>
</blockquote>
<h4 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h4><p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p>
<h4 id="如何评价AngularJS和BackboneJS"><a href="#如何评价AngularJS和BackboneJS" class="headerlink" title="如何评价AngularJS和BackboneJS"></a>如何评价AngularJS和BackboneJS</h4><p><code>backbone</code>具有依赖性，依赖<code>underscore.js</code>。<code>Backbone + Underscore + jQuery(or Zepto)</code> 就比一个<code>AngularJS</code> 多出了2 次HTTP请求.</p>
<p><br></p>
<p><code>Backbone</code>的<code>Model</code>没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。<code>AngularJS</code>与此相反，Model直接与UI视图绑定，<code>Model</code>与UI视图的关系，通过<code>directive</code>封装，<code>AngularJS</code>内置的通用<code>directive</code>，就能实现大部分操作了，也就是说，基本不必关心<code>Model</code>与UI视图的关系，直接操作Model就行了，UI视图自动更新。</p>
<p><br></p>
<p><code>AngularJS</code>的<code>directive</code>，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。</p>
<h4 id="用过哪些设计模式？"><a href="#用过哪些设计模式？" class="headerlink" title="用过哪些设计模式？"></a>用过哪些设计模式？</h4><blockquote>
<p>工厂模式：</p>
</blockquote>
<pre><code>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。

    工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。


function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.profession = profession;
    obj.move = function () {
        return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession;
    };
    return obj;
}
var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例
</code></pre><p><br></p>
<blockquote>
<p>构造函数模式</p>
</blockquote>
<p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p>
<pre><code>1.构造函数方法没有显示的创建对象 (new Object());

2.直接将属性和方法赋值给 this 对象;

3.没有 renturn 语句。
</code></pre><h4 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h4><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包有三个特性：</p>
<blockquote>
<p>1.函数嵌套函数</p>
<p>2.函数内部可以引用外部的参数和变量</p>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
<p> 具体请看：<a href="http://segmentfault.com/a/1190000000652891" target="_blank" rel="external">详解js闭包</a></p>
<h4 id="请你谈谈Cookie的弊端"><a href="#请你谈谈Cookie的弊端" class="headerlink" title="请你谈谈Cookie的弊端"></a>请你谈谈Cookie的弊端</h4><p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p>
<p>第一：每个特定的域名下最多生成20个<code>cookie</code></p>
<pre><code>1.IE6或更低版本最多20个cookie

2.IE7和之后的版本最后可以有50个cookie。

3.Firefox最多50个cookie

4.chrome和Safari没有做硬性限制
</code></pre><p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>userdata</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<blockquote>
<p>优点：极高的扩展性和可用性</p>
</blockquote>
<pre><code>1.通过良好的编程，控制保存在cookie中的session对象的大小。

2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。

3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。

4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
</code></pre><blockquote>
<p>缺点：</p>
</blockquote>
<pre><code>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.


2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><h4 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h4><p>在较高版本的浏览器中，<code>js</code>提供了<code>sessionStorage</code>和<code>globalStorage</code>。在<code>HTML5</code>中提供了<code>localStorage</code>来取代<code>globalStorage</code>。</p>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h4 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h4><p><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽，另外<code>cookie</code>还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<code>Web Storage</code>拥有<code>setItem,getItem,removeItem,clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie，getCookie</code>。</p>
<p>但是<code>cookie</code>也是不可以或缺的：<code>cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生</p>
<p>浏览器的支持除了<code>IE７</code>及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的<code>userData</code>其实就是<code>javascript</code>本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持<code>web storage</code>。</p>
<p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem、getItem</code>和<code>removeItem</code>等</p>
<h4 id="cookie-和session-的区别："><a href="#cookie-和session-的区别：" class="headerlink" title="cookie 和session 的区别："></a>cookie 和session 的区别：</h4><pre><code>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗

   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

    考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：

   将登陆信息等重要信息存放为SESSION

   其他信息如果需要保留，可以放在COOKIE中
</code></pre><blockquote>
<p><code>display:none</code>和<code>visibility:hidden</code>的区别？</p>
</blockquote>
<pre><code>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。

visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。
</code></pre><blockquote>
<p>CSS中<code>link</code> 和<code>@import</code>的区别是？</p>
</blockquote>
<pre><code>(1) link属于HTML标签，而@import是CSS提供的;

(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;

(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;

(4) link方式的样式的权重 高于@import的权重.
</code></pre><blockquote>
<p><code>position:absolute</code>和<code>float</code>属性的异同</p>
</blockquote>
<ul>
<li>共同点：对内联元素设置<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高。</li>
</ul>
<ul>
<li>不同点：<code>float</code>仍会占据位置，<code>absolute</code>会覆盖文档流中的其他元素。</li>
</ul>
<blockquote>
<p>介绍一下box-sizing属性？</p>
</blockquote>
<p><code>box-sizing</code>属性主要用来控制元素的盒模型的解析模式。默认值是<code>content-box</code>。</p>
<ul>
<li><p><code>content-box</code>：让元素维持W3C的标准盒模型。元素的宽度/高度由<code>border + padding + content</code>的宽度/高度决定，设置<code>width/height</code>属性指的是<code>content</code>部分的宽/高</p>
</li>
<li><p><code>border-box</code>：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置<code>width/height</code>属性指的是<code>border + padding + content</code></p>
</li>
</ul>
<p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p>
<blockquote>
<p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1<span class="selector-class">.id</span>选择器（ # <span class="selector-tag">myid</span>）</div><div class="line"></div><div class="line">2.类选择器（<span class="selector-class">.myclassname</span>）</div><div class="line"></div><div class="line">3.标签选择器（<span class="selector-tag">div</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">4.相邻选择器（<span class="selector-tag">h1</span> + <span class="selector-tag">p</span>）</div><div class="line"></div><div class="line">5.子选择器（<span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>）</div><div class="line"></div><div class="line">6.后代选择器（<span class="selector-tag">li</span> <span class="selector-tag">a</span>）</div><div class="line"></div><div class="line">7.通配符选择器（ * ）</div><div class="line"></div><div class="line">8.属性选择器（<span class="selector-tag">a</span><span class="selector-attr">[rel = "external"]</span>）</div><div class="line"></div><div class="line">9.伪类选择器（<span class="selector-tag">a</span>: <span class="selector-tag">hover</span>, <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>）</div></pre></td></tr></table></figure>
<p><strong>优先级为:</strong></p>
<p><code>!important &gt;  id &gt; class &gt; tag</code></p>
<p><code>important</code> 比 内联优先级高,但内联比 <code>id</code> 要高</p>
<blockquote>
<p>CSS3新增伪类举例：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-of-type</span> 选择属于其父元素的首个 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span>  选择属于其父元素的最后 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span>  选择属于其父元素唯一的 &lt;<span class="selector-tag">p</span>&gt; 元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span>    选择属于其父元素的唯一子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>  选择属于其父元素的第二个子元素的每个 &lt;<span class="selector-tag">p</span>&gt; 元素。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:enabled</span>  <span class="selector-pseudo">:disabled</span> 控制表单控件的禁用状态。</div><div class="line"></div><div class="line"><span class="selector-pseudo">:checked</span>        单选框或复选框被选中。</div></pre></td></tr></table></figure>
<blockquote>
<p>CSS3有哪些新特性？</p>
</blockquote>
<pre><code>CSS3实现圆角（border-radius），阴影（box-shadow），

对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）

transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜

增加了更多的CSS选择器  多背景 rgba

在CSS3中唯一引入的伪元素是::selection.

媒体查询，多栏布局

border-image
</code></pre><p>CSS3中新增了一种盒模型计算方式：<code>box-sizing</code>。盒模型默认的值是<code>content-box</code>, 新增的值是<code>padding-box</code>和<code>border-box</code>，几种盒模型计算元素宽高的区别如下：</p>
<h4 id="content-box（默认）"><a href="#content-box（默认）" class="headerlink" title="content-box（默认）"></a><code>content-box（默认）</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width + padding-left + padding-right + border-left + border-right</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height + padding-top + padding-bottom + border-top + border-bottom</div></pre></td></tr></table></figure>
<h4 id="padding-box"><a href="#padding-box" class="headerlink" title="padding-box"></a><code>padding-box</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right) + border-top + border-bottom</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</div></pre></td></tr></table></figure>
<h4 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a><code>border-box</code></h4><p>布局所占宽度Width：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width = width(包含padding-left + padding-right + border-left + border-right)</div></pre></td></tr></table></figure>
<p>布局所占高度Height:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</div></pre></td></tr></table></figure>
<blockquote>
<p>对BFC规范的理解？</p>
</blockquote>
<pre><code>  BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。
</code></pre><h4 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h4><pre><code>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构

2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；

4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
</code></pre><h4 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><p>1）、<code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</p>
<p>2）、严格模式的排版和 <code>JS</code> 运作模式是  以该浏览器支持的最高标准运行。</p>
<p>3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<p>4）、<code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现。</p>
<h4 id="你知道多少种Doctype文档类型？"><a href="#你知道多少种Doctype文档类型？" class="headerlink" title="你知道多少种Doctype文档类型？"></a>你知道多少种<code>Doctype</code>文档类型？</h4><pre><code> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。

 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。

 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。

Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks

 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。
</code></pre><h4 id="HTML与XHTML——二者有什么区别"><a href="#HTML与XHTML——二者有什么区别" class="headerlink" title="HTML与XHTML——二者有什么区别"></a>HTML与XHTML——二者有什么区别</h4><pre><code>区别：

1.所有的标记都必须要有一个相应的结束标记

2.所有标签的元素和属性的名字都必须使用小写

3.所有的XML标记都必须合理嵌套

4.所有的属性必须用引号&quot;&quot;括起来

5.把所有&lt;和&amp;特殊符号用编码表示

6.给所有属性赋一个值

7.不要在注释内容中使“--”

8.图片必须有说明文字
</code></pre><h4 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h4><pre><code>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.

浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）

#box{ float:left; width:10px; margin:0 0 0 100px;}

这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入
_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

渐进识别的方式，从总体中逐渐排除局部。


  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。

  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

  css

      .bb{

       background-color:#f1ee18;/*所有识别*/

      .background-color:#00deff\9; /*IE6、7、8识别*/

      +background-color:#a200ff;/*IE6、7识别*/

      _background-color:#1e0bd1;/*IE6识别*/

      }


怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发
怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在
可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;`
</code></pre><blockquote>
<p>上下margin重合问题</p>
</blockquote>
<pre><code>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。

解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。
</code></pre><h4 id="解释下浮动和它的工作原理？清除浮动的技巧"><a href="#解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧"></a>解释下浮动和它的工作原理？清除浮动的技巧</h4><pre><code>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。


1.使用空标签清除浮动。

   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。

2.使用overflow。

   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。

3.使用after伪对象清除浮动。

   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
</code></pre><h4 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h4><pre><code>浮动元素引起的问题：

（1）父元素的高度无法被撑开，影响与父元素同级的元素

（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后

（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
</code></pre><blockquote>
<p>解决方法：</p>
</blockquote>
<p>使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>: <span class="string">"."</span>;<span class="attribute">display</span>: block;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">clear</span>: both;<span class="attribute">visibility</span>: hidden;&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.clearfix</span>&#123;<span class="attribute">display</span>: inline-block;&#125; <span class="comment">/* for IE/Mac */</span></div></pre></td></tr></table></figure>
<p><strong>清除浮动的几种方法：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1，额外标签法，&lt;div style="clear:both;"&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</div><div class="line"></div><div class="line">2，使用after伪类</div><div class="line"></div><div class="line">#parent:after&#123;</div><div class="line"></div><div class="line">    content:".";</div><div class="line"></div><div class="line">    height:0;</div><div class="line"></div><div class="line">    visibility:hidden;</div><div class="line"></div><div class="line">    display:block;</div><div class="line"></div><div class="line">    clear:both;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">3,浮动外部元素</div><div class="line"></div><div class="line">4,设置overflow为hidden或者auto</div></pre></td></tr></table></figure>
<h4 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h4><blockquote>
<p>1）创建新节点</p>
</blockquote>
<pre><code>createDocumentFragment()    //创建一个DOM片段

createElement()   //创建一个具体的元素

createTextNode()   //创建一个文本节点
</code></pre><blockquote>
<p>2）添加、移除、替换、插入</p>
</blockquote>
<pre><code>appendChild()

removeChild()

replaceChild()

insertBefore() //并没有insertAfter()
</code></pre><blockquote>
<p>3）查找</p>
</blockquote>
<pre><code>getElementsByTagName()    //通过标签名称

getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，
会得到一个数组，其中包括id等于name值的)

getElementById()    //通过元素Id，唯一性
</code></pre><h4 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h4><pre><code>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

拖拽释放(Drag and drop) API

语义化更好的内容标签（header,nav,footer,aside,article,section）

音频、视频API(audio,video)

画布(Canvas) API

地理(Geolocation) API

本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；

sessionStorage 的数据在浏览器关闭后自动删除


表单控件，calendar、date、time、email、url、search

新的技术webworker, websocket, Geolocation
</code></pre><blockquote>
<p>移除的元素</p>
</blockquote>
<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；
</code></pre><blockquote>
<p>支持HTML5新标签：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">IE8/IE7/IE6支持通过document.createElement方法产生的标签，</div><div class="line"></div><div class="line">可以利用这一特性让这些浏览器支持HTML5新标签，</div><div class="line"></div><div class="line">当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架</div><div class="line"></div><div class="line">   <span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line"></div><div class="line">   &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;</div><div class="line"></div><div class="line">   &lt;![endif]--&gt;</div><div class="line"></div><div class="line">如何区分： DOCTYPE声明\新增的结构元素\功能元素</div></pre></td></tr></table></figure>
<h4 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">调用localstorge、cookies等本地存储方式</div></pre></td></tr></table></figure>
<h4 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> FOUC - Flash Of Unstyled Content 文档样式闪烁</div><div class="line"></div><div class="line"> <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span>&gt;</span><span class="css">@<span class="keyword">import</span> <span class="string">"../fouc.css"</span>;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line">而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</div><div class="line"></div><div class="line"> 解决方法简单的出奇，只要在<span class="tag">&lt;<span class="name">head</span>&gt;</span>之间加入一个<span class="tag">&lt;<span class="name">link</span>&gt;</span>或者<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">元素就可以了。</span></div></pre></td></tr></table></figure>
<h4 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h4><p><code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>。</p>
<p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。</p>
<p><code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<pre><code>（1）变量被声明了，但没有赋值时，就等于undefined。


（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。


（3）对象没有赋值的属性，该属性的值为undefined。


（4）函数没有返回值时，默认返回undefined。
</code></pre><p><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</p>
<pre><code>（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。
</code></pre><h4 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h4><pre><code>   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

   2、属性和方法被加入到 this 引用的对象中。

   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。



var obj  = {};

obj.__proto__ = Base.prototype;

Base.call(obj);
</code></pre><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><pre><code>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js
</code></pre><h4 id="call-和-apply-的区别和作用？"><a href="#call-和-apply-的区别和作用？" class="headerlink" title="call() 和 apply() 的区别和作用？"></a><code>call()</code> 和 <code>apply()</code> 的区别和作用？</h4><p>作用：动态改变某个类的某个方法的运行环境（执行上下文）。</p>
<p>区别参见：<a href="http://segmentfault.com/blog/trigkit4/1190000000660786#articleHeader15" target="_blank" rel="external">JavaScript学习总结（四）function函数部分</a></p>
<h4 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h4><pre><code>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。



setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。

闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</code></pre><p>详见：<a href="http://segmentfault.com/blog/trigkit4/1190000000687844" target="_blank" rel="external">详解js变量、作用域及内存</a></p>
<h4 id="列举IE-与其他浏览器不一样的特性？"><a href="#列举IE-与其他浏览器不一样的特性？" class="headerlink" title="列举IE 与其他浏览器不一样的特性？"></a>列举IE 与其他浏览器不一样的特性？</h4><ul>
<li><p>IE支持<code>currentStyle</code>，FIrefox使用<code>getComputStyle</code></p>
</li>
<li><p>IE  使用<code>innerText</code>，Firefox使用<code>textContent</code></p>
</li>
<li><p>滤镜方面：IE:<code>filter:alpha(opacity= num)</code>；Firefox：<code>-moz-opacity:num</code></p>
</li>
<li><p>事件方面：IE：<code>attachEvent</code>：火狐是<code>addEventListener</code></p>
</li>
<li><p>鼠标位置：IE是<code>event.clientX</code>；火狐是<code>event.pageX</code></p>
</li>
<li><p>IE使用<code>event.srcElement</code>；Firefox使用<code>event.target</code></p>
</li>
<li><p>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置<code>margin:0;padding:0以及list-style:none</code></p>
</li>
<li><p>CSS圆角：ie7以下不支持圆角</p>
</li>
</ul>
<h4 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h4><p>Javascript数据推送</p>
<ul>
<li><code>Commet</code>：基于HTTP长连接的服务器推送技术</li>
</ul>
<ul>
<li>基于<code>WebSocket</code>的推送方案</li>
</ul>
<ul>
<li><code>SSE</code>（Server-Send Event）：服务器推送数据新方式</li>
</ul>
<h4 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h4><pre><code>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。

    1、实现界面交互

    2、提升用户体验

    3、有了Node.js，前端可以实现服务端的一些事情


前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，



 参与项目，快速高质量完成实现效果图，精确到1px；

 与团队成员，UI设计，产品经理的沟通；

 做好的页面结构，页面重构和用户体验；

 处理hack，兼容、写出优美的代码格式；

 针对服务器的优化、拥抱最新前端技术。
</code></pre><h4 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h4><pre><code>    分为4个步骤：

    （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。

    （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

    （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。

    （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。



请求返回后，便进入了我们关注的前端模块

简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM`
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000697254" target="_blank" rel="external">从输入 URL 到浏览器接收的过程中发生了什么事情？</a></p>
<h4 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h4><pre><code>1，工厂模式

2，构造函数模式

3，原型模式

4，混合构造函数和原型模式

5，动态原型模式

6，寄生构造函数模式

7，稳妥构造函数模式
</code></pre><h4 id="javascript继承的6种方法"><a href="#javascript继承的6种方法" class="headerlink" title="javascript继承的6种方法"></a>javascript继承的6种方法</h4><pre><code>1，原型链继承

2，借用构造函数继承

3，组合继承(原型+借用构造)

4，原型式继承

5，寄生式继承

6，寄生组合式继承
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
<h4 id="创建ajax的过程"><a href="#创建ajax的过程" class="headerlink" title="创建ajax的过程"></a>创建ajax的过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)创建<span class="string">`XMLHttpRequest`</span>对象,也就是创建一个异步调用对象.</div><div class="line"></div><div class="line">(<span class="number">2</span>)创建一个新的<span class="string">`HTTP`</span>请求,并指定该<span class="string">`HTTP`</span>请求的方法、<span class="string">`URL`</span>及验证信息.</div><div class="line"></div><div class="line">(<span class="number">3</span>)设置响应<span class="string">`HTTP`</span>请求状态变化的函数.</div><div class="line"></div><div class="line">(<span class="number">4</span>)发送<span class="string">`HTTP`</span>请求.</div><div class="line"></div><div class="line">(<span class="number">5</span>)获取异步调用返回的数据.</div><div class="line"></div><div class="line">(<span class="number">6</span>)使用JavaScript和DOM实现局部刷新.</div><div class="line"></div><div class="line"></div><div class="line">var xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"></div><div class="line">xmlHttp.open(<span class="string">'GET'</span>,<span class="string">'demo.php'</span>,<span class="string">'true'</span>);</div><div class="line"></div><div class="line">xmlHttp.send()</div><div class="line"></div><div class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<h4 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h4><pre><code>1.异步加载的方案： 动态插入script标签

2.通过ajax去获取js代码，然后通过eval执行

3.script标签上添加defer或者async属性

4.创建并插入iframe，让它异步执行js

5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
</code></pre><h4 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h4><pre><code>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个
Firefox，chrome也是6个
</code></pre><p>####<code>Flash</code>、<code>Ajax</code>各自的优缺点，在使用中如何取舍？</p>
<ul>
<li><code>Flash</code>适合处理多媒体、矢量图形、访问机器；对<code>CSS</code>、处理文本上不足，不容易被搜索。</li>
</ul>
<p>-<code>Ajax</code>对<code>CSS</code>、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</p>
<ul>
<li>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</li>
</ul>
<h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h4 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" class="headerlink" title="为什么要有同源限制？"></a>为什么要有同源限制？</h4><p>   我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<p>缺点：</p>
<p>现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h4 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h4><pre><code>    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。


    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，

    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。



然而，在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）

向服务器发送大量数据（POST 没有数据量限制）

发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><h4 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。

2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；

3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`;
</code></pre><h4 id="ajax的缺点和在IE下的问题？"><a href="#ajax的缺点和在IE下的问题？" class="headerlink" title="ajax的缺点和在IE下的问题？"></a>ajax的缺点和在IE下的问题？</h4><p>详情请见：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">JavaScript学习总结（七）Ajax和Http状态字</a></p>
<blockquote>
<p>ajax的缺点</p>
</blockquote>
<pre><code>1、ajax不支持浏览器back按钮。

2、安全问题 AJAX暴露了与服务器交互的细节。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试。
</code></pre><blockquote>
<p>IE缓存问题</p>
</blockquote>
<p>在IE浏览器下，如果请求的方法是<code>GET</code>，并且请求的<code>URL</code>不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的<code>URL</code>，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(<code>&#39;t&#39;= + new Date().getTime()</code>)</p>
<p>或者：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span>(<span class="string">'GET'</span>,<span class="string">'demo.php?rand=+Math.random()'</span>,<span class="literal">true</span>);<span class="comment">//</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Ajax请求的页面历史记录状态问题</p>
</blockquote>
<p>可以通过锚点来记录状态，<code>location.hash</code>。让浏览器记录Ajax请求时页面状态的变化。</p>
<p>还可以通过<code>HTML5</code>的<code>history.pushState</code>，来实现浏览器地址栏的无刷新改变</p>
<h4 id="谈谈你对重构的理解"><a href="#谈谈你对重构的理解" class="headerlink" title="谈谈你对重构的理解"></a>谈谈你对重构的理解</h4><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，<br>在扩展的同时保持一致的UI。</p>
<pre><code>对于传统的网站来说重构通常是：

表格(table)布局改为DIV+CSS

使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)

对于移动平台的优化

针对于SEO进行优化

深层次的网站重构应该考虑的方面


减少代码间的耦合

让代码保持弹性

严格按规范编写代码

设计可扩展的API

代替旧有的框架、语言(如VB)

增强用户体验

通常来说对于速度的优化也包含在重构中



压缩JS、CSS、image等前端资源(通常是由服务器来解决)

程序的性能优化(如数据读写)

采用CDN来加速资源加载

对于JS DOM的优化

HTTP服务器的文件缓存
</code></pre><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</div><div class="line"></div><div class="line">200  OK   正常返回信息</div><div class="line"></div><div class="line">201  Created  请求成功并且服务器创建了新的资源</div><div class="line"></div><div class="line">202  Accepted  服务器已接受请求，但尚未处理</div><div class="line"></div><div class="line">301  Moved Permanently  请求的网页已永久移动到新位置。</div><div class="line"></div><div class="line">302 Found  临时性重定向。</div><div class="line"></div><div class="line">303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</div><div class="line"></div><div class="line">304  Not Modified  自从上次请求后，请求的网页未修改过。</div><div class="line"></div><div class="line"></div><div class="line">400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</div><div class="line"></div><div class="line">401 Unauthorized  请求未授权。</div><div class="line"></div><div class="line">403 Forbidden  禁止访问。</div><div class="line"></div><div class="line">404 Not Found  找不到如何与 URI 相匹配的资源。</div><div class="line"></div><div class="line">500 Internal Server Error  最常见的服务器端错误。</div><div class="line"></div><div class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</div></pre></td></tr></table></figure>
<h4 id="说说你对Promise的理解"><a href="#说说你对Promise的理解" class="headerlink" title="说说你对Promise的理解"></a>说说你对Promise的理解</h4><p>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：</p>
<pre><code>pending: 初始状态, 非 fulfilled 或 rejected.

fulfilled: 成功的操作.

rejected: 失败的操作.

settled: Promise已被fulfilled或rejected，且不是pending
</code></pre><p>另外， <code>fulfilled</code> 与 <code>rejected</code> 一起合称 <code>settled</code>。</p>
<p><code>Promise</code> 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p>
<blockquote>
<p>Promise 的构造函数</p>
</blockquote>
<p>构造一个 <code>Promise</code>，最基本的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></div><div class="line"></div><div class="line">        resolve(result);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></div><div class="line"></div><div class="line">        reject(<span class="built_in">Error</span>(errMessage));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为 <code>thenable</code>）。它的使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在 <code>rejected</code> 的时候被调用，接收参数就是 <code>future，onFulfilled</code> 对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code>。</p>
<h4 id="说说你对前端架构师的理解"><a href="#说说你对前端架构师的理解" class="headerlink" title="说说你对前端架构师的理解"></a>说说你对前端架构师的理解</h4><p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；<br>带领团队完成研发工具及平台前端部分的设计、研发和维护；<br>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先<br>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</p>
<h4 id="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</div><div class="line"></div><div class="line">                o[e] = <span class="keyword">typeof</span> <span class="keyword">this</span>[e] === <span class="string">"object"</span> ? <span class="keyword">this</span>[e].clone() : <span class="keyword">this</span>[e];</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h4><p>严格模式主要有以下限制：</p>
<pre><code>变量必须声明后再使用

函数的参数不能有同名属性，否则报错

不能使用with语句

不能对只读属性赋值，否则报错

不能使用前缀0表示八进制数，否则报错

不能删除不可删除的属性，否则报错

不能删除变量delete prop，会报错，只能删除属性delete global[prop]

eval不会在它的外层作用域引入变量

eval和arguments不能被重新赋值

arguments不会自动反映函数参数的变化

不能使用arguments.callee

不能使用arguments.caller

禁止this指向全局对象

不能使用fn.caller和fn.arguments获取函数调用的堆栈

增加了保留字（比如protected、static和interface）
</code></pre><p>设立”严格模式”的目的，主要有以下几个：</p>
<ul>
<li><p>消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
</li>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
</li>
<li><p>提高编译器效率，增加运行速度；</p>
</li>
<li><p>为未来新版本的<code>Javascript</code>做好铺垫。</p>
</li>
</ul>
<p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p>
<h4 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h4><blockquote>
<p>1.将时间设为当前时间往前一点。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line">date.setDate(date.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></div></pre></td></tr></table></figure>
<p><code>setDate()</code>方法用于设置一个月的某一天。</p>
<blockquote>
<p>2.expires的设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h4 id="lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签"><a href="#lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签" class="headerlink" title="&lt;strong&gt;，&lt;em&gt;和&lt;b&gt;，&lt;i&gt;标签"></a><code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code>和<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 标签和 <span class="tag">&lt;<span class="name">em</span>&gt;</span> 标签一样，用于强调文本，但它强调的程度更强一些。</div><div class="line"></div><div class="line">em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 <span class="tag">&lt;<span class="name">i</span>&gt;</span>...<span class="tag">&lt;/<span class="name">i</span>&gt;</span>;</div><div class="line"></div><div class="line"><span class="tag">&lt; <span class="attr">b</span> &gt;</span> <span class="tag">&lt; <span class="attr">i</span> &gt;</span>是视觉要素，分别表示无意义的加粗，无意义的斜体。</div><div class="line"></div><div class="line">em 和 strong 是表达要素(phrase elements)。</div></pre></td></tr></table></figure>
<h4 id="说说你对AMD和Commonjs的理解"><a href="#说说你对AMD和Commonjs的理解" class="headerlink" title="说说你对AMD和Commonjs的理解"></a>说说你对AMD和Commonjs的理解</h4><p><code>CommonJS</code>是服务器端模块的规范，Node.js采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<blockquote>
<p>详情：<a href="https://segmentfault.com/a/1190000004888589" target="_blank" rel="external">也谈webpack及其开发模式</a></p>
</blockquote>
<h4 id="document-write-的用法"><a href="#document-write-的用法" class="headerlink" title="document.write()的用法"></a>document.write()的用法</h4><p><code>document.write()</code>方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。</p>
<p><code>document.write</code>只能重绘整个页面。<code>innerHTML</code>可以重绘页面的一部分</p>
<h4 id="编写一个方法-求一个字符串的字节长度"><a href="#编写一个方法-求一个字符串的字节长度" class="headerlink" title="编写一个方法 求一个字符串的字节长度"></a>编写一个方法 求一个字符串的字节长度</h4><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> len = str.length;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> bytes = len;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> bytes;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</div></pre></td></tr></table></figure>
<h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a>git fetch和git pull的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git pull：相当于是从远程获取最新版本并merge到本地</div><div class="line"></div><div class="line">git fetch：相当于是从远程获取最新版本到本地，不会自动merge</div></pre></td></tr></table></figure>
<h4 id="说说你对MVC和MVVM的理解"><a href="#说说你对MVC和MVVM的理解" class="headerlink" title="说说你对MVC和MVVM的理解"></a>说说你对MVC和MVVM的理解</h4><blockquote>
<p><code>MVC</code></p>
</blockquote>
<pre><code>View 传送指令到 Controller

Controller 完成业务逻辑后，要求 Model 改变状态

Model 将新的数据发送到 View，用户得到反馈
</code></pre><p>所有通信都是单向的。</p>
<p><code>Angular</code>它采用双向绑定（data-binding）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然。</p>
<pre><code>组成部分Model、View、ViewModel

View：UI界面

ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；

Model：数据访问层
</code></pre><h4 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理"></a>请解释什么是事件代理</h4><p>事件代理（Event Delegation），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是<code>DOM</code>元素的事件冒泡。使用事件代理的好处是可以提高性能。</p>
<h4 id="attribute和property的区别是什么？"><a href="#attribute和property的区别是什么？" class="headerlink" title="attribute和property的区别是什么？"></a>attribute和property的区别是什么？</h4><p><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</p>
<p><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</p>
<p>所以：</p>
<p>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的，</p>
<p>但是对于自定义的属性来说，他们是不同步的，</p>
<h4 id="说说网络分层里七层模型是哪七层"><a href="#说说网络分层里七层模型是哪七层" class="headerlink" title="说说网络分层里七层模型是哪七层"></a>说说网络分层里七层模型是哪七层</h4><ul>
<li><p>应用层：应用层、表示层、会话层（从上往下）（<code>HTTP、FTP、SMTP、DNS</code>）</p>
</li>
<li><p>传输层（<code>TCP</code>和<code>UDP</code>）</p>
</li>
<li><p>网络层（<code>IP</code>）</p>
</li>
<li><p>物理和数据链路层（以太网）</p>
</li>
</ul>
<blockquote>
<p>每一层的作用如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</div><div class="line">数据链路层：将比特组装成帧和点到点的传递（帧Frame）</div><div class="line">网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</div><div class="line">传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</div><div class="line">会话层：建立、管理和终止会话（会话协议数据单元SPDU）</div><div class="line">表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</div><div class="line">应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</div></pre></td></tr></table></figure>
<blockquote>
<p>各种协议</p>
</blockquote>
<p><code>ICMP协议</code>： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br><code>TFTP协议</code>： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br><code>HTTP协议</code>： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br><code>DHCP协议</code>： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<h4 id="说说mongoDB和MySQL的区别"><a href="#说说mongoDB和MySQL的区别" class="headerlink" title="说说mongoDB和MySQL的区别"></a>说说mongoDB和MySQL的区别</h4><p><code>MySQL</code>是传统的关系型数据库，<code>MongoDB</code>则是非关系型数据库</p>
<p> <code>mongodb</code>以<code>BSON</code>结构（二进制）进行存储，对海量数据存储有着很明显的优势。</p>
<p>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：<br>①弱一致性（最终一致），更能保证用户的访问速度：<br>②文档结构的存储方式，能够更便捷的获取数据。</p>
<h4 id="讲讲304缓存的原理"><a href="#讲讲304缓存的原理" class="headerlink" title="讲讲304缓存的原理"></a>讲讲304缓存的原理</h4><p>服务器首先产生<code>ETag</code>，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p><br></p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>
<p><br></p>
<p>客户端请求一个页面（A）。 服务器返回页面A，并在给<code>A</code>加上一个<code>ETag</code>。 客户端展现该页面，并将页面连同<code>ETag</code>一起缓存。 客户再次请求页面<code>A</code>，并将上次请求时服务器返回的<code>ETag</code>一起传递给服务器。 服务器检查该<code>ETag</code>，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应<code>304</code>（未修改——<code>Not Modified</code>）和一个空的响应体。</p>
<p><br></p>
<h4 id="什么样的前端代码是好的"><a href="#什么样的前端代码是好的" class="headerlink" title="什么样的前端代码是好的"></a>什么样的前端代码是好的</h4><p>高复用低耦合，这样文件小，好维护，而且好扩展。</p>
<h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4><ul>
<li><a href="./readme.html">css代码题</a></li>
<li><a href="./readme.js">js代码题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文涵盖了前端面试中会涉及的方方面面题目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/#more&quot;&gt;前端面试题集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生大病，只是一“傲”字。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="http://damonare.github.io/tags/HTTP/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://damonare.github.io/tags/HTML/"/>
    
      <category term="面试" scheme="http://damonare.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="TCP/IP" scheme="http://damonare.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Hexo折腾记</title>
    <link href="http://damonare.github.io/2016/09/06/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>http://damonare.github.io/2016/09/06/Hexo折腾记/</id>
    <published>2016-09-05T16:17:05.192Z</published>
    <updated>2016-11-26T10:03:18.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 博主之前也有折腾wordpress和jekyll可对于一个前端er来说，wordpress让人没法尽兴，因为不知道该如何添加自己的代码。而jekyll就太麻烦了每一次都需要重新提交，而且样式也不是很丰富，简直就和鸡肋一般。食之无味，弃之可惜。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/06/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0/#more">Hexo折腾记</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>如果时间可以静止，我希望就停在此刻。</strong></p>
<a id="more"></a>
<p><strong>之前有听说过Hexo这个博客框架，但一直没时间给自己搭一个，其实平时也有注意到很多大牛的博客是很绚丽的，却不知道那就是Hexo。说干就干，历时一整天，踩坑无数，终于变成了博主想要的样子。放个链接<a href="https://damonare.github.io">Damonare的个人博客</a>如果你也想要一个和博主一样的博客，那就继续看下去吧。</strong></p>
<ul>
<li>博主系统Window7,搭建博客主题Yilia。下面记录博主搭建的整个过程。</li>
</ul>
<h2 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h2><blockquote>
<ul>
<li>想搭建一个博客的应该大多数都是程序员吧，那么github账号应该是一定有的了。你要是实在清新脱俗到连个github账号也没有，不用担心，给你个外链<a href="https://github.com" target="_blank" rel="external">Github</a>,账号设置然后添加SSH,这样你之后输入hexo命令的时候就不用一次次输入密码了，关于如何注册github和添加SSH，这里需要提醒一点，github账号最好都是小写字母，不然容易解析错误，还有邮箱，尽量别用国内的邮箱，很容易出问题了，比如你git提交的贡献不被记录。</li>
<li>Git身为程序员给他应该是会用的吧。好吧假设你不会使用git和github给你个外链<a href="http://www.cnblogs.com/peterzd/archive/2012/04/22/2465230.html" target="_blank" rel="external">看这里</a></li>
</ul>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul>
<li><p>好的，现在你有了github和git了，也配置好了，那么就需要在github新建一个仓库了,</p>
<p><img src="http://img.blog.csdn.net/20160906153800293" alt="这里写图片描述"></p>
<p><strong>注意：这里的仓库名称要和你的username对应</strong></p>
</li>
<li>Node安装</li>
</ul>
<blockquote>
<p>Node可以去官网下载，或是在国内下载，由于众所周知的原因，这里放一个<a href="http://nodejs.cn/" target="_blank" rel="external">nodejs.cn</a>的链接<br>Node内置npm包，我们之后就可以打开node命令行使用npm进行安装一些依赖，如果觉得太慢，可以使用淘宝镜像cnpm</p>
</blockquote>
<ul>
<li>Hexo安装</li>
</ul>
<blockquote>
<p>好的，现在我们Node,git,github都弄好了，现在可以本地化一个hexo了,新建hexo文件夹，任意盘下都可以，然后命令行执行命令：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> hexo -g  <span class="comment">#-g表示全局安装, npm默认为当前项目安装</span></div></pre></td></tr></table></figure></p>
<p>如果遇到错误：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Release/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/default/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div><div class="line">&#123; [Error: Cannot <span class="built_in">find</span> <span class="keyword">module</span> <span class="string">'./build/Debug/DTraceProviderBindings'</span>] code: <span class="string">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>改用下面的命令安装：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> install hexo --<span class="literal">no</span>-optional</div></pre></td></tr></table></figure></p>
<p>好的，现在hexo也就绪了,hexo命令：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/git</div><div class="line">hexo init hexo  <span class="comment">#执行init命令初始化到你指定的hexo目录</span></div><div class="line"><span class="built_in">cd</span> hexo</div><div class="line">npm install    <span class="comment">#install before start blogging</span></div><div class="line">hexo generate       <span class="comment">#自动根据当前目录下文件,生成静态网页</span></div><div class="line">hexo server         <span class="comment">#运行本地服务</span></div></pre></td></tr></table></figure>
<blockquote>
<p>浏览器输入<a href="http://localhost:4000就可以看到效果。" target="_blank" rel="external">http://localhost:4000就可以看到效果。</a><br> <strong>浏览目录</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">├── .deploy       <span class="meta">#需要部署的文件</span></div><div class="line">├── node_modules  <span class="meta">#Hexo插件</span></div><div class="line">├── <span class="keyword">public</span>        <span class="meta">#生成的静态网页文件</span></div><div class="line">├── scaffolds     <span class="meta">#模板</span></div><div class="line">├── source        <span class="meta">#博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span></div><div class="line">|   ├── _drafts   <span class="meta">#草稿</span></div><div class="line">|   └── _posts    <span class="meta">#文章</span></div><div class="line">├── themes        <span class="meta">#主题</span></div><div class="line">├── _config.yml   <span class="meta">#全局配置文件</span></div><div class="line">└── <span class="keyword">package</span>.json</div></pre></td></tr></table></figure></p>
<p>添加博文<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span>  <span class="meta">#新建博文,其中postName是博文题目</span></div></pre></td></tr></table></figure></p>
<p>如果不想博文在首页全部显示, 并能出现阅读全文按钮效果, 需要在你想在首页显示的部分下添加</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--more--&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这点和wordpress是一样的</p>
</blockquote>
<h2 id="Hexo-Yilia主题配置"><a href="#Hexo-Yilia主题配置" class="headerlink" title="Hexo Yilia主题配置"></a>Hexo Yilia主题配置</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd <span class="regexp">~/git/</span>hexo</div><div class="line">git clone git<span class="meta">@github</span>.<span class="string">com:</span>litten<span class="regexp">/hexo-theme-yilia.git themes/</span>yilia</div></pre></td></tr></table></figure>
<blockquote>
<p>在./_config.yml，修改主题为yilia<br>theme: yilia</p>
<p>Hexo <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题</a></p>
</blockquote>
<p>查看本地效果<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">hexo g</span></div><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<h3 id="完整配置信息如下："><a href="#完整配置信息如下：" class="headerlink" title="完整配置信息如下："></a>完整配置信息如下：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site #站点信息</span></div><div class="line"><span class="attr">title:</span> blog Name <span class="comment">#标题</span></div><div class="line"><span class="attr">subtitle:</span> Subtitle <span class="comment">#副标题</span></div><div class="line"><span class="attr">description:</span> my blog desc <span class="comment">#描述</span></div><div class="line"><span class="attr">author:</span> me <span class="comment">#作者</span></div><div class="line"><span class="attr">language:</span> zh-CN <span class="comment">#语言</span></div><div class="line"><span class="attr">timezone:</span> Asia/Shanghai <span class="comment">#时区</span></div><div class="line"></div><div class="line"><span class="comment"># URL</span></div><div class="line"><span class="attr">url:</span> http://yoururl.com   <span class="comment">#用于绑定域名, 其他的不需要配置</span></div><div class="line"><span class="attr">root:</span> /</div><div class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></div><div class="line"><span class="attr">permalink:</span> posts/title.html</div><div class="line"><span class="attr">permalink_defaults:</span></div><div class="line"></div><div class="line"><span class="comment"># Directory #目录</span></div><div class="line"><span class="attr">source_dir:</span> source <span class="comment">#源文件</span></div><div class="line"><span class="attr">public_dir:</span> public <span class="comment">#生成的网页文件</span></div><div class="line"><span class="attr">tag_dir:</span> tags <span class="comment">#标签</span></div><div class="line"><span class="attr">archive_dir:</span> archives <span class="comment">#归档</span></div><div class="line"><span class="attr">category_dir:</span> categories <span class="comment">#分类</span></div><div class="line"><span class="attr">code_dir:</span> downloads/code</div><div class="line"><span class="attr">i18n_dir:</span> :lang <span class="comment">#国际化</span></div><div class="line"><span class="attr">skip_render:</span></div><div class="line"></div><div class="line"><span class="comment"># Writing #写作</span></div><div class="line"><span class="attr">new_post_name:</span> :title.md <span class="comment">#新文章标题</span></div><div class="line"><span class="attr">default_layout:</span> post <span class="comment">#默认模板(post page photo draft)</span></div><div class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment">#标题转换成大写</span></div><div class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment">#新标签页里打开连接</span></div><div class="line"><span class="attr">filename_case:</span> <span class="number">0</span></div><div class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></div><div class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></div><div class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></div><div class="line"><span class="attr">future:</span> <span class="literal">true</span></div><div class="line"><span class="attr">highlight:</span> <span class="comment">#语法高亮</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  line_number:</span> <span class="literal">true</span> <span class="comment">#显示行号</span></div><div class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  tab_replace:</span></div><div class="line"></div><div class="line"><span class="comment"># Category &amp; Tag #分类和标签</span></div><div class="line"><span class="attr">default_category:</span> uncategorized <span class="comment">#默认分类</span></div><div class="line"><span class="attr">category_map:</span></div><div class="line"><span class="attr">tag_map:</span></div><div class="line"></div><div class="line"><span class="comment"># Date / Time format #日期时间格式</span></div><div class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></div><div class="line"><span class="attr">date_format:</span> YYYY-MM-DD</div><div class="line"><span class="attr">time_format:</span> HH:mm:ss</div><div class="line"></div><div class="line"><span class="comment"># Pagination #分页</span></div><div class="line"><span class="attr">per_page:</span> <span class="number">10</span> <span class="comment">#每页文章数, 设置成 0 禁用分页</span></div><div class="line"><span class="attr">pagination_dir:</span> page</div><div class="line"></div><div class="line"><span class="comment"># Extensions #插件和主题</span></div><div class="line"><span class="comment">## 插件: http://hexo.io/plugins/</span></div><div class="line"><span class="comment">## 主题: http://hexo.io/themes/</span></div><div class="line"><span class="attr">theme:</span> next</div><div class="line"></div><div class="line"><span class="comment"># Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面</span></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">- type:</span> git</div><div class="line"><span class="attr">  repo:</span> git@gitcafe.com:username/username.git,gitcafe-pages</div><div class="line"><span class="attr">- type:</span> git</div><div class="line"><span class="attr">  repo:</span> git@github.com:username/username.github.io.git,master</div><div class="line"></div><div class="line"><span class="comment"># Disqus #Disqus评论系统</span></div><div class="line"><span class="attr">disqus_shortname:</span></div><div class="line"></div><div class="line"><span class="attr">plugins:</span> <span class="comment">#插件，例如生成 RSS 和站点地图的</span></div><div class="line"><span class="bullet">-</span> hexo-generator-feed</div><div class="line"><span class="bullet">-</span> hexo-generator-sitemap</div></pre></td></tr></table></figure>
<blockquote>
<p>其它设置，可参考：<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="external">这篇博文</a></p>
</blockquote>
<h3 id="Hexo-Yilia-Bug修改"><a href="#Hexo-Yilia-Bug修改" class="headerlink" title="Hexo Yilia Bug修改"></a>Hexo Yilia Bug修改</h3><blockquote>
<p>修改参考<a href="https://github.com/litten/hexo-theme-yilia/issues" target="_blank" rel="external">这里</a>基本所有的问题都能在这里解决了,所以啊，一个项目的issue真的很具有参考价值，少走不少弯路，通过这里的代码博主添加了 Hexo文章统计 功能，没有动画，头像设置有null的问题以及点击小房子没反应的bug。</p>
</blockquote>
<p>&gt;</p>
<h2 id="Hexo添加文章目录"><a href="#Hexo添加文章目录" class="headerlink" title="Hexo添加文章目录"></a>Hexo添加文章目录</h2><blockquote>
<p>我们首先要编辑文章显示页面的模板，也就是<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">themes<span class="regexp">/landscape/</span>layout<span class="regexp">/_partial/</span>article.ejs</div></pre></td></tr></table></figure></p>
<p>文件。为了将目录生成在正文之前，我们首先在这个文件中找到<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby"> post.content </span><span class="xml"><span class="tag">%&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>并在这一行之前加入如下代码：</p>
</blockquote>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="comment">&lt;!-- Table of Contents --&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl"> <span class="keyword">if</span> (!<span class="keyword">index</span> &amp;&amp; post.toc)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toc"</span> <span class="attr">class</span>=<span class="string">"toc-article"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">"toc-title"</span>&gt;</span>文章目录<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl">- toc(post.content) </span><span class="xml"><span class="tag">%&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span><span class="perl"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的含义清晰明了，if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的div。</p>
<p>修改完这个文件之后，找一篇包含了多个子标题的文章，并在文章开头的front-matter中添加一句toc: true，在浏览器中访问这篇文章，应该可以看到文章的开头处已经有了带链接的目录。但是这样的目录实在太难看，我们还需要添加相应的CSS来将其指定为我们想要的样式。</p>
<p>要指定目录的样式，我们要修改的文件是<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">themes<span class="regexp">/landscape/</span><span class="keyword">source</span><span class="regexp">/css/</span>_partial<span class="regexp">/article.styl</span></div></pre></td></tr></table></figure></p>
<p>在文件的最后，添加如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*toc*/</span></div><div class="line"><span class="selector-class">.toc-article</span></div><div class="line">	<span class="attribute">background</span> <span class="number">#eee</span></div><div class="line">	<span class="attribute">border</span> <span class="number">1px</span> solid <span class="number">#bbb</span></div><div class="line">	<span class="attribute">border-radius</span> <span class="number">10px</span></div><div class="line">	<span class="attribute">margin</span> <span class="number">1.5em</span> <span class="number">0</span> <span class="number">0.3em</span> <span class="number">1.5em</span></div><div class="line">	<span class="attribute">padding</span> <span class="number">1.2em</span> <span class="number">1em</span> <span class="number">0</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">max-width</span> <span class="number">28%</span></div><div class="line"></div><div class="line"><span class="selector-class">.toc-title</span></div><div class="line">	<span class="attribute">font-size</span> <span class="number">120%</span></div><div class="line"></div><div class="line"><span class="selector-id">#toc</span></div><div class="line">	<span class="attribute">line-height</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">font-size</span> <span class="number">0.9em</span></div><div class="line">	<span class="attribute">float</span> right</div><div class="line"><span class="selector-class">.toc</span></div><div class="line">	<span class="attribute">padding</span> <span class="number">0</span></div><div class="line">	<span class="attribute">margin</span> <span class="number">1em</span></div><div class="line">	<span class="attribute">line-height</span> <span class="number">1.8em</span></div><div class="line">	<span class="selector-tag">li</span></div><div class="line">	<span class="attribute">list-style-type</span> none</div><div class="line"></div><div class="line"><span class="selector-class">.toc-child</span></div><div class="line">	<span class="attribute">margin-left</span> <span class="number">1em</span></div></pre></td></tr></table></figure>
<p>由于Hexo使用的是stylus预处理器，所以CSS代码要注意缩进，不然就报错了，这种目录要是不满意完全可以按照自己意愿写一个。</p>
</blockquote>
<h2 id="Hexo-多说评论框"><a href="#Hexo-多说评论框" class="headerlink" title="Hexo 多说评论框"></a>Hexo 多说评论框</h2><blockquote>
<p>链接：<a href="http://ssk.91txh.com/205" target="_blank" rel="external">多说社会化评论框核心脚本embed.js本地化方法</a><br>链接：<a href="http://ssk.91txh.com/207" target="_blank" rel="external">多说社会化评论框添加 站长回复 标记</a><br>链接： <a href="http://ssk.91txh.com/209" target="_blank" rel="external">多说回复后显示浏览器及操作系统信息（Useragent）</a></p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>有任何问题请在评论中回复，博主会在评论中解答。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 博主之前也有折腾wordpress和jekyll可对于一个前端er来说，wordpress让人没法尽兴，因为不知道该如何添加自己的代码。而jekyll就太麻烦了每一次都需要重新提交，而且样式也不是很丰富，简直就和鸡肋一般。食之无味，弃之可惜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/06/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0/#more&quot;&gt;Hexo折腾记&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果时间可以静止，我希望就停在此刻。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://damonare.github.io/categories/life/"/>
    
    
      <category term="Hexo" scheme="http://damonare.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Javascript作用域总结</title>
    <link href="http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/09/06/javascript作用域总结/</id>
    <published>2016-09-05T16:04:16.808Z</published>
    <updated>2016-11-26T10:14:02.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/#more">Javascript作用域总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生世上风波险，一日风波十二时。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><strong>这个应该好理解，函数作用域就是说定义在函数中的参数和变量在函数外部是不可见的。</strong></p>
<p><strong>大多数类C语言都拥有块级作用域，JS却没有。请看下文demo:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C语言</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line">i--;</div><div class="line"><span class="keyword">if</span>(i)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> j=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d/n"</span>,j);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行这段代码，会出现“use an undefined variable:j”的错误。可以看到，C语言拥有块级作用域，因为j是在if的语句块中定义的，因此，它在块外是无法访问的。</strong></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><hr>
<blockquote>
<p>任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
</blockquote>
<p>正如我们举的C语言的例子，大多数类C语言都是有块级作用域的，那么在JavaScript又有什么不同呢？</p>
<p><strong>我们一起看看这个JavaScript的demo:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">functin test()&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">&#125;</div><div class="line">alert(i);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p><strong>运行这段代码，弹出”3”，可见，在块外，块中定义的变量i仍然是可以访问的。也就是说，JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。</strong></p>
<p><strong>那么我们该如何使JS拥有块级作用域呢？是否还记得，在一个函数中定义的变量，当这个函数调用完后，变量会被销毁，我们是否可以用这个特性来模拟出JS的块级作用域呢？看下面这个demo：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">&#125;</div><div class="line">&#125;)();</div><div class="line">alert(i);</div><div class="line">&#125;</div><div class="line">test();</div></pre></td></tr></table></figure>
<p><strong>这时候再次运行，会弹出”i”未定义的错误，哈哈，实现了吧~~~这里，我们把for语句块放到了一个闭包之中，然后调用这个函数，当函数调用完毕，变量i自动销毁，因此，我们在块外便无法访问了。</strong></p>
<p><strong>JS的闭包特性is the most important feature((<em>^__^</em>) 大家懂的)。在JS中，为了防止命名冲突，我们应该尽量避免使用全局变量和全局函数。那么，该如何避免呢？不错，正如上文demo所示，我们可以把要定义的所有内容放入到一个</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//内容</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><strong>之中，这时候，我们是不是相当于给它们的外层添加了一个函数作用域呢？该作用域之外的程序是无法访问它们的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/06/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%80%BB%E7%BB%93/#more&quot;&gt;Javascript作用域总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生世上风波险，一日风波十二时。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
