<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damonare的个人博客</title>
  <subtitle>不念过去，不畏将来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://damonare.github.io/"/>
  <updated>2017-02-08T14:54:01.933Z</updated>
  <id>http://damonare.github.io/</id>
  
  <author>
    <name>Damonare</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解Node.js的事件轮询</title>
    <link href="http://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"/>
    <id>http://damonare.github.io/2017/02/08/理解Node.js的事件轮询/</id>
    <published>2017-02-08T11:49:30.871Z</published>
    <updated>2017-02-08T14:54:01.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：</p>
<ul>
<li>原文地址：<a href="https://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/#more">理解Node.js的事件轮询</a></li>
<li>Node小应用：<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a></li>
</ul>
<p><strong>智者阅读群书，亦阅历人生</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Node-js的两个基本概念"><a href="#Node-js的两个基本概念" class="headerlink" title="Node.js的两个基本概念"></a>Node.js的两个基本概念</h4><p>Node.js的第一个基本概念就是I/O操作开销是巨大的：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/io-cost.png" alt=""></p>
<p>所以，当前变成技术中最大的浪费来自于等待I/O操作的完成。有几种方法可以解决性能的影响：</p>
<ul>
<li><strong>同步方式</strong>：按次序一个一个的处理请求。<em>利</em>：简单；<em>弊</em>：任何一个请求都可以阻塞其他所有请求。</li>
<li><strong>开启新进程</strong>：每个请求都开启一个新进程。<em>利</em>：简单；<em>弊</em>：大量的链接意味着大量的进程。</li>
<li><strong>开启新线程</strong>：每个请求都开启一个新线程。<em>利</em>：简单，而且跟进程比，对系统内核更加友好，因为线程比进程轻的多;<em>弊</em>:不是所有的机器都支持线程，而且对于要处理共享资源的情况，多线程编程会很快变得太过于复杂。</li>
</ul>
<p>第二个基本概念是每个连接都创建一个新线程是很消耗内存的（例如：你可以对比Nginx回想一下Apache内存耗尽的情景）。</p>
<p>Apache是多线程的：它为每个请求开启一个新的线程（或者是进程，这取决于你的配置），当并发连接增多时，你可以看看它是怎么一点一点耗尽内存的。Nginx和Node.js不是多线程的，因为线程的消耗太“重”了。它们两个是单线程、基于事件的，这就把处理众多连接所产生的线程/进程消耗给消除了。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>确实只有一个线程：你不能并行执行任何代码，比如：下面的“sleep”将会阻塞sever1秒钟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> now = <span class="keyword">new</span> Data().getTime();</div><div class="line">   <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &lt; now + <span class="number">1000</span>) &#123;</div><div class="line">         <span class="comment">// do nothing</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">sleep();</div></pre></td></tr></table></figure>
<p>但就我目前学习阶段而言，我觉得好多人对于所谓的node单线程是有误解的。实际上官方给出的“单线程”是具有误导性的。所谓的单线程是指你的代码只运行在一个线程上(好多地方都叫它主线程，实际上Javascript的浏览器运行环境不也是这么处理我们写的Javascript代码的嘛)，而诸多任务的并行处理，就需要多线程了，如下图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/104032-20150917140900539-1845886135.png" alt=""></p>
<p>如上图，Node.js中的单线程之说指的就是这个主线程，这个主线程有一个循环结构，保持着整个程序(你写的代码)的运转。</p>
<h4 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h4><p>其实上面我们所说的<strong>维持主线程运行的循环</strong>这部分就是”事件轮询”，它存在于主线程中，负责不停地调用开发者编写的代码。但对开发者是不可见的。so…开发者编写的代码是怎样被调用的呢？看下图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/104032-20150917141055570-1948801510.png" alt=""></p>
<p>如上图，异步函数在执行结束后，会在事件队列中添加一个事件(遵循先进先出原则)，主线程中的代码执行完毕后(即一次循环结束)，下一次循环开始就在事件队列中”读取”事件，然后调用它所对应的回调函数(所以回调函数的执行顺序是不一定的)。如果开发者在回调函数中调用了阻塞方法(比如上文中的sleep函数)，那么整个事件轮询就会阻塞，事件队列中的事件得不到及时处理。正因为这样，nodejs中的一些库方法均是异步的，也提倡用户调用异步方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;  <span class="comment">//异步读取文件</span></div><div class="line">　　<span class="built_in">console</span>.log(<span class="string">"read file end"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"call readFile over"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码，我们虽然使用了异步方法readfile读取文件，但<code>read file end</code>永远不会输出，因为代码始终在while循环中，下一次事件轮询始终没法开始，也就没法’读取’事件队列调用相应的回调函数了。</p>
<p>最后有一个<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a>是博主平时积累的一些代码，包含注释，汇总成了一个小应用，还是可以看到学习的蛛丝马迹的。感兴趣的您可以看看。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>参考文章：</p>
<ul>
<li><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop" target="_blank" rel="external">Understanding the node.js event loop</a></li>
<li><a href="http://www.cnblogs.com/xiaozhi_5638/p/4816265.html" target="_blank" rel="external">nodejs事件轮询详述</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://damonare.github.io/2017/02/08/%E7%90%86%E8%A7%A3Node.js%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/#more&quot;&gt;理解Node.js的事件轮询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node小应用：&lt;a href=&quot;https://github.com/damonare/node-sample&quot;&gt;Node-sample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;智者阅读群书，亦阅历人生&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://damonare.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>理解Node.js(译文)</title>
    <link href="http://damonare.github.io/2017/02/05/%E7%90%86%E8%A7%A3Node.js(%E8%AF%91%E6%96%87)/"/>
    <id>http://damonare.github.io/2017/02/05/理解Node.js(译文)/</id>
    <published>2017-02-05T09:29:12.158Z</published>
    <updated>2017-02-08T11:58:57.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：这篇文章十分生动形象的的介绍了Node，满足了读者想去了解Node的需求。作者是Node的第一批贡献者之一，德国前端大神。译者觉得作者的比喻很适合初学者理解Node，特此翻译。</p>
<p><strong>译者</strong> ：原文网址里有只小蚂蚁的效果很有意思(多次鼠标悬浮会有惊喜)，哈哈哈，可以去看一下哦。</p>
<ul>
<li>原文地址：<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="external">Understanding node.js</a></li>
<li>原文作者：<a href="http://felixge.de/" target="_blank" rel="external">Felix Geisendörfer</a></li>
<li>Node小应用：<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">Node-sample</a></li>
<li>译者：<a href="http://damonare.cn" target="_blank" rel="external">Damonare</a></li>
</ul>
<p><strong>本文属于译文</strong> </p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>当我向别人介绍<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 的时候一般会有两种反应，要么是立马就弄明白它是个什么玩意儿，要么是被它搞的很糊涂。</p>
<p>如果你现在还处于后者，下面就是我对于<code>node</code>的解释：</p>
<ul>
<li>它是一个命令行工具，你可以下载一个tarball文件，编译然后安装源文件；</li>
<li>它可以让你在你的终端输入<code>node my_app.js</code>来运行Javascript程序；</li>
<li>Node的JS代码是由 <a href="http://code.google.com/p/v8/" target="_blank" rel="external">V8 javascript 引擎</a>（就是那个使得Chrome如此之快的东西）所执行的；</li>
<li>Node提供了诸如访问网络或是操作文件系统的<code>Javascript API</code></li>
</ul>
<h4 id="“但我也可以用-Ruby-Python-Php-Java-…等语言来做我想要做的事啊”"><a href="#“但我也可以用-Ruby-Python-Php-Java-…等语言来做我想要做的事啊”" class="headerlink" title="“但我也可以用 Ruby, Python, Php,Java, …等语言来做我想要做的事啊”"></a>“但我也可以用 Ruby, Python, Php,Java, …等语言来做我想要做的事啊”</h4><p>我听到你说的话了，你是对的。<code>Node</code>不是狡猾的独角兽，这点很抱歉，它不会帮你做你该做的事。它仅仅是一个工具，而且他也不会替代你现在所常用的一些工具，至少现在不会。</p>
<h4 id="“说重点！！！”"><a href="#“说重点！！！”" class="headerlink" title="“说重点！！！”"></a>“说重点！！！”</h4><p>好的，我会的，当你需要同时做好几件事的时候<code>Node</code>会表现的十分优秀。你有写了一段代码然后对他说”我想你可以并行运行！”的体验吗？哈哈哈，在Node中除了你的代码所有的东西都是并行运行的。</p>
<h4 id="“啊？！”"><a href="#“啊？！”" class="headerlink" title="“啊？！”"></a>“啊？！”</h4><p>是的，没错，除了你的代码之外所有的代码都是并行运行的。为了理解这一点，你可以把你自己的代码想象成一个国王，而<code>Node</code>就是他的仆人军队。</p>
<p>新的一天是这样开始的：某个仆人叫醒了国王，然后问他是否需要什么。国王给了这个仆人一个任务清单然后就回去继续睡觉了。然后这个仆人就把任务清单上的任务分发下去，仆人们开始工作了。</p>
<p>当一个仆人完成了他的任务的时候，他就跑到国王寝宫外面排队等候报告。国王一次只能听取一个仆人报告任务，有的时候国王会在仆人报告结束的时候给他更多的任务。(看你代码咋写咯)</p>
<p>生活是美好的，因为国王的诸多仆人同时执行多个任务，但报告结果的时候是一个一个来的，所以国王能够很专注。</p>
<h4 id="“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”"><a href="#“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”" class="headerlink" title="“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”"></a>“那确实很美好，但你能结束这个愚蠢的比喻用更加geek的方式来告诉我吗？”</h4><p>好的，一个<code>node</code>程序或许是下面这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line">  , sys = <span class="built_in">require</span>(<span class="string">'sys'</span>);</div><div class="line"><span class="comment">//译者注：sys is deprecated. Use util instead.这里我们直接用console.log即可</span></div><div class="line">fs.readFile(<span class="string">'treasure-chamber-report.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">report</span>) </span>&#123;</div><div class="line">  <span class="comment">//sys.puts("oh, look at all my money: "+report);</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"oh, look at all my money: "</span>+report)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">fs.writeFile(<span class="string">'letter-to-princess.txt'</span>, <span class="string">'...'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//sys.puts("can't wait to hear back from her!");</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"can't wait to hear back from her!"</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你的代码(国王)给了<code>node</code>(仆人)两个任务即读(readFile)和写(writeFile)文件，然后就去睡大觉了。一旦node完成了某个任务，跟这个任务对应的回调就会触发。但同一时间只能有一个回调被触发，在那个回调执行完成之前，所有其它的回调都得排队等待。进一步说，回调触发的顺序是不能被保证的。</p>
<h4 id="“所以我不必担心代码在同一时间访问同一个数据结构？”"><a href="#“所以我不必担心代码在同一时间访问同一个数据结构？”" class="headerlink" title="“所以我不必担心代码在同一时间访问同一个数据结构？”"></a>“所以我不必担心代码在同一时间访问同一个数据结构？”</h4><p>你确实理解了，这就是JavaScript的单进程/事件循环设计美丽的地方。</p>
<h4 id="“好棒，但我为什么应该用它呢？”"><a href="#“好棒，但我为什么应该用它呢？”" class="headerlink" title="“好棒，但我为什么应该用它呢？”"></a>“好棒，但我为什么应该用它呢？”</h4><p>一个原因是效率。在一个web应用中，响应时间主要是花在了执行数据库查询上面，而用<code>node</code>,你可以一次性执行所有的数据库查询。将响应时间减少到了执行最慢的数据库查询所用的时间。</p>
<p>另一个原因是<code>Javascript</code>。你可以使用<code>Node</code>让你的浏览器和后端共享代码。Javascript也在渐渐成为一门真正的通用语言。不管你在过去是用Python, Ruby, Java, PHP, …等等，你都或多或少的使用过Javasctipt，对吗？</p>
<p>最后一个原因是原生速度。V8正在不断的推进作为地球上最快的动态语言编译器之一的边界，我也想不到有任何其它的语言在速度上能够像Javascript一样不断的高歌猛进。再进一步说，<code>node</code>的I/O设备真的十分的轻量，能够让你尽可能最大程度的利用系统的I/O容量。</p>
<h4 id="“所以你是说从现在开始我应该用Node写我所有的应用么？”"><a href="#“所以你是说从现在开始我应该用Node写我所有的应用么？”" class="headerlink" title="“所以你是说从现在开始我应该用Node写我所有的应用么？”"></a>“所以你是说从现在开始我应该用Node写我所有的应用么？”</h4><p>是也不是，一旦你开始舞弄<code>node</code>这柄锤子，所有的东西都会开始变得像钉子。但如果你当前的工作有一个deadline，你可以参考下面的几点来做决定用不用<code>node</code>:</p>
<ul>
<li>低响应时间/高并发是否重要？Node真的很擅长处理这俩问题；</li>
<li>项目有多大？小项目没问题，如果是大项目就应该认真评估了(可用的库，修复一个bug所需的资源或者two upstream等等)</li>
</ul>
<h4 id="“我能在Node中访问DOM吗？”"><a href="#“我能在Node中访问DOM吗？”" class="headerlink" title="“我能在Node中访问DOM吗？”"></a>“我能在Node中访问DOM吗？”</h4><p>这是一个好问题！答案是不行，DOM是浏览器的东西吗，不过幸好node的JS引擎（V8）跟那些混乱的东西是完全分离的。不过，有人在以node模块的形式来实现DOM，或许带来令人兴奋的可能性比如对客户端代码进行单元测试。(译者注：现在已经有人实现了这个模块，详情查看<a href="https://www.npmjs.com/package/node-dom" target="_blank" rel="external">Node-dom</a>)。</p>
<h4 id="“难道事件驱动编程真的很难吗？”"><a href="#“难道事件驱动编程真的很难吗？”" class="headerlink" title="“难道事件驱动编程真的很难吗？”"></a>“难道事件驱动编程真的很难吗？”</h4><p>这取决于你自己，如果你已经学会了如何在浏览器里调用Ajax或是调用某个事件，那么学习node对你不会是什么难题。</p>
<p>同时，测试驱动开发能够真正的帮助你从做一个可维护的设计开始学习node。</p>
<h4 id="“我应该从哪里学到更多？”"><a href="#“我应该从哪里学到更多？”" class="headerlink" title="“我应该从哪里学到更多？”"></a>“我应该从哪里学到更多？”</h4><p>Tim Caswell正在运作优秀的<a href="http://howtonode.org/" target="_blank" rel="external">How To Node</a>博客。在twitter上Follow <a href="https://twitter.com/search?q=node.js&amp;src=typd" target="_blank" rel="external">nodejs</a>。订阅<a href="http://groups.google.com/group/nodejs" target="_blank" rel="external">邮件列表</a>。(译者注：也可以结合<a href="http://nodejs.cn/api/" target="_blank" rel="external">Node.js 6.9.5 文档</a>进行学习，另外，译者写了一个node的小应用<a href="https://github.com/damonare/node-sample" target="_blank" rel="external">node-sample</a>可以clone下来看下)</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本篇文章的比如讲真是有些简单了，但从现实事物中找到真正相对应的也是在太难。，另外，由于时间原因，本文一些不妥之处或是当时还处在实验性阶段的东西译者或删或改。能力有限，水平一般，翻译不妥之处，还望指正。感谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：这篇文章十分生动形象的的介绍了Node，满足了读者想去了解Node的需求。作者是Node的第一批贡献者之一，德国前端大神。译者觉得作者的比喻很适合初学者理解Node，特此翻译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt; ：原文网址里有只小蚂蚁的效果很有意思(多次鼠标悬浮会有惊喜)，哈哈哈，可以去看一下哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb&quot;&gt;Understanding node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://felixge.de/&quot;&gt;Felix Geisendörfer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node小应用：&lt;a href=&quot;https://github.com/damonare/node-sample&quot;&gt;Node-sample&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本文属于译文&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="译文" scheme="http://damonare.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Node.js" scheme="http://damonare.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript闭包入门(译文)</title>
    <link href="http://damonare.github.io/2017/01/20/Javascript%E9%97%AD%E5%8C%85%E5%85%A5%E9%97%A8(%E8%AF%91%E6%96%87)/"/>
    <id>http://damonare.github.io/2017/01/20/Javascript闭包入门(译文)/</id>
    <published>2017-01-20T13:32:20.200Z</published>
    <updated>2017-01-21T10:01:28.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括</strong> ：这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。</p>
<p><strong>译者</strong> ：文章写在2006年，可直到翻译的21小时之前作者还在完善这篇文章，在Stackoverflow的<a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="external">How do JavaScript closures work?</a>这个问题里更是得到了4000+的赞同，文章内容质量自然不必多说。</p>
<ul>
<li>原文地址：<a href="http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies" target="_blank" rel="external">JavaScript Closures for Beginners</a></li>
<li>原文作者：Morris </li>
<li>译者：Damonare</li>
<li>译者博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>本文属于译文</strong> </p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="闭包并不是魔法"><a href="#闭包并不是魔法" class="headerlink" title="闭包并不是魔法"></a>闭包并不是魔法</h3><p>这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。</p>
<p>实际上一旦你对闭包的核心概念心领神会了，闭包就不难理解了，但如果你想通过读那些学术性文章或是学院派的论文来理解闭包那基本是不可能的。</p>
<p>本文主要是面向那些有主流程序语言开发经验或是能看懂下面这段代码的程序员：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name;</div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">  say();</div><div class="line">&#125;</div><div class="line">sayHello(<span class="string">'Joe'</span>);</div></pre></td></tr></table></figure>
<h3 id="一个闭包小案例"><a href="#一个闭包小案例" class="headerlink" title="一个闭包小案例"></a>一个闭包小案例</h3><p><strong>两种方式概括：</strong></p>
<ul>
<li>闭包是javascript支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="external">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</li>
</ul>
<p>或是</p>
<ul>
<li>闭包是函数开始执行的时候被分配的一个<a href="http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_" target="_blank" rel="external">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</li>
</ul>
<p>下面这段代码返回了一个指向这个函数的引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> text = <span class="string">'Hello '</span> + name; <span class="comment">// 局部变量text</span></div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125;</div><div class="line">  <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">'Bob'</span>);</div><div class="line">say2(); <span class="comment">// 打印日志： "Hello Bob"</span></div></pre></td></tr></table></figure>
<p>绝大部分Javascript程序员能够理解上面代码中的一个函数引用是如何返回赋值给变量<code>say2</code>的，如果你不理解，那么你需要理解之后再来学习闭包。C语言程序员会认为这个函数返回一个指向某函数的指针，变量<code>say</code>和<code>say2</code>都是指向某个函数的指针。</p>
<p>Javascript的函数引用和C语言指针相比还有一个关键性的不同之处，在Javascript中，一个引用函数的变量可以看做是有两个指针，一个是指向函数的指针，一个是指向闭包的隐藏指针。</p>
<p>上面代码中就有一个闭包，为什么呢？因为匿名函数<code>function() { console.log(text); }</code>是在另一个函数(在本例中就是<code>sayHello2()</code>函数)声明的。在Javascript中，如果你在另一个函数中使用了<code>function</code>关键字，那么你就创建了一个闭包。</p>
<p>在C语言和大多数常用程序语言中，当一个函数返回后，函数内声明的局部变量就不能再被访问了，因为该函数对应的栈帧已经被销毁了。</p>
<p>在Javscript中，如果你在一个函数中声明了另一个函数，那么在你调用这个函数返回后里面的局部变量仍然是可以访问的。这个已经在上面的代码中演示过了，即我们在函数<code>sayHello()</code>返回后仍然可以调用函数<code>say2()</code>。<strong>注意：我们在代码中引用的变量<code>text</code>是我们在函数<code>sayHello2()</code>中声明的局部变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(text); &#125; <span class="comment">// 输出say2.toString();</span></div></pre></td></tr></table></figure>
<p>观察<code>say2.toString()</code>的输出，我们可以看到确实引用了<code>text</code>变量。匿名函数之所以可以引用包含<code>&#39;Hello Bob&#39;</code>的<code>text</code>变量就是因为<code>sayhello2()</code>的局部变量被保存在了闭包中。</p>
<p>神奇的是，在JavaScript中，函数引用还有一个对于它所创建的闭包的秘密引用，类似于事件委托是一个方法指针加上对于某个对象的秘密引用。</p>
<h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><p>出于某种不得而知的原因，当你去阅读一些关于闭包的文章的时候，闭包看起来真的是难以理解的。但如果你看到一些你能够去操作的闭包小案例(这花费了我一段时间)，闭包就容易理解了。推荐好好推敲下这几个小案例直到你彻底理解了它们到底是如何工作的。如果你没完全弄明白闭包是如何工作的就去盲目使用闭包，会搞出很多神奇的bug的！</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>局部变量虽然没有被复制，但可以通过被引用而被保留下来。这就好像外部函数退出后，但栈帧依旧保存在内存中一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say667</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 局部变量num最后会保存在闭包中</span></div><div class="line">  <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">  <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">  num++;</div><div class="line">  <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayNumber = say667();</div><div class="line">sayNumber(); <span class="comment">// 输出 43</span></div></pre></td></tr></table></figure>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>下面三个全局函数对同一个闭包有一个共同的引用，因为他们都是在调用函数<code>setupSomeGlobals()</code>时声明的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gLogNumber, gIncreaseNumber, gSetNumber;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupSomeGlobals</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 局部变量num最后会保存在闭包中</span></div><div class="line">  <span class="keyword">var</span> num = <span class="number">42</span>;</div><div class="line">  <span class="comment">// 将一些对于函数的引用存储为全局变量</span></div><div class="line">  gLogNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(num); &#125;</div><div class="line">  gIncreaseNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; num++; &#125;</div><div class="line">  gSetNumber = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; num = x; &#125;</div><div class="line">&#125;</div><div class="line">setupSomeGlobals();</div><div class="line">gIncreaseNumber();</div><div class="line">gLogNumber(); <span class="comment">// 43</span></div><div class="line">gSetNumber(<span class="number">5</span>);</div><div class="line">gLogNumber(); <span class="comment">// 5</span></div><div class="line"><span class="keyword">var</span> oldLog = gLogNumber;</div><div class="line">setupSomeGlobals();</div><div class="line">gLogNumber(); <span class="comment">// 42</span></div><div class="line">oldLog() <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>这三个函数具有对同一个闭包的共享访问权限——这个闭包是指当三个函数定义时<code>setupSomeGlobals()</code>的局部变量。</p>
<p><strong>注意：在上述示例中，当你再次调用<code>setupSomeGlobals()</code>时，一个新的闭包(栈帧)就被创建了。</strong>旧变量<code>gLogNumber</code>, <code>gIncreaseNumber</code>, <code>gSetNumber</code> 被有新闭包的函数覆盖(在JavaScript中，如果你在一个函数中声明了一个新的函数，那么当外部函数被调用时，内部函数会被重新创建)。</p>
<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p> 这个示例对于很多人来说都是一个挑战，所以希望你能弄懂它。<strong>注意：当你在一个循环里面定义一个函数的时候，闭包里的局部变量可能不会像你想的那样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildList</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> item = <span class="string">'item'</span> + i;</div><div class="line">        result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(item + <span class="string">' '</span> + list[i])&#125; );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fnlist = buildList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line">    <span class="comment">// 使用j是为了防止搞混---可以使用i</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; fnlist.length; j++) &#123;</div><div class="line">        fnlist[j]();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> testList() <span class="comment">//输出 "item2 undefined" 3 次</span></div></pre></td></tr></table></figure>
<p><code>result.push( function() {console.log(item + &#39; &#39; + list[i])}</code>这一行给<code>result</code>数组添加了三次函数匿名引用。如果你不熟悉匿名函数可以想象成下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pointer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(item + <span class="string">' '</span> + list[i])&#125;;</div><div class="line">result.push(pointer);</div></pre></td></tr></table></figure>
<p>注意，当你运行上述代码的时候会打印<code>&quot;item2 undefined&quot;</code>三次！和前面的示例一样，和<code>buildList</code>的局部变量对应的闭包只有一个。当匿名函数在<code>fnlist[j]()</code>这一行调用的时候，他们使用同一个闭包，而且是使用的这个闭包里<code>i</code>和<code>item</code>现在的值(循环结束后<code>i</code>的值为3，<code>item</code>的值为<code>&#39;item2&#39;</code>)。<strong>注意：我们从索引<code>0</code>开始，所以<code>item</code>最后的值为<code>item2&#39;</code>，<code>i</code>的值会被<code>i++</code>增加到<code>3</code> 。</strong></p>
<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>这个例子表明了闭包会保存函数退出之前内部定义的所有的局部变量。<strong>注意：变量<code>alice</code>是在匿名函数之前创建的。</strong> 匿名函数先被声明，然后当它被调用的时候之所以能够访问<code>alice</code>是因为他们在同一个作用域内(JavaScript做了<a href="http://stackoverflow.com/questions/3725546/variable-hoisting/3725763#3725763" target="_blank" rel="external">变量提升</a>)，<code>sayAlice()()</code>直接调用了从<code>sayAlice()</code>中返回的函数引用——这个和前面的完全一样，只是少了临时的变量【译者注：存储sayAlice()返回的函数引用的变量】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAlice</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(alice); &#125;</div><div class="line">    <span class="comment">// 局部变量最后保存在闭包中</span></div><div class="line">    <span class="keyword">var</span> alice = <span class="string">'Hello Alice'</span>;</div><div class="line">    <span class="keyword">return</span> say;</div><div class="line">&#125;</div><div class="line">sayAlice()();<span class="comment">// 输出"Hello Alice"</span></div></pre></td></tr></table></figure>
<p><strong>技巧：需要注意变量<code>say</code>也是在闭包内部，也能被在<code>sayAlice()</code>内部声明的其它函数访问，或者也可以在函数内部递归访问它。</strong></p>
<h4 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h4><p>最后一个例子说明了每次调用函数都会为局部变量创建一个闭包。实际上每次函数声明并不会创建一个单独的闭包，但每次调用函数都会创建一个独立的闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newClosure</span>(<span class="params">someNum, someRef</span>) </span>&#123;</div><div class="line">    <span class="comment">// 局部变量最终保存在闭包中</span></div><div class="line">    <span class="keyword">var</span> num = someNum;</div><div class="line">    <span class="keyword">var</span> anArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="keyword">var</span> ref = someRef;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        num += x;</div><div class="line">        anArray.push(num);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'num: '</span> + num +</div><div class="line">            <span class="string">'\nanArray '</span> + anArray.toString() +</div><div class="line">            <span class="string">'\nref.someVar '</span> + ref.someVar);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">obj = &#123;someVar: <span class="number">4</span>&#125;;</div><div class="line">fn1 = newClosure(<span class="number">4</span>, obj);</div><div class="line">fn2 = newClosure(<span class="number">5</span>, obj);</div><div class="line">fn1(<span class="number">1</span>); <span class="comment">// num: 5; anArray: 1,2,3,5; ref.someVar: 4;</span></div><div class="line">fn2(<span class="number">1</span>); <span class="comment">// num: 6; anArray: 1,2,3,6; ref.someVar: 4;</span></div><div class="line">obj.someVar++;</div><div class="line">fn1(<span class="number">2</span>); <span class="comment">// num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;</span></div><div class="line">fn2(<span class="number">2</span>); <span class="comment">// num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;</span></div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果任何不太明白的地方最好的方式就是把玩这几个例子，去机械地阅读一些文章远比去做这些实例难得多。我关于闭包的说明、栈框体(stack-frame)的说明等等，严格理论上讲并不是完全正确的——它们只是为了理解而简化处理过的。当基础的概念心领神会之后，就可以轻松地理解这些细节了。</p>
<h3 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h3><ul>
<li>每当你在另一个函数里使用了关键字<code>function</code>，一个闭包就被创建了</li>
<li>每当你在一个函数内部使用了<code>eval()</code>，一个闭包就被创建了。在<code>eval</code>内部你可以引用外部函数定义的局部变量，同样的，在<code>eval</code>内部也可以通过<code>eval(&#39;var foo = …&#39;)</code>来创建新的局部变量。</li>
<li>当你在一个函数内部使用<code>new function(...)</code>(即<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">构造函数</a>)时，它不会创建闭包(新函数不能引用外部函数的局部变量）。</li>
<li>JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。</li>
<li>也许最好的理解是闭包总是在进入某个函数的时候被创建，而局部变量是被加入到这个闭包中。</li>
<li>闭包函数每次被调用的时候都会创建一组新的局部变量存储。(前提是这个函数包含一个内部的函数声明，并且这个函数的引用被返回或者用某种方法被存储到一个外部的引用中)</li>
<li>两个函数或许从源代码文本上看起来一样，但因为隐藏闭包的存在会让两个函数具有不同的行为。我认为Javascript代码实际上并不能找出一个函数引用是否有闭包。</li>
<li>如果你正尝试做一些动态源代码的修改(例如：<code>myFunction = Function(myFunction.toString().replace(/Hello/,&#39;Hola&#39;));</code>)，如果<code>myFunction</code>是一个闭包的话，那么这并不会生效(当然，你甚至可能从来都没有在运行的时候考虑过修改源代码字符串，但是。。。)。</li>
<li>在函数内部的函数的内部声明函数是可以的——可以获得不止一个层级的闭包。</li>
<li>通常我认为闭包是一个同时包含函数和被捕捉的变量的术语，但是请注意我并没有在本文中使用这个定义。</li>
<li>我觉得JavaScript中的闭包跟其它函数式编程语言中的闭包是有不同之处的。</li>
</ul>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>如果你正好在学习闭包(在这里或是其他地方)，期待您对本文的任何反馈，您的任何建议都可能会使本文更加清晰易懂。请联系<a href="mailto:jztan1996@gmail.com" target="_blank" rel="external">jztan1996@gmail.com 【译者注：这是译者的邮箱，欢迎交流学习】</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是译者翻译的第一篇文章，收获良多，感觉上并不比自己写一篇文章省事，相反熟悉内容了解代码的同时还得去揣摩作者表达的意图，难度的确要比自己单独写一篇高。能力有限，水平一般，有翻译不到位的地方，欢迎批评指正。感谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括&lt;/strong&gt; ：这篇文章使用有效的javascript代码向程序员们解释了闭包，大牛和功能型程序员请自行忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt; ：文章写在2006年，可直到翻译的21小时之前作者还在完善这篇文章，在Stackoverflow的&lt;a href=&quot;http://stackoverflow.com/questions/111102/how-do-javascript-closures-work&quot;&gt;How do JavaScript closures work?&lt;/a&gt;这个问题里更是得到了4000+的赞同，文章内容质量自然不必多说。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;JavaScript Closures for Beginners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：Morris &lt;/li&gt;
&lt;li&gt;译者：Damonare&lt;/li&gt;
&lt;li&gt;译者博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本文属于译文&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="译文" scheme="http://damonare.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Ajax入门</title>
    <link href="http://damonare.github.io/2017/01/18/Ajax%E5%85%A5%E9%97%A8/"/>
    <id>http://damonare.github.io/2017/01/18/Ajax入门/</id>
    <published>2017-01-18T06:29:40.316Z</published>
    <updated>2017-01-20T13:21:18.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了ajax的历史，工作原理以及优缺点，对XMLHttpRequest对象进行了详细的讲解，并使用原生js实现了一个ajax对象以方便日常开始使用。</p>
<ul>
<li><p>damonare的ajax库：<a href="https://github.com/damonare/ajax/tree/master" target="_blank" rel="external">damonare的ajax库</a></p>
</li>
<li><p>原文博客地址：<a href="https://damonare.github.io/2017/01/18/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ajax%E5%90%97%EF%BC%9F/#more">你真的懂ajax吗？</a></p>
</li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>相信每个前端程序员日常工作中都避免不了的工作就是和后端联调，联调自然就避免不了使用<code>ajax</code>，但我相信，不管是使用jquery封装的<code>ajax</code>方法还是使用vue的插件<code>vue-resource</code>的程序员，真正对于<code>ajax</code>有过深入探究的并不多，我们更多的是为了使用而使用，至于它的原理往往因为即使不了解依旧能做出东西而懒得去看，我们都被轮子们惯坏了。根据<a href="https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99" target="_blank" rel="external">二八定律</a>，即任何一组东西中，最重要的只占其中一小部分，约20%，其余80%的尽管是多数，却是次要的。因 此，如果想挤进那20%的行列，就要学到一般人学不到的深度，学到一般人学不了的东西。</p>
<p>好的，现在我们从头来说一下<code>ajax</code>。</p>
<h3 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h3><p>在上世纪90年代，几乎所有的网站都由HTML页面实现，服务器处理每一个用户请求都需要重新加载网页。形式是怎样的呢？就比如说你在浏览器上登录自己的微博账号，填完了表单，点击登录按钮，一次”完整”的HTTP请求就此触发，服务器发现你的登录密码不对头，立马把网页原原本本的返回给你，在用户看来呢，就是一次重新加载的过程！用户体验极差！而且这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>到了2005年，google率先在它的应用(诸如google地图、gmail)里使用了<code>ajax</code>技术，这才让这项技术正式风靡开来。</p>
<p>如今它的应用已经十分广泛：</p>
<ul>
<li>运用<a href="https://zh.wikipedia.org/wiki/XHTML" target="_blank" rel="external">XHTML</a>+<a href="https://zh.wikipedia.org/wiki/CSS" target="_blank" rel="external">CSS</a>来表达信息；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a>操作<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%89%A9%E4%BB%B6%E6%A8%A1%E5%9E%8B" target="_blank" rel="external">DOM</a>（Document Object Model）来运行动态效果；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="external">XML</a>和<a href="https://zh.wikipedia.org/wiki/XSLT" target="_blank" rel="external">XSLT</a>操作数据；</li>
<li>运用<a href="https://zh.wikipedia.org/wiki/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>或新的Fetch API与<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="external">网页服务器</a>进行异步数据交换；</li>
<li>注意：AJAX与<a href="https://zh.wikipedia.org/wiki/Flash" target="_blank" rel="external">Flash</a>、<a href="https://zh.wikipedia.org/wiki/Silverlight" target="_blank" rel="external">Silverlight</a>和<a href="https://zh.wikipedia.org/wiki/Java_Applet" target="_blank" rel="external">Java Applet</a>等<a href="https://zh.wikipedia.org/wiki/RIA" target="_blank" rel="external">RIA</a>技术是有区分的。</li>
</ul>
<h3 id="Ajax工作原理"><a href="#Ajax工作原理" class="headerlink" title="Ajax工作原理"></a>Ajax工作原理</h3><p> Ajax的工作原理相当于在用户和服务器之间加了一个中间层(ajax引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。把这些交给了Ajax引擎，用户操作起来也就感觉更加流畅了。</p>
<h3 id="Ajax优缺点"><a href="#Ajax优缺点" class="headerlink" title="Ajax优缺点"></a>Ajax优缺点</h3><h4 id="Ajax的优点"><a href="#Ajax的优点" class="headerlink" title="Ajax的优点"></a>Ajax的优点</h4><ol>
<li>无刷新更新数据。</li>
</ol>
<p>AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。</p>
<ol>
<li>异步与服务器通信。</li>
</ol>
<p>AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。</p>
<ol>
<li>前端和后端负载平衡。</li>
</ol>
<p>AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。</p>
<ol>
<li>基于标准被广泛支持。</li>
</ol>
<p>AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。</p>
<ol>
<li>界面与应用分离。</li>
</ol>
<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。</p>
<h4 id="Ajax缺点"><a href="#Ajax缺点" class="headerlink" title="Ajax缺点"></a>Ajax缺点</h4><ol>
<li>AjAX干掉了Back和加入收藏书签功能，即对浏览器机制的破坏。</li>
</ol>
<blockquote>
<p> 对应用Ajax最主要的批评就是，它可能破坏浏览器的后退与加入收藏书签功能。在动态更新页面的情况下，用户无法回到前一个页面状态，这是因为浏览器仅能记下历史记录中的<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2&amp;action=edit&amp;redlink=1" target="_blank" rel="external">静态页面</a>。一个被完整读入的页面与一个已经被动态修改过的页面之间的可能差别非常微妙；用户通常都希望单击后退按钮，就能够取消他们的前一次操作，但是在Ajax应用程序中，却无法这样做。不过开发者已想出了种种办法来解决这个问题，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a> 之前的方法大多是在用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的<a href="https://zh.wikipedia.org/w/index.php?title=IFRAME&amp;action=edit&amp;redlink=1" target="_blank" rel="external">IFRAME</a>中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态）。</p>
<p>关于无法将状态加入收藏或书签的问题，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a>之前的一种方式是使用<a href="https://zh.wikipedia.org/wiki/URL" target="_blank" rel="external">URL</a>片断标识符（通常被称为<a href="https://zh.wikipedia.org/wiki/%E9%94%9A%E7%82%B9" target="_blank" rel="external">锚点</a>，即URL中#后面的部分）来保持追踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="external">HTML5</a> 以后可以直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留。上述两个方法也可以同时解决无法后退的问题。</p>
</blockquote>
<ol>
<li>AJAX的安全问题。</li>
</ol>
<p>AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。</p>
<ol>
<li>因为网络延迟需要给用户提供必要提示</li>
</ol>
<p>进行Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。如果不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到厌烦。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。</p>
<h3 id="XMLhttpRequest介绍"><a href="#XMLhttpRequest介绍" class="headerlink" title="XMLhttpRequest介绍"></a>XMLhttpRequest介绍</h3><p>Ajax(Asynchronous  JavaScript  and  XML)不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由<a href="https://zh.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON</a>代替，进一步减少数据量，形成所谓的AJAJ。为了使用JavaScript向服务器发出 <a href="https://developer.mozilla.org/en/HTTP" target="_blank" rel="external">HTTP</a> 请求，需要一个提供此功能的类的实例。这就是XMLHttpRequest的由来。这样的类最初是在Internet Explorer中作为一个名为XMLHTTP的ActiveX对象引入的。然后，Mozilla，Safari和其他浏览器，实现一个XMLHttpRequest类，支持Microsoft的原始ActiveX对象的方法和属性。同时微软也实现了XMLHttpRequest。</p>
<p>显而易见XMLHttpRequest类是重中之重了。</p>
<h4 id="XMLhttpRequest属性"><a href="#XMLhttpRequest属性" class="headerlink" title="XMLhttpRequest属性"></a>XMLhttpRequest属性</h4><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>一个JavaScript函数对象，当readyState属性改变时会调用它。回调函数会在user interface线程中调用。</p>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</p>
<p>5 个状态中每一个都有一个相关联的非正式的名称，下表列出了状态、名称和含义：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Uninitialized</td>
<td>初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</td>
</tr>
<tr>
<td>1</td>
<td>Open</td>
<td>open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。</td>
</tr>
<tr>
<td>2</td>
<td>Sent</td>
<td>Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</td>
</tr>
<tr>
<td>3</td>
<td>Receiving</td>
<td>所有响应头部都已经接收到。响应体开始接收但未完成。</td>
</tr>
<tr>
<td>4</td>
<td>Loaded</td>
<td>HTTP 响应已经完全接收。</td>
</tr>
</tbody>
</table>
<p>readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了 abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 onreadystatechange 事件句柄。</p>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><p>目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。</p>
<p>如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。</p>
<p>如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。</p>
<h5 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h5><p>对请求的响应，解析为 XML 并作为 Document 对象返回。</p>
<h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。</p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p>这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status 属性一样，当 readyState 小于 3 的时候读取这一属性会导致一个异常。</p>
<h4 id="XMLHttpRequest方法"><a href="#XMLHttpRequest方法" class="headerlink" title="XMLHttpRequest方法"></a>XMLHttpRequest方法</h4><h5 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h5><p>取消当前响应，关闭连接并且结束任何未决的网络活动。</p>
<p>这个方法把 XMLHttpRequest 对象重置为 readyState 为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h5><p>把 HTTP 响应头部作为未解析的字符串返回。</p>
<p>如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “\r\n” 隔开。</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h5><p>返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。</p>
<p>该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p>
<h5 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h5><p>初始化一个请求. 该方法用于JavaScript代码中;如果是本地代码, 使用 <a href="https://developer.mozilla.org/zh-cn/nsIXMLHttpRequest#openRequest(" target="_blank" rel="external"><code>openRequest()</code></a>)方法代替.</p>
<blockquote>
<p> <strong>注意:</strong> 在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort（）方法。</p>
</blockquote>
<p>参数</p>
<ul>
<li><p><code>method</code></p>
<p>请求所使用的HTTP方法; 例如 “GET”, “POST”, “PUT”, “DELETE”等. 如果下个参数是非HTTP(S)的URL,则忽略该参数.</p>
</li>
<li><p><code>url</code></p>
<p>该请求所要访问的URL</p>
</li>
<li><p><code>async</code></p>
<p>一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。</p>
</li>
<li><p><code>user</code></p>
<p>用户名,可选参数,为授权使用;默认参数为空string.</p>
</li>
<li><p><code>password</code></p>
<p>密码,可选参数,为授权使用;默认参数为空string.</p>
</li>
</ul>
<h5 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h5><p>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。</p>
<h5 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h5><p>向一个打开但未发送的请求设置或添加一个 HTTP 请求(设置请求头)。</p>
<p>参数</p>
<ul>
<li><p><code>header</code></p>
<p>将要被赋值的请求头名称</p>
</li>
<li><p><code>value</code></p>
<p>给指定的请求头赋的值</p>
</li>
</ul>
<h3 id="Ajax原生js实现"><a href="#Ajax原生js实现" class="headerlink" title="Ajax原生js实现"></a>Ajax原生js实现</h3><p>下面是使用原生js写的ajax：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = &#123;&#125;;</div><div class="line">ajax.httpRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//判断是否支持XMLHttpRequest对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//兼容IE浏览器</span></div><div class="line">    <span class="keyword">var</span> versions = [</div><div class="line">        <span class="string">"MSXML2.XmlHttp.6.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.5.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.4.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.3.0"</span>,</div><div class="line">        <span class="string">"MSXML2.XmlHttp.2.0"</span>,</div><div class="line">        <span class="string">"Microsoft.XmlHttp"</span></div><div class="line">    ];</div><div class="line">	<span class="comment">//定义局部变量xhr,储存IE浏览器的ActiveXObject对象</span></div><div class="line">    <span class="keyword">var</span> xhr;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; versions.length; i++) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> xhr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ajax.send = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback, method, data, async</span>) </span>&#123;</div><div class="line">    <span class="comment">//默认异步</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">async</span> === <span class="literal">undefined</span>) &#123;</div><div class="line">        <span class="keyword">async</span> = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> httpRequest = ajax.httpRequest();</div><div class="line">    <span class="comment">//初始化HTTP请求</span></div><div class="line">    httpRequest.open(method, url, <span class="keyword">async</span>);</div><div class="line">    <span class="comment">//onreadystatechange函数对象</span></div><div class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//readyState 的值等于4，从服务器拿到了数据</span></div><div class="line">        <span class="keyword">if</span> (httpRequest.readyState == <span class="number">4</span>) &#123;</div><div class="line">            <span class="comment">//回调服务器响应数据</span></div><div class="line">            callback(httpRequest.responseText)</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (method == <span class="string">'POST'</span>) &#123;</div><div class="line">      	<span class="comment">//给指定的HTTP请求头赋值</span></div><div class="line">        httpRequest.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//发送HTTP请求</span></div><div class="line">    httpRequest.send(data);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//实现GET请求</span></div><div class="line">ajax.get = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> query = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</div><div class="line">    &#125;</div><div class="line">    ajax.send(url + (query.length ? <span class="string">'?'</span> + query.join(<span class="string">'&amp;'</span>) : <span class="string">''</span>), callback, <span class="string">'GET'</span>, <span class="literal">null</span>, <span class="keyword">async</span>)</div><div class="line">&#125;;</div><div class="line"><span class="comment">//实现POST请求</span></div><div class="line">ajax.post = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, callback, async</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> query = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">        query.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</div><div class="line">    &#125;</div><div class="line">    ajax.send(url, callback, <span class="string">'POST'</span>, query.join(<span class="string">'&amp;'</span>), <span class="keyword">async</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果你使用jquery或是zepto很大部分是因为它的ajax兼容性高的缘故，不妨试试这个：<a href="https://github.com/damonare/ajax/tree/master" target="_blank" rel="external">damonare的ajax库</a>，喜欢给个star也是可以的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>ajax技术对于整个web应用意义都是非凡的，仅以此篇致敬那些曾经奋斗在一线为了ajax技术的实现和普及做出工作的前辈们。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.cnblogs.com/SanMaoSpace/archive/2013/06/15/3137180.html" target="_blank" rel="external">Ajax工作原理记优缺点</a></li>
<li><a href="https://zh.wikipedia.org/wiki/AJAX" target="_blank" rel="external">Ajax</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了ajax的历史，工作原理以及优缺点，对XMLHttpRequest对象进行了详细的讲解，并使用原生js实现了一个ajax对象以方便日常开始使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;damonare的ajax库：&lt;a href=&quot;https://github.com/damonare/ajax/tree/master&quot;&gt;damonare的ajax库&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;https://damonare.github.io/2017/01/18/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82ajax%E5%90%97%EF%BC%9F/#more&quot;&gt;你真的懂ajax吗？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(四)——树</title>
    <link href="http://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
    <id>http://damonare.github.io/2017/01/14/学习javascript数据结构（四）——树/</id>
    <published>2017-01-14T05:22:28.299Z</published>
    <updated>2017-01-16T13:41:31.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了数据结构中的[树]的概念，尽可能通俗易懂的解释树这种数据结构的概念，使用javascript实现了树，如有纰漏，欢迎批评指正。</p>
<ul>
<li>原文博客地址：<a href="https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more">学习javascript数据结构(四)——树</a></li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人之所能，不能兼备，弃其所短，取其所长。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="树简介"><a href="#树简介" class="headerlink" title="树简介"></a>树简介</h3><p>在上一篇<a href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more">学习javascript数据结构(三)——集合</a>中我们说了集合这种数据结构，在<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a>和<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a>说了栈和队列以及链表这类线性表数据结构。接下来这一篇说的是<code>树</code>这种数据结构。首先想让大家明白的是数据结构是个什么玩意儿，数据结构可以分为数据的逻辑结构和数据的物理结构，所谓的数据逻辑结构在我理解就是计算机对于数据的组织方式的研究。也就是说研究的是数据和数据之间的关系。而数据的物理结构是数据的逻辑结构在计算机中的具体实现，也就是说一种逻辑结构可能会有多种存储结构与之相对应。</p>
<p>那么我们这一篇所说的<code>树</code>就是一种数据逻辑结构，即研究的是数据和数据之间的关系。之前所说的<code>栈</code>、<code>队列</code>、<code>链表</code>都是一种线性结构，相信大家也能发现这种线性结构的数据关系有一个共同点，就是数据都是一对一的，而上一篇说到的集合这种数据结构，数据是散乱的，他们之间的关系就是隶属于同一个集合，如上一篇例子所说，这些小孩子都是同一个幼儿园的，但是这些小孩子之间的关系我们并不知道。线性表(栈、队列、链表)就是对这些小孩子关系的一种表达(一对一)。而集合也是对于这些小孩子关系的一种表达。和线性表不同的是，树这种数据结构是一对多的，也就是说他所描述的是某个小孩子和其它小孩子之间的关系。</p>
<p>树这种结构实际上我们平时也有见到，比如下图这种简单的思维导图：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/4e4a20a4462309f7b9c58b78720e0cf3d7cad635.jpg" alt="思维导图"></p>
<p>如下也是一棵树：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2009072216345191.jpg" alt="树"></p>
<p>关于树概念总结如下:</p>
<p> 1）树形结构是一对多的非线性结构。<br> 2）树形结构有树和二叉树两种，树的操作实现比较复杂，但树可以转换为二叉树进行处理。<br> 3）树的定义：树(Tree)是 n(n≥0)个相同类型的数据元素的有限集合。<br> 4）树中的数据元素叫节点(Node)。<br> 5）n=0 的树称为空树(Empty Tree)；<br> 6）对于 n＞0 的任意非空树 T 有：<br>     （1）有且仅有一个特殊的节点称为树的根(Root)节点，根没有前驱节点；<br>     （2）若n＞1，则除根节点外，其余节点被分成了m(m＞0)个互不相交的集合<br>           T1，T2，。。。，Tm，其中每一个集合Ti(1≤i≤m)本身又是一棵树。树T1，T2，。。。，Tm称为这棵树的子树(Subtree)。<br> 7）树的定义是递归的，用树来定义树。因此，树（以及二叉树）的许多算法都使用了递归。 </p>
<p>参看维基百科对于<code>树</code>的定义：</p>
<blockquote>
<p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" target="_blank" rel="external">抽象数据类型</a>（ADT）或是实作这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B" target="_blank" rel="external">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B" target="_blank" rel="external">有树状结构</a>性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88" target="_blank" rel="external">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
</blockquote>
<p>树的种类：</p>
<blockquote>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E6%A0%91" target="_blank" rel="external">自由树</a>；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">二叉树</a>：每个节点最多含有两个子树的树称为二叉树；<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">完全二叉树</a>：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="external">满二叉树</a>：所有叶节点都在最底层的完全二叉树；<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">平衡二叉树</a>（<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="external">AVL树</a>）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="external">排序二叉树</a>(二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)；</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91" target="_blank" rel="external">霍夫曼树</a>：<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84&amp;action=edit&amp;redlink=1" target="_blank" rel="external">带权路径</a>最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="external">B树</a>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li>
</ul>
</li>
</ul>
</blockquote>
<p>有关树的术语:</p>
<blockquote>
<ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的<strong>高度</strong>或<strong>深度</strong>：树中节点的最大层次；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
</blockquote>
<p>（我是维基百科搬运工，哈哈哈）</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p> <strong>二叉树</strong>（英语：Binary tree）是每个节点最多有两个子树的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84" target="_blank" rel="external">树结构</a>。通常子树被称作“左子树”（<em>left subtree</em>）和“右子树”（<em>right subtree</em>）。<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" target="_blank" rel="external">二叉树</a>常被用于实现<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="external">二叉查找树</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D" target="_blank" rel="external">二元堆积</a>。</p>
</blockquote>
<p>我们主要研究的就是二叉树，也就是数据为一对二的关系。那么在二叉树中又有些分类；</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2329205432280906653.jpg" alt="二叉树"></p>
<p>二叉树分类：</p>
<ul>
<li>一棵深度为k，且有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点称之为<strong>满二叉树</strong>；</li>
<li>深度为k，有n个节点的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" target="_blank" rel="external">二叉树</a>，当且仅当其每一个节点都与深度为k的<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&amp;action=edit&amp;redlink=1" target="_blank" rel="external">满二叉树</a>中，序号为1至n的节点对应时，称之为<strong>完全二叉树</strong>。</li>
<li>平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵<strong>平衡二叉树</strong>。</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>1）一棵二叉树由根结点、左子树和右子树三部分组成，<br>2） D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的<br>3） 遍历方式有6 种：DLR、DRL、LDR、LRD、RDL、RLD。先左或先右算法基本一样，所以就剩下三种DLR（先序或是前序）、LDR（中序）、LRD（后序）。</p>
<ul>
<li><strong>前序遍历</strong>：首先访问根节点，然后遍历左子树，最后遍历右子树，可记录为根—左—右；</li>
</ul>
<ul>
<li><strong>中序遍历</strong>：首先访问左子树，然后访问根节点，最后遍历右子树，可记录为左—根—右；</li>
</ul>
<ul>
<li><strong>后序遍历</strong>：首先遍历左子树，然后遍历右子树，最后遍历根节点，可记录为左—右—根。</li>
</ul>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/BINTREE2.jpg" alt="二叉树的遍历"></p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/2017-01-16_173441.png" alt="二叉树遍历"></p>
<p>以上图1为例解释前序遍历：</p>
<p>首先访问根节点<code>a</code>=&gt;然后遍历左子树<code>b</code>=&gt;左子树<code>b</code>的左子树<code>d</code>=&gt;<code>d</code>的右孩子<code>e</code>&gt;此时<code>b</code>的左子树遍历完，遍历<code>b</code>的右子树<code>f</code>=&gt;<code>f</code>的左孩子<code>g</code>=&gt;左子树<code>b</code>遍历完，遍历根节点的右孩子<code>c</code>，完成=&gt;<code>abdefgc</code></p>
<p>中序遍历，后序遍历就不多说了，不同的只是访问的顺序。</p>
<p>注意：</p>
<p>(1)已知前序、后序遍历结果，不能推导出一棵确定的树；</p>
<p>(2)已知前序、中序遍历结果，能够推导出后序遍历结果；</p>
<p>(3)已知后序、中序遍历结果，能够推导出前序遍历结果；</p>
<h3 id="二叉搜索树的创建"><a href="#二叉搜索树的创建" class="headerlink" title="二叉搜索树的创建"></a>二叉搜索树的创建</h3><p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<pre><code>（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值；

（2）若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值；

（3）它的左、右子树也分别为二叉查找树。
</code></pre><p>首先我们声明一个BinarySearchTree类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function BinarySearchTree() &#123;</div><div class="line">	var Node = function(key)&#123;</div><div class="line">        this.key = key;</div><div class="line">        this.left = null;</div><div class="line">        this.right = null;</div><div class="line">    &#125;;</div><div class="line">    var root=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/binary6.gif" alt="二叉树"></p>
<p>和链表一样，二叉树也通过指针来表示节点之间的关系。在双向链表中，每一个节点有两个指针，一个指向下一个节点，一个指向上一个节点。对于树，使用同样的方式，只不过一个指向左孩子，一个指向右孩子。现在我们给这棵树弄一些方法：</p>
<ul>
<li>insert(key):向树中插入一个新的键(节点);</li>
<li>search(key):在书中查找一个键，如果节点存在，返回true;如果不存在，返回false;</li>
<li>inOrdertraverse:通过中序遍历方式遍历所有节点；</li>
<li>preorderTraverse:通过先序遍历方式遍历所有的节点；</li>
<li>postOrdertraverse:通过后序遍历的方式遍历所有的节点；</li>
<li>min:返回树中的最小值；</li>
<li>max:返回树中的最大值；</li>
<li>remove(key):从树中移除某个键；</li>
</ul>
<p>BinarySearchTree类的完整代码（充分添加注释）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</div><div class="line"></div><div class="line">        <span class="comment">//判断是否是第一个节点，如果是作为根节点保存。不是调用inserNode方法</span></div><div class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>)&#123;</div><div class="line">            root = newNode;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            insertNode(root,newNode);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</div><div class="line">      <span class="comment">//判断两个节点的大小，根据二叉搜索树的特点左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值</span></div><div class="line">        <span class="keyword">if</span> (newNode.key &lt; node.key)&#123;</div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>)&#123;</div><div class="line">                node.left = newNode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                insertNode(node.left, newNode);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node.right = newNode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                insertNode(node.right, newNode);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getRoot = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> searchNode(root, key);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key &lt; node.key)&#123;</div><div class="line">            <span class="keyword">return</span> searchNode(node.left, key);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key)&#123;</div><div class="line">            <span class="keyword">return</span> searchNode(node.right, key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//element is equal to node.item</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        inOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            inOrderTraverseNode(node.left, callback);</div><div class="line">            callback(node.key);</div><div class="line">            inOrderTraverseNode(node.right, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        preOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            callback(node.key);</div><div class="line">            preOrderTraverseNode(node.left, callback);</div><div class="line">            preOrderTraverseNode(node.right, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">        postOrderTraverseNode(root, callback);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">            postOrderTraverseNode(node.left, callback);</div><div class="line">            postOrderTraverseNode(node.right, callback);</div><div class="line">            callback(node.key);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> minNode(root);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node)&#123;</div><div class="line">            <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</div><div class="line">                node = node.left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> node.key;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> maxNode(root);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node)&#123;</div><div class="line">            <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</div><div class="line">                node = node.right;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> node.key;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        root = removeNode(root, element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">        <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</div><div class="line">            node = node.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, element</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (element &lt; node.key)&#123;</div><div class="line">            node.left = removeNode(node.left, element);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; node.key)&#123;</div><div class="line">            node.right = removeNode(node.right, element);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="comment">//处理三种特殊情况</span></div><div class="line">            <span class="comment">//1 - 叶子节点</span></div><div class="line">            <span class="comment">//2 - 只有一个孩子的节点</span></div><div class="line">            <span class="comment">//3 - 有两个孩子的节点</span></div><div class="line">            <span class="comment">//case 1</span></div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node = <span class="literal">null</span>;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//case 2</span></div><div class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>)&#123;</div><div class="line">                node = node.right;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>)&#123;</div><div class="line">                node = node.left;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//case 3</span></div><div class="line">            <span class="keyword">var</span> aux = findMinNode(node.right);</div><div class="line">            node.key = aux.key;</div><div class="line">            node.right = removeNode(node.right, aux.key);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>树是一种比较常见的数据结构，不管是考试还是日常编码或是面试都是没法避免的一个知识点，此篇总结不甚完善，纰漏之处还望指出方便之后更改。敬请期待数据结构篇最后一篇文章：[学习javascript数据结构（五）——图]</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/树_(数据结构" target="_blank" rel="external">树（数据结构）</a>)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91#.E4.BA.8C.E5.8F.89.E6.A0.91.E7.9A.84.E7.B1.BB.E5.9E.8B" target="_blank" rel="external">二叉树</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了数据结构中的[树]的概念，尽可能通俗易懂的解释树这种数据结构的概念，使用javascript实现了树，如有纰漏，欢迎批评指正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more&quot;&gt;学习javascript数据结构(四)——树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人之所能，不能兼备，弃其所短，取其所长。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React全家桶实现一个简易备忘录</title>
    <link href="http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://damonare.github.io/2016/12/19/React全家桶实现简易备忘录/</id>
    <published>2016-12-19T09:34:38.262Z</published>
    <updated>2016-12-20T06:09:41.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。</p>
<ul>
<li><p>代码地址：<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现一个简易备忘录</a></p>
</li>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/#more">React全家桶实现一个简易备忘录</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生不失意，焉能暴己知。</strong></p>
<a id="more"></a>
<h3 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h3><blockquote>
<p>技术架构：本备忘录使用react+react-router+redux+less+ES6+webpack实现;</p>
<p>页面UI参照：<a href="http://www.todolist.cn/" target="_blank" rel="external">TodoList官网</a>实现;</p>
<p>在线演示地址：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a>;</p>
</blockquote>
<h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>支持回车添加新事项;</li>
<li>支持删除事项(点击X符号);</li>
<li>支持状态转换具体包括：<ul>
<li>新建事项-&gt;正在进行(点击checkbox选项)</li>
<li>正在进行-&gt;已完成(点击文字内容本身)</li>
<li>正在进行-&gt;新建事项(点击checkbox选项)</li>
<li>已完成-&gt;正在进行(点击文字本身)</li>
</ul>
</li>
<li>支持判断输入空字符，过长字符(20个汉字以内);</li>
<li>支持搜索;</li>
<li>支持本地化存储;</li>
<li>支持状态的展开隐藏(点击标题)</li>
<li>兼容手机端(iPhone6及以上)</li>
<li>支持路由切换</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-React浅谈"><a href="#1-React浅谈" class="headerlink" title="1. React浅谈"></a>1. React浅谈</h3><h4 id="1-1-组件化"><a href="#1-1-组件化" class="headerlink" title="1.1  组件化"></a>1.1  组件化</h4><p>​    毫无疑问，当谈到<code>React</code>的时候不能避免的会提到组件化思想。React刚开始想解决的问题只是UI这一层面的问题，也就是MVC中view层面的问题，不成想如今越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。对于<code>React</code>组件的理解同样要站在view层面的角度出发，一个完整的页面是由大大小小的组件堆叠而成，就好像搭积木，每一块积木都是一个组件，组件套组件组成了用户所能看到的完整的页面。</p>
<h4 id="1-2-JSX语法糖"><a href="#1-2-JSX语法糖" class="headerlink" title="1.2  JSX语法糖"></a>1.2  JSX语法糖</h4><p>​    使用<code>React</code>，不一定非要使用<code>JSX</code>语法，可以使用原生的JS进行开发。但是<code>React</code>作者强烈建议我们使用<code>JSX</code>，因为<code>JSX</code>在定义类似HTML这种树形结构时，十分的简单明了。这里简单的讲下<code>JSX</code>的由来。</p>
<p>​    比如，下面一个div元素，我们用HTML语法描述为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>   如果换做使用javascript描述这个元素呢？最好的方式可以简单的转化为<code>json</code>对象，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  type:"div",</div><div class="line">  props:&#123;</div><div class="line">    className:"test",</div><div class="line">    children:&#123;</div><div class="line">      type:"span",</div><div class="line">      props:&#123;</div><div class="line">        children:"Test"</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   这样我们就可以在javascript中创建一个<code>Virtual DOM</code>（虚拟DOM）了。当然，这样是没法复用的，我们再把它封装一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div=&gt;(&#123;text&#125;)&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type:<span class="string">"div"</span>,</div><div class="line">    props:&#123;</div><div class="line">      className:<span class="string">"test"</span>,</div><div class="line">      children:&#123;</div><div class="line">        type:<span class="string">"span"</span>,</div><div class="line">        props:&#123;</div><div class="line">          children: text,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  接下来再实现这个div就可以直接调用Div(‘Test’)来创建。但上述结构看起来实在让人不爽，写起来也很容易写混，一旦结构复杂了，很容易让人找不着北，于是<code>JSX</code>语法应运而生。我们用写HTML的方式写这段代码，再经过翻译器转换成javascript后交给浏览器执行。上述代码用<code>JSX</code>重写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Div =()=&gt;(</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"test"</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>多么简单明了！！！具体的<code>JSX语法</code>不多说了，学习更多戳这：<a href="http://reactjs.cn/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX in Depth</a></p>
<h4 id="1-3-Virtual-DOM"><a href="#1-3-Virtual-DOM" class="headerlink" title="1.3  Virtual DOM"></a>1.3  Virtual DOM</h4><p>   其实上面已经提到了<code>Virtual DOM</code>，它的存在也是<code>React</code>长久不衰的原因之一，虚拟DOM的概念并不是FB首创却在FB的手上大火了起来(后台是多么重要)。</p>
<p>  我们知道真实的页面对应了一个DOM树，在传统页面的开发模式中，每次需要更新页面时，都需要对DOM进行更新，DOM操作十分昂贵，为减少对于真实DOM的操作，诞生了<code>Virtual DOM</code>的概念，也就是用javascript把真实的DOM树描述了一遍，使用的也就是我们刚刚说过的<code>JSX</code>语法。对比如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/1444448853198657.jpg" alt="Virtual DOM原理"></p>
<p>   每次数据更新之后，重新计算<code>Virtual DOM</code>，并和上一次的<code>Virtual DOM</code>对比，对发生的变化进行批量更新。React也提供了<code>shouldComponentUpdate</code>生命周期回调，来减少数据变化后不必要的<code>Virtual DOM</code>对比过程，提升了性能。</p>
<p> <code>Virtual DOM</code>虽然渲染方式比传统的DOM操作要好一些，但并不明显，因为对比DOM节点也是需要计算的，最大的好处在于可以很方便的和其它平台集成，比如<code>react-native</code>就是基于<code>Virtual DOM</code>渲染出原生控件。具体渲染出的是<code>Web DOM</code>还是<code>Android</code>控件或是<code>iOS</code>控件就由平台决定了。所以我们说<code>react</code>的出现是一场革命，一次对于<code>native app</code>的宣战,就像<code>react-native</code>那句口号——<strong>Learn Once,Write Anywhere</strong>.</p>
<h4 id="1-4-函数式编程"><a href="#1-4-函数式编程" class="headerlink" title="1.4 函数式编程"></a>1.4 函数式编程</h4><p>​    过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。</p>
<p>​   而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=&gt;遍历旧数组=&gt;给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。</p>
<h4 id="1-5-数据流"><a href="#1-5-数据流" class="headerlink" title="1.5 数据流"></a>1.5 数据流</h4><p>  在React中，数据的流动是单向的，即从父节点传递到子节点。也因此组件是简单的，他们只需要从父组件获取props渲染即可。如果顶层的props改变了，React会递归的向下遍历整个组件树，重新渲染所有使用这个属性的组件。那么父组件如何获取子组件数据呢？很简单，通过回调就可以了，父组件定义某个方法供给子组件调用，子组件调用方法传递给父组件数据，Over。</p>
<h3 id="2-React-router"><a href="#2-React-router" class="headerlink" title="2. React-router"></a>2. React-router</h3><p>这东西我觉得没啥难度，官方例子都很不错，跟着官方例子来一遍基本就明白到底是个啥玩意了，官方例子：<a href="https://github.com/reactjs/react-router-tutorial/tree/master/lessons" target="_blank" rel="external"><strong>react-router-tutorial。</strong></a></p>
<p>完事以后可以再看一下阮一峰老师的教程，主要是对一些API的讲解：<a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">React Router 使用教程</a>。</p>
<p>还有啥不明白的欢迎评论留言共同探讨。</p>
<h3 id="3-Redux"><a href="#3-Redux" class="headerlink" title="3. Redux"></a>3. Redux</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。乱！</p>
<p>这时候<code>Redux</code>就强势登场了，现在你可以把<code>React</code>的model看作是一个个的子民，每一个子民都有自己的一个状态，纷纷扰扰，各自维护着自己状态，我行我素，那哪行啊！太乱了，我们需要一个King来领导大家，我们就可以把<code>Redux</code>看作是这个King。网罗所有的组件组成一个国家，掌控着一切子民的状态！防止有人叛乱生事！</p>
<p>这个时候就把组件分成了两种：容器组件(King或是路由)和展示组件(子民)。</p>
<ul>
<li>容器组件：即<code>redux</code>或是<code>router</code>,起到了维护状态，出发action的作用，其实就是King高高在上下达指令。</li>
<li>展示组件：不维护状态，所有的状态由容器组件通过<code>props</code>传给他，所有操作通过回调完成。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">展示组件</th>
<th style="text-align:center">容器组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">描述如何展现（骨架、样式）</td>
<td style="text-align:center">描述如何运行（数据获取、状态更新）</td>
</tr>
<tr>
<td style="text-align:center">直接使用 Redux</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">数据来源</td>
<td style="text-align:center">props</td>
<td style="text-align:center">监听 Redux state</td>
</tr>
<tr>
<td style="text-align:center">数据修改</td>
<td style="text-align:center">从 props 调用回调函数</td>
<td style="text-align:center">向 Redux 派发 actions</td>
</tr>
<tr>
<td style="text-align:center">调用方式</td>
<td style="text-align:center">手动</td>
<td style="text-align:center">通常由 React Redux 生成</td>
</tr>
</tbody>
</table>
<p>Redux三大部分：<code>store</code>,<code>action</code>,<code>reducer</code>。相当于King的直系下属。</p>
<p>那么也可以看出<code>Redux</code>只是一个状态管理方案，完全可以单独拿出来使用，这个King不仅仅可以是React的，去Angular，Ember那里也是可以做King的。在React中维系King和组件关系的库叫做<code>react-redux</code>。</p>
<p>， 它主要有提供两个东西：<code>Provider</code> 和<code>connect</code>，具体使用文后说明。</p>
<p>提供几个Redux的学习地址：<a href="http://cn.redux.js.org/index.html" target="_blank" rel="external">官方教程-中文版</a>，<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一）：基本用法</a></p>
<h4 id="3-2-Store"><a href="#3-2-Store" class="headerlink" title="3.2 Store"></a>3.2 Store</h4><p>Store 就是保存数据的地方，它实际上是一个<code>Object tree</code>。整个应用只能有一个 Store。这个Store可以看做是King的首相，掌控一切子民(组件)的活动(state)。</p>
<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">const</span> store = createStore(func);</div></pre></td></tr></table></figure>
<p>createStore接受一个函数作为参数，返回一个Store对象(首相诞生记)</p>
<p>我们来看一下Store(首相)的职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#getState" target="_blank" rel="external"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="http://cn.redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="external"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<h4 id="3-3-action"><a href="#3-3-action" class="headerlink" title="3.3 action"></a>3.3 action</h4><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。即store的数据变化来自于用户操作。action就是一个通知，它可以看作是首相下面的邮递员，通知子民(组件)改变状态。它是 store 数据的<strong>唯一</strong>来源。一般来说会通过 <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> action = &#123;</div><div class="line">  type: <span class="string">'ADD_TODO'</span>,</div><div class="line">  payload: <span class="string">'Learn Redux'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>Action创建函数</strong></p>
<p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    type: ADD_TODO,</div><div class="line">    text</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做将使 action 创建函数更容易被移植和测试。</p>
<h4 id="3-4-reducer"><a href="#3-4-reducer" class="headerlink" title="3.4 reducer"></a>3.4 reducer</h4><p><strong>Action</strong> 只是描述了<strong>有事情发生了</strong>这一事实，并没有指明应用如何更新 state。而这正是 reducer 要做的事情。也就是邮递员(action)只负责通知，具体你(组件)如何去做，他不负责，这事情只能是你们村长(reducer)告诉你如何去做才能符合社会主义核心价值观，如何做才能对建设共产主义社会有利。</p>
<p>专业解释: <strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</strong></p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">return</span> new_state;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="3-5-数据流"><a href="#3-5-数据流" class="headerlink" title="3.5 数据流"></a>3.5 数据流</h4><p><strong>严格的单向数据流</strong>是 Redux 架构的设计核心。</p>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ul>
<li><strong>调用</strong> <a href="http://cn.redux.js.org/docs/api/Store.html#dispatch" target="_blank" rel="external"><code>store.dispatch(action)</code></a>。</li>
<li><strong>Redux store 调用传入的 reducer 函数。</strong></li>
<li><strong>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</strong></li>
<li><strong>Redux store 保存了根 reducer 返回的完整 state 树</strong>。</li>
</ul>
<p>工作流程图如下：</p>
<p><img src="http://7xsssj.com2.z0.glb.qiniucdn.com/6b3fb1df3ad9c95354280a332065941a_thumb.png" alt="redux工作原理图"></p>
<h4 id="3-6-Connect"><a href="#3-6-Connect" class="headerlink" title="3.6 Connect"></a>3.6 Connect</h4><p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
<p>尽管如此，Redux 还是和 <a href="http://facebook.github.io/react/" target="_blank" rel="external">React</a> 和 <a href="https://github.com/dekujs/deku" target="_blank" rel="external">Deku</a> 这类框架搭配起来用最好，因为这类框架允许你以 state 函数的形式来描述界面，Redux 通过 action 的形式来发起 state 变化。</p>
<p>Redux 默认并不包含 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React 绑定库</a>，需要单独安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react-redux</div></pre></td></tr></table></figure>
<p>当然，我们这个实例里是不需要的，所有需要的依赖已经在package.json里配置好了。</p>
<p><code>React-Redux</code> 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">const</span> TodoList = connect()(Memos);</div></pre></td></tr></table></figure>
<p>上面代码中<code>Memos</code>是个UI组件，<code>TodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p>
<p>而只是纯粹的这样把Memos包裹起来毫无意义，完整的connect方法这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">const</span> TodoList = connect(</div><div class="line">  mapStateToProps</div><div class="line">)(Memos)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h4 id="3-7-Provider"><a href="#3-7-Provider" class="headerlink" title="3.7 Provider"></a>3.7 Provider</h4><p> 这个Provider 其实是一个中间件，它是为了解决让容器组件拿到King的指令(<code>state</code>对象)而存在的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></div><div class="line"><span class="keyword">let</span> store = createStore(todoApp);</div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p>
<h3 id="4-实战备忘录"><a href="#4-实战备忘录" class="headerlink" title="4.实战备忘录"></a>4.实战备忘录</h3><p>讲解之前可以先看一下github上的代码，你可以clone下来学习，也可以在线给我提issue，欢迎戳这:<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现简易备忘录</a></p>
<h4 id="4-1目录结构"><a href="#4-1目录结构" class="headerlink" title="4.1目录结构"></a>4.1目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── app                 #开发目录</div><div class="line">|   |   </div><div class="line">|   ├──actions          #action的文件</div><div class="line">|   |   </div><div class="line">|   ├──components       #展示组件</div><div class="line">|   |   </div><div class="line">|   ├──containers       #容器组件,主页</div><div class="line">|   |   </div><div class="line">|   ├──reducers         #reducer文件</div><div class="line">|   |</div><div class="line">|   |——routes		   #路由文件，容器组件</div><div class="line">|   |</div><div class="line">|   |——static           #静态文件</div><div class="line">|   |</div><div class="line">|   ├──stores           #store配置文件</div><div class="line">|   |</div><div class="line">|   |——main.less        #路由样式</div><div class="line">|   |</div><div class="line">|   └──main.js          #入口文件</div><div class="line">|      </div><div class="line">├── build                #发布目录</div><div class="line">├── node_modules        #包文件夹</div><div class="line">├── .gitignore     </div><div class="line">├── .jshintrc      </div><div class="line">├── webpack.production.config.js  #生产环境配置      </div><div class="line">├── webpack.config.js   #webpack配置文件</div><div class="line">├── package.json        #环境配置</div><div class="line">└── README.md		   #使用说明</div></pre></td></tr></table></figure>
<p>接下来，我们只关注app目录就好了。</p>
<h4 id="4-2入口文件"><a href="#4-2入口文件" class="headerlink" title="4.2入口文件"></a>4.2入口文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Route, IndexRoute, browserHistory, Router&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./container/App'</span>;</div><div class="line"><span class="keyword">import</span> AllMemosRoute <span class="keyword">from</span> <span class="string">'./routes/AllMemosRoute'</span>;</div><div class="line"><span class="keyword">import</span> TodoRoute <span class="keyword">from</span> <span class="string">'./routes/TodoRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoingRoute <span class="keyword">from</span> <span class="string">'./routes/DoingRoute'</span>;</div><div class="line"><span class="keyword">import</span> DoneRoute <span class="keyword">from</span> <span class="string">'./routes/DoneRoute'</span>;</div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./stores'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./main.less'</span>;</div><div class="line"><span class="keyword">const</span> store = configureStore();</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">        &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">            &lt;Route path="/"  component=&#123;App&#125;&gt;</div><div class="line">                &lt;IndexRoute component=&#123;AllMemosRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/todo" component=&#123;TodoRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/doing" component=&#123;DoingRoute&#125;/&gt;</div><div class="line">                &lt;Route path="/done" component=&#123;DoneRoute&#125;/&gt;</div><div class="line">            &lt;/Route&gt;</div><div class="line">        &lt;/Router&gt;</div><div class="line">   &lt;/Provider&gt;,</div><div class="line"> document.body.appendChild(document.createElement('div')))</div></pre></td></tr></table></figure>
<p>这里我们从<code>react-redux</code>中获取到 Provider 组件，我们把它渲染到应用的最外层。<br>他需要一个属性 store ，他把这个 store 放在context里，给Router(connect)用。</p>
<h4 id="4-3-Store"><a href="#4-3-Store" class="headerlink" title="4.3 Store"></a>4.3 Store</h4><blockquote>
<p> app/store/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'../reducers'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> store = createStore(reducer, initialState);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">    <span class="comment">// Enable Webpack hot module replacement for reducers</span></div><div class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'../reducers'</span>, () =&gt; &#123;</div><div class="line">      <span class="keyword">const</span> nextReducer = <span class="built_in">require</span>(<span class="string">'../reducers'</span>);</div><div class="line">      store.replaceReducer(nextReducer);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-Action-创建函数和常量"><a href="#4-4-Action-创建函数和常量" class="headerlink" title="4.4 Action 创建函数和常量"></a>4.4 Action 创建函数和常量</h4><blockquote>
<p>app/action/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @author Damonare 2016-12-10</div><div class="line"> * @version 1.0.0</div><div class="line"> * action 类型</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Add_Todo = <span class="string">'Add_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Todo_To_Doing = <span class="string">'Change_Todo_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Done = <span class="string">'Change_Doing_To_Done'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Done_To_Doing = <span class="string">'Change_Done_To_Doing'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Change_Doing_To_Todo = <span class="string">'Change_Doing_To_Todo'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Search=<span class="string">'Search'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delete_Todo=<span class="string">'Delete_Todo'</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * action 创建函数</div><div class="line"> * @method  addTodo添加新事项</div><div class="line"> * @param  &#123;String&#125; text 添加事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Add_Todo,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  search 查找事项</div><div class="line"> * @param  &#123;String&#125; text 查找事项的内容</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Search,</div><div class="line">      text</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeTodoToDoing 状态由todo转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeTodoToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Todo_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoneToDoing 状态由done转为doing</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoneToDoing</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Done_To_Doing,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToTodo 状态由doing转为todo</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Doing_To_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  changeDoingToDone 状态由doing转为done</div><div class="line"> * @param  &#123;Number&#125; index 需要改变状态的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeDoingToDone</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Change_Doing_To_Done,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * @method  deleteTodo 删除事项</div><div class="line"> * @param  &#123;Number&#125; index 需要删除的事项的下标</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteTodo</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      type: Delete_Todo,</div><div class="line">      index</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明每一个返回 action 函数的时候，我们需要在头部声明这个 action 的 type，以便好组织管理。<br>每个函数都会返回一个 action 对象，所以在 容器组件里面调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">text =&gt;</div><div class="line">  dispatch(addTodo(text))</div></pre></td></tr></table></figure>
<p>就是调用<code>dispatch(action)</code> 。</p>
<h4 id="4-5-Reducers"><a href="#4-5-Reducers" class="headerlink" title="4.5 Reducers"></a>4.5 Reducers</h4><blockquote>
<p>app/reducers/index.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> todolist <span class="keyword">from</span> <span class="string">'./todos'</span>;</div><div class="line"><span class="comment">// import visibilityFilter from './visibilityFilter';</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</div><div class="line">  todolist</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</div></pre></td></tr></table></figure>
<blockquote>
<p>app/reducers/todos.jsx</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Add_Todo,</div><div class="line">    Delete_Todo,</div><div class="line">    Change_Todo_To_Doing,</div><div class="line">    Change_Doing_To_Done,</div><div class="line">    Change_Doing_To_Todo,</div><div class="line">    Change_Done_To_Doing,</div><div class="line">    Search</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span>;</div><div class="line"><span class="keyword">let</span> todos;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (localStorage.todos) &#123;</div><div class="line">        todos = <span class="built_in">JSON</span>.parse(localStorage.todos)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        todos = []</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">todolist</span>(<span class="params">state = todos, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">        *  添加新的事项</div><div class="line">        *  并进行本地化存储</div><div class="line">        *  使用ES6展开运算符链接新事项和旧事项</div><div class="line">        *  JSON.stringify进行对象深拷贝</div><div class="line">        */</div><div class="line">        <span class="keyword">case</span> Add_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state, &#123;</div><div class="line">                    todo: action.text,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state, &#123;</div><div class="line">                    todo: action.text,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将todo转为doing状态，注意action.index的类型转换</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Todo_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为done状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Done:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">true</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将done转为doing状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Done_To_Doing:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">false</span>,</div><div class="line">                    doing: <span class="literal">true</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  将doing转为todo状态</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Change_Doing_To_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                &#123;</div><div class="line">                    todo:state[action.index].todo,</div><div class="line">                    istodo: <span class="literal">true</span>,</div><div class="line">                    doing: <span class="literal">false</span>,</div><div class="line">                    done: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  删除某个事项</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Delete_Todo:</div><div class="line">            localStorage.setItem(<span class="string">'todos'</span>, <span class="built_in">JSON</span>.stringify([</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ]));</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.index),</div><div class="line">                ...state.slice(<span class="built_in">parseInt</span>(action.index) + <span class="number">1</span>)</div><div class="line">            ];</div><div class="line">            <span class="comment">/*</span></div><div class="line">            *  搜索</div><div class="line">            */</div><div class="line">        <span class="keyword">case</span> Search:</div><div class="line">        <span class="keyword">let</span> text=action.text;</div><div class="line">        <span class="keyword">let</span> reg=<span class="built_in">eval</span>(<span class="string">"/"</span>+text+<span class="string">"/gi"</span>);</div><div class="line">            <span class="keyword">return</span> state.filter(item=&gt; item.todo.match(reg));</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> todolist;</div></pre></td></tr></table></figure>
<p>具体的展示组件这里就不罗列代码了，感兴趣的可以戳这：<a href="https://github.com/damonare/memos/tree/master/app/components" target="_blank" rel="external">备忘录展示组件地址</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>严格来说，这个备忘录并不是使用的react全家桶，毕竟还有一部分less代码，不过这一个应用也算是比较全面的使用了react+react-router+redux，作为react全家桶技术学习的练手的小项目再适合不过了。如果您对这个小东西感兴趣，欢迎戳这:<a href="https://github.com/damonare/memos" target="_blank" rel="external">React全家桶实现简易备忘录</a>给个star。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文采用react+redux+react-router+less+es6+webpack,以实现一个简易备忘录(todolist)为例尽可能全面的讲述使用react全家桶实现一个完整应用的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/damonare/memos&quot;&gt;React全家桶实现一个简易备忘录&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/12/19/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%A4%87%E5%BF%98%E5%BD%95/#more&quot;&gt;React全家桶实现一个简易备忘录&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生不失意，焉能暴己知。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="React" scheme="http://damonare.github.io/tags/React/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>百度FE工程师实习offer到手记</title>
    <link href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/"/>
    <id>http://damonare.github.io/2016/12/13/我的Web面试经历-百度/</id>
    <published>2016-12-13T08:18:32.655Z</published>
    <updated>2016-12-13T12:10:18.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于<a href="http://www.xidian.edu.cn/" target="_blank" rel="external">西安电子科技大学</a>，现在是大三在读。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more">百度FE工程师实习offer到手记</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>没有什么能够阻挡，你对自由的向往。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>整个面试过程是略微曲折的，博主参加了百度两个部门的面试，一个部门拿到了实习offer，另一个部门挂在了二面。文后暂且称为部门甲和部门乙吧。</p>
</blockquote>
<h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p><strong>基础知识储备</strong></p>
<p>作为一个FE(front-end,也就是前端)工程师基础的扎实是十分重要的。基本的HTML，CSS，Javascript知识得懂吧，自己的技术栈得建立起来吧，毕竟前端框架层出不穷，起码要有一个稳定的路线支撑着自己研究下去啊。基础知识部分这里推荐两篇博主之前的博文：</p>
<ul>
<li><a href="http://damonare.github.io/2016/09/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/#more">前端面试题集</a></li>
<li><a href="http://damonare.github.io/2016/09/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8/#more">前端面试大全</a></li>
</ul>
<p>有一篇是我自己总结的，一篇是转载大牛的，都可以看一下。</p>
<p><strong>简历与经历</strong></p>
<p>好的表达能力确实是很加分的，语言流畅，思路清晰，多说专业词汇，我觉得会给面试官留下很好的印象。将简历的内容完整的表达出来并不容易，每一个人在刚开始写简历的时候肯定都会尽量把自己忘好的方向写，但心里没有个尺度是不行的，太完美的人是不存在的，敢写就先要想好如果面试官问该怎么回答，或是会问什么问题，站在面试官的角度思考一下，某一方面到底有没有必要写在简历里。这个自己心里是要有数的。比如：关于某社团经历，组织过什么小活动，怎么组织的，时间地点人物安排的流程是什么样的，心里是要有准的;再比如：关于某项目经历，该项目的技术难点，遇到的问题以及解决方法，技术栈是啥，由几部分人组成，开发周期等信息心里是要有数的。</p>
<p>简历这块我总结如下，最基本的：</p>
<ul>
<li>姓名、电话、邮箱、学校、位置等必要信息</li>
<li>项目经历(技术栈，个人担任的角色，项目内容要说明白</li>
<li>获奖经历(别把高中得过三好学生这种的扯出来就好…)</li>
<li>个人性格(纯属凑字数)</li>
</ul>
<p>加分项：</p>
<ul>
<li>实习经历</li>
<li>Github开源项目</li>
<li>个人博客</li>
</ul>
<p><strong>投递地址</strong></p>
<p>可以找一些招聘网站投递简历，比如：</p>
<ul>
<li><a href="http://my.zhaopin.com/" target="_blank" rel="external">智联招聘</a></li>
<li><a href="http://my.51job.com/" target="_blank" rel="external">前程无忧</a></li>
<li><a href="http://passport.lagou.com/" target="_blank" rel="external">拉钩</a></li>
<li>相关企业的校招网站</li>
<li>大佬内推</li>
</ul>
<h3 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h3><p>博主先面试的是部门甲，一面面试官声音很好听，给人一种很放松的感觉。<br>下面是一面问的问题：</p>
<ul>
<li>自我介绍</li>
<li>拿手项目难点解决方法</li>
<li>gulp和webpack对比</li>
<li>git和svn对比</li>
<li>CSS居中方法</li>
<li>vue和react对比</li>
<li>如何用栈实现队列</li>
<li>取球算法问题</li>
<li>Es6你常用的特性</li>
<li>jquery和react对比</li>
<li>原生实现ajax</li>
<li>口述react单项数据流</li>
<li>react子组件如何传值给父组件</li>
</ul>
<p>一面太紧张了，很多问题回答的支支吾吾的，好在大佬给了二面机会，二面的面试官感觉性格也是很好的那种人，有说有笑的，问的问题如下：</p>
<ul>
<li>HTML5表单新特性</li>
<li>自己总结下编写html使用嵌套的注意点</li>
<li>scss的好处</li>
<li>写过什么复杂的数据交互的页面没，介绍下</li>
<li>无限级联动的注意点</li>
<li>描述下跨域使用场景，举例说明</li>
<li>gulp和webpack对比介绍</li>
<li>gulp和webpack原理区别</li>
<li>口述如何模拟radio，模拟下拉框</li>
</ul>
<p>然后参加了部门乙的一面，问题如下：</p>
<ul>
<li>CSS两栏布局</li>
<li>gulp和webpack对比</li>
<li>vue和react对比</li>
</ul>
<p>这次的一面博主忘记做记录了，很多问题想不起来了….十分抱歉，二面很简单，问题如下：</p>
<ul>
<li>分析下URL由哪几部分组成的</li>
<li>冒泡排序的时间复杂度，是否稳定</li>
<li>堆排序的时间复杂度，是否稳定</li>
<li>单链表反转</li>
</ul>
<p>博主自以为这四个问题答得还可以呢，以为应该过了，最后原来只是我以为…部门乙的面试石沉大海再无消息。</p>
<p>隔天,部门甲来电话说给我笔试题，让我做做看。用他们的技术栈实现一个备忘录，要求一周内完成。说是备忘录实际上就是稍微复杂一点的todolist。技术栈要求：react+redux+react-router+less+ES6。</p>
<p>这事似乎有门！博主抓紧查阅了资料学习。之前对于react是熟悉的但redux一直没怎么懂，另外博主平时使用较多的CSS预处理语言是scss，less没用过，又是一通查阅。好在博主小爆发了一下，两天时间写完了，交了上去。现在看看，感觉自己还是有潜力发掘的，人被逼急了大脑真是会疯狂运转。算是超预期完成了吧，加上了react-router和本地化存储以及一些小feature。下面是在线地址，感兴趣的话您可以去看看：<a href="http://damonare.cn/memos" target="_blank" rel="external">Damonare的备忘录</a></p>
<p>笔试题结束后，隔了几天(大佬看完了我的笔试题代码之后)，来了三面，三面的面试官也很和蔼，给人一种很亲切的感觉。大概聊了一下具体的时间安排以及我平时的一些活动和对于一些专业名词的理解。面试官说我技术面实际上表现的很不好，很多问题都答得不尽人意，但看我挺喜欢这行的，就给了我一次笔试的机会，好在我笔试过关了…(很后怕啊)</p>
<h3 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h3><p>技术面试流程我总结是这样的：</p>
<ul>
<li>自我介绍(必不可少啊，总得让面试官大概的了解自己吧)</li>
<li>基础知识阶段(广度阶段)</li>
<li>项目中遇到的难点以及解决方法</li>
<li>针对某一技术进行深度挖掘</li>
<li>你有什么要问我的</li>
</ul>
<p>我个人在最后的阶段，两个部门都问了一下他们现在所使用的的技术栈。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上能拿到这次百度的实习offer，您也能看出来很大一部分我靠的都是运气。部门甲的面试官们看了我的博客，同时他们在面试的时候也就几篇博文对我提了几个问题，可能也是从博客看出我对于FE的喜爱的吧。所以给了笔试的机会，否则我想部门甲的面试也会和部门乙一样挂掉。</p>
<p>但话说回来了，博客是自己搭的，博文是一篇一篇积累起来的，也不能说全是运气。</p>
<p>引用一句从一位现在在阿里工作的学长的一句话：<code>让别人知道你知道</code>。</p>
<p>让别人知道你知道，说起来好像很简单，但其实做起来并不容易，这个并不是只靠说的，嘴巴一张一合也只是让一个人知道了而已。想让更多人知道就得下点功夫了。不要在意别人的言语，包括博主自己现在某种程度上还是活在别人的眼里。那种过于在意别人的言语，渐渐把自己活成别人眼里的模样的人不是很可悲么。活出自己！过自己的生活，与他人何干。就像博主平时会码代码码到很晚，旁边也常传来一些不理解的话，诸如<code>码农</code>、<code>天天就知道写代码</code>。做自己！干自己喜欢的事！何必去理别人的看法呢！</p>
<p>另外，博主不是科班出身，不要以非科班或自己是个文科生去逃避，喜欢就去学，想做就做！Man一点好伐！诸如阮一峰，尤小右那样的大神不也是非科班一步步成就了现在的地位的么。</p>
<p>还有一点，如果您是一个现在在犹豫是否学习FE或是其他技术的人，请理智一点！千万不要拿我不喜欢技术这种枯燥的事为理由搪塞，谁告诉你技术枯燥的？！网络就是程序员的天下，所谓的程序员呆板钱多话少死得早都是程序员自黑的话，这种你也敢信？文字工作发泄情绪的平台是笔杆子，农民发泄情绪的平台是锄头，可悲的是这些并不会被大多数人看到，而程序员的自黑却会被整个网络的人看到。这点道理不明白？羡慕高薪就去学，学完了再去评论。没学过就说不感兴趣，那是愚蠢的！</p>
<p>最后，试着去推销自己吧，<code>让别人知道你知道</code>的方式有很多，诸如：做公众号，开专栏，写博客等方式。</p>
<p>当然为了不必要的烦恼，最好还是用昵称来经营自己。那么，博主选择方式就是写博客了。</p>
<p>就写博客这件事来说，一来可以作为自己学习的记录，二来可以作为一个学习笔记，三来可以作为一个知识分享的形式，一举三得，实在是个很好的方式。博主刚开始写的时候是没有人看的，当您正处在这个阶段的时候，不要放弃，坚持写，坚持记录，总有一天会有人发现某一篇博文的精彩的。不求带来多少经济利益，只为能给屏幕前的读者一丝帮助或是启迪。</p>
<p>总的来说，面试必需的三个要素我觉得如下：<code>礼貌</code>、<code>专业能力</code>、<code>运气</code>。一次面试的失败并没有什么，天时地利人和是很难凑齐的。不要灰心丧气，重整旗鼓，再战苍穹便是！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文总结了博主最近参加百度FE工程师面试过程中的一些心得和体会，分享给还在求职的同学以作参考，希望能给以帮助或是启迪。另外博主就读于&lt;a href=&quot;http://www.xidian.edu.cn/&quot;&gt;西安电子科技大学&lt;/a&gt;，现在是大三在读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/12/13/%E6%88%91%E7%9A%84Web%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86-%E7%99%BE%E5%BA%A6/#more&quot;&gt;百度FE工程师实习offer到手记&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;没有什么能够阻挡，你对自由的向往。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实习" scheme="http://damonare.github.io/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="面试" scheme="http://damonare.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS三栏布局的四种方法</title>
    <link href="http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://damonare.github.io/2016/12/07/CSS三栏布局的四种方法/</id>
    <published>2016-12-07T13:15:42.218Z</published>
    <updated>2016-12-11T10:11:05.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more">CSS三栏布局的四种方法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>年华一去不复返，事业放弃再难成。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>所谓三栏布局就是指页面分为左中右三部分然后对中间一部分做自适应的一种布局方式。</p>
</blockquote>
<h3 id="1-绝对定位法"><a href="#1-绝对定位法" class="headerlink" title="1.绝对定位法"></a>1.绝对定位法</h3><p>HTML代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//简单的进行CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0px;</div><div class="line">    margin:0px;</div><div class="line">&#125;</div><div class="line">//左右绝对定位</div><div class="line">.left,.right&#123;</div><div class="line">    position: absolute;</div><div class="line">    top:0px;</div><div class="line">    background: red;</div><div class="line">    height:100%;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">    left:0;</div><div class="line">    width:100px;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">    right:0px;</div><div class="line">    width:200px;</div><div class="line">&#125;</div><div class="line">//中间使用margin空出左右元素所占据的空间</div><div class="line">.main&#123;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">    height:100%;</div><div class="line">    background: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法有个明显的缺点，就是如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</p>
<h3 id="2-圣杯布局"><a href="#2-圣杯布局" class="headerlink" title="2. 圣杯布局"></a>2. 圣杯布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//习惯性的CSS reset</div><div class="line">body,html&#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//父元素body空出左右栏位</div><div class="line">body &#123;</div><div class="line">    padding-left: 100px;</div><div class="line">    padding-right: 200px;</div><div class="line">&#125;</div><div class="line">//左边元素更改</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    position: relative;</div><div class="line">    left: -100px;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间部分</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">//右边元素定义</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    height: 100%;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    position: relative;</div><div class="line">    right: -200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关解释如下：</p>
<ul>
<li>(1)中间部分需要根据浏览器宽度的变化而变化，所以要用100%，这里设左中右向左浮动，因为中间100%，左层和右层根本没有位置上去</li>
<li>(2)把左层margin负100后，发现left上去了，因为负到出窗口没位置了，只能往上挪</li>
<li>(3)按第二步这个方法，可以得出它只要挪动窗口宽度那么宽就能到最左边了，利用负边距，把左右栏定位</li>
<li>(4)但由于左右栏遮挡住了中间部分，于是采用相对定位方法，各自相对于自己把自己挪出去，得到最终结果</li>
</ul>
<h3 id="3-双飞翼布局"><a href="#3-双飞翼布局" class="headerlink" title="3. 双飞翼布局"></a>3. 双飞翼布局</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">        Main</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    /*padding-left:100px;*/</div><div class="line">    /*padding-right:200px;*/</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -100%;</div><div class="line">    height: 100%;</div><div class="line">    /*position: relative;*/</div><div class="line">    /*left:-100px;*/</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    width: 100%;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: left;</div><div class="line">    margin-left: -200px;</div><div class="line">    height: 100%;</div><div class="line">    /*position:relative;*/</div><div class="line">    /*right:-200px;*/</div><div class="line">&#125;</div><div class="line">//新增inner元素</div><div class="line">.inner &#123;</div><div class="line">    margin-left: 100px;</div><div class="line">    margin-right: 200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>圣杯布局实际看起来是复杂的后期维护性也不是很高，在淘宝UED的探讨下，出来了一种新的布局方式就是双飞翼布局，代码如上。增加多一个div就可以不用相对布局了，只用到了浮动和负边距。和圣杯布局差异的地方已经被注释。</p>
<h3 id="4-浮动"><a href="#4-浮动" class="headerlink" title="4. 浮动"></a>4. 浮动</h3><p>HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//注意元素次序</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//CSS reset</div><div class="line">body,html &#123;</div><div class="line">    height:100%;</div><div class="line">    padding: 0;</div><div class="line">    margin: 0</div><div class="line">&#125;</div><div class="line">//左栏左浮动</div><div class="line">.left &#123;</div><div class="line">    background: red;</div><div class="line">    width: 100px;</div><div class="line">    float: left;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line">//中间自适应</div><div class="line">.main &#123;</div><div class="line">    background: blue;</div><div class="line">    height: 100%;</div><div class="line">    margin:0px 200px 0px 100px;</div><div class="line">&#125;</div><div class="line">//右栏右浮动</div><div class="line">.right &#123;</div><div class="line">    background: red;</div><div class="line">    width: 200px;</div><div class="line">    float: right;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式代码足够简洁与高效，也容易理解</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>四种方法其实只有圣杯布局和双飞翼布局较难理解，但实际上理解了圣杯布局，双飞翼布局自然就理解了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 不管是三栏布局还是两栏布局都是我们在平时项目里经常使用的，也许你不知道什么事三栏布局什么是两栏布局但实际已经在用，或许你知道三栏布局的一种或两种方法，但实际操作中也只会依赖那某一种方法，本文具体的介绍了三栏布局的四种方法，并介绍了它的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/12/07/CSS%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/#more&quot;&gt;CSS三栏布局的四种方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;年华一去不复返，事业放弃再难成。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS" scheme="http://damonare.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(三)——集合</title>
    <link href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/"/>
    <id>http://damonare.github.io/2016/11/26/学习javascript数据结构（三）——集合/</id>
    <published>2016-11-26T05:24:45.261Z</published>
    <updated>2017-01-16T13:28:00.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more">学习javascript数据结构(三)——集合</a></li>
<li>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生多风雨，何处无险阻。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h3><p>在上一篇<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a>中我们说了链表这种数据结构，但归根结底，不论是栈，队列亦或是链表都是线性结构。他们都是一种很规矩的数据结构，就像幼儿园的小朋友排队乖乖的站在那不会动一样。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224745616" alt="幼儿园小朋友排队"></p>
<hr>
<p>然而纷杂的数据并不会总是排队站在那里，幼儿园小朋友一旦下了课那可就撒欢了，乱糟糟一团。可我们的幼儿园老师却能分辨出这些小朋友，因为啥？因为每个小朋友都在一个班里，而且每一个小朋友都有自己的名字。老师自然很容易就找到小朋友了。</p>
<hr>
<p><img src="http://img.blog.csdn.net/20161129224928510" alt="幼儿园小朋友下课"></p>
<hr>
<p>而本篇博文要说的集合正是一堆<code>乱糟糟的数据</code>，唯一的共同点是这些数据隶属于同一个<code>集合</code>,看下百科给出的解释：</p>
<blockquote>
<p>由一个或多个元素所构成的叫做集合。</p>
</blockquote>
<p>此处的元素就是小朋友了，他们所在的集合就是他们的班级。其实我们在高中的时候也接触过集合的概念。那时候还没有套路这个名词，单纯的岁月，那个年代对于集合是这么解释的：</p>
<blockquote>
<p>集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素。</p>
</blockquote>
<p>然后又是这么分类的：</p>
<ul>
<li>空集：{}</li>
<li>有限集：{a,b,4}</li>
<li>无限集：{1,2,3,4…}</li>
</ul>
<p>不过，数据结构中集合是没有无限集这个概念的。再然后那时候的集合还有这么几个特性：</p>
<ul>
<li>确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。</li>
<li>互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。有时需要对同一元素出现多次的情形进行刻画，可以使用多重集，其中的元素允许出现多次。</li>
<li>无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。集合上可以定义序关系，定义了序关系后，元素之间就可以按照序关系排序。但就集合本身的特性而言，元素之间没有必然的序。</li>
</ul>
<p>想当年哥还是个数学学霸，如今却沦落为了一个码农……真是让人唏嘘啊。咳咳！接着说：</p>
<p>集合还有这几种常见的基本操作：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<p>而且我们数据结构中的集合基本是也符合高中时候的数学中的概念的。接下来我们是用ES5来实现集合，为啥子这么说呢……因为在ES6中已经新给出了Set，Map等几个集合类，更加方便快捷的锁定键值对。</p>
<h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><p>首先我们先声明一个集合类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> items=&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们需要给链表声明一些方法：</p>
<ul>
<li>add(value):向集合添加一个新的项</li>
<li>remove(value):从集合移除一个值</li>
<li>has(value):如果值在集合中，返回true,否则返回false</li>
<li>clear():移除集合中的所有项</li>
<li>size():返回集合所包含的元素数量，与数组的length属性相似</li>
<li>values():返回一个集合中所有值的数组</li>
<li>union(setName):并集，返回包含两个集合所有元素的新集合(元素不重复)</li>
<li>intersection(setName):交集，返回包含两个集合中共有的元素的集合、</li>
<li>difference(setName):差集，返回包含所有存在本集合而不存在setName集合的元素的新集合</li>
<li>subset(setName):子集，验证setName是否是本集合的子集</li>
</ul>
<p>下面是Set类的完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            items[value] = value;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">            <span class="keyword">delete</span> items[value];</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.hasOwnProperty(value);</div><div class="line">        <span class="comment">//return value in items;</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = &#123;&#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * cross browser compatibility - legacy browsers</div><div class="line">     * for modern browsers use size function</div><div class="line">     * @returns &#123;number&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key))</div><div class="line">                ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Modern browsers function</div><div class="line">     * IE9+, FF4+, Chrome5+, Opera12+, Safari5+</div><div class="line">     * @returns &#123;Array&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items); i&lt;keys.length; i++) &#123;</div><div class="line">            values.push(items[keys[i]]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.valuesLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> values = [];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123;</div><div class="line">            <span class="keyword">if</span>(items.hasOwnProperty(key)) &#123;</div><div class="line">                values.push(items[key]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getItems = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> items;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        values = otherSet.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            unionSet.add(values[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                intersectionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> intersectionSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;    </div><div class="line">                differenceSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> differenceSet;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;  </div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是ES6版本代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Set2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Set2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        add(value)&#123;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                items_[value] = value;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span>(value)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</div><div class="line">                <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">delete</span> items_[value];</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        has(value)&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> items_.hasOwnProperty(value);</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items_).length;</div><div class="line">        &#125;</div><div class="line">        values()&#123;</div><div class="line">            <span class="keyword">let</span> values = [];</div><div class="line">            <span class="keyword">let</span> items_ = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, keys=<span class="built_in">Object</span>.keys(items_); i&lt;keys.length; i++) &#123;</div><div class="line">                values.push(items_[keys[i]]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> values;</div><div class="line">        &#125;</div><div class="line">        getItems()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        union(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            values = otherSet.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                unionSet.add(values[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> unionSet;</div><div class="line">        &#125;</div><div class="line">        intersection(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (otherSet.has(values[i]))&#123;</div><div class="line">                    intersectionSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intersectionSet;</div><div class="line">        &#125;</div><div class="line">        difference(otherSet)&#123;</div><div class="line">            <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">            <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                    differenceSet.add(values[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> differenceSet;</div><div class="line">        &#125;;</div><div class="line">        subset(otherSet)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size())&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</div><div class="line">                    <span class="keyword">if</span> (!otherSet.has(values[i]))&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Set2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>集合是一种比较常见的数据结构，在JS中我们已经有了一种类似哈希表的东西：Object(对象)。但现在我们所说的集合只是以[value,value]形式存储数据.敬请期待：<a href="https://damonare.github.io/2017/01/14/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#more">学习javascript数据结构(四)——树</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文讲解了数据结构中的[集合]概念，并使用javascript实现了集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/26/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/#more&quot;&gt;学习javascript数据结构(三)——集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生多风雨，何处无险阻。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本地存储小结</title>
    <link href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/16/Javascript本地存储小结/</id>
    <published>2016-11-16T03:35:51.573Z</published>
    <updated>2016-11-26T10:06:09.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括:</strong> 详细讲述<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>的区别和用法。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more">Javascript本地存储小结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生如画，岁月如歌。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-各种存储方案的简单对比"><a href="#1-各种存储方案的简单对比" class="headerlink" title="1. 各种存储方案的简单对比"></a>1. 各种存储方案的简单对比</h3><ul>
<li>Cookies：浏览器均支持，容量为4KB</li>
<li>UserData：仅IE支持，容量为64KB</li>
<li>Flash：100KB，非HTML原生，需要插件支持</li>
<li>Google Gears SQLite ：需要插件支持，容量无限制</li>
<li>LocalStorage：HTML5，容量为5M</li>
<li>SesstionStorage：HTML5，容量为5M</li>
<li>globalStorage：Firefox独有的，Firefox13开始就不再支持这个方法<blockquote>
<p>UserData仅IE支持， Google Gears SQLite需要插件，Flash已经伴随着HTML5的出现渐渐退出了历史舞台，因此今天我们的主角只有他们三个：<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>;</p>
</blockquote>
</li>
</ul>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><p>作为一个前端和Cookie打交道的次数肯定不会少了，Cookie算是比较古老的技术了<br>1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。</p>
<h4 id="2-1-Cookie的特点"><a href="#2-1-Cookie的特点" class="headerlink" title="2.1 Cookie的特点"></a>2.1 Cookie的特点</h4><p><strong>我们先来看下Cookie的特点：</strong></p>
<ul>
<li><p>1）cookie的大小受限制，cookie大小被限制在4KB，不能接受像大文件或邮件那样的大数据。</p>
</li>
<li><p>2）只要有请求涉及cookie，cookie就要在服务器和浏览器之间来回传送（这解释为什么本地文件不能测试cookie）。而且cookie数据始终在同源的http请求中携带（即使不需要），这也是Cookie不能太大的重要原因。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。</p>
</li>
<li><p>3）用户每请求一次服务器数据，cookie则会随着这些请求发送到服务器，服务器脚本语言如PHP等能够处理cookie发送的数据，可以说是非常方便的。当然前端也是可以生成Cookie的，用js对cookie的操作相当的繁琐，浏览器只提供document.cookie这样一个对象，对cookie的赋值，获取都比较麻烦。而在PHP中，我们可以通过setcookie()来设置cookie，通过$_COOKIE这个超全局数组来获取cookie。</p>
</li>
</ul>
<blockquote>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
</blockquote>
<h4 id="2-2-Session"><a href="#2-2-Session" class="headerlink" title="2.2 Session"></a>2.2 Session</h4><p>说到Cookie就不能不说Session。</p>
<blockquote>
<p>Session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。比如：<code>http://damonare.cn?sessionid=123456</code>还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"sessionid"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<h4 id="2-3-Cookie和Session简单对比"><a href="#2-3-Cookie和Session简单对比" class="headerlink" title="2.3 Cookie和Session简单对比"></a>2.3 Cookie和Session简单对比</h4><p><strong>Cookie和Session 的区别：</strong></p>
<ul>
<li><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
</li>
<li><p>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>
</li>
<li><p>3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</p>
</li>
<li>4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>5）所以建议：<ul>
<li>将登陆信息等重要信息存放为SESSION</li>
<li>其他信息如果需要保留，可以放在cookie中</li>
</ul>
</li>
</ul>
<h4 id="2-4-document-cookie的属性"><a href="#2-4-document-cookie的属性" class="headerlink" title="2.4 document.cookie的属性"></a>2.4 document.cookie的属性</h4><p><strong>expires属性</strong></p>
<blockquote>
<p>指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。</p>
</blockquote>
<p><strong>path属性</strong></p>
<blockquote>
<p>它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。</p>
</blockquote>
<p><strong>domain属性</strong></p>
<blockquote>
<p>domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.damonare.cn的服务器能够读取catalog.damonare.cn设置的cookie值。如果catalog.damonare.cn的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.damonare.cn”，那么所有位于catalog.damonare.cn的网页和所有位于orlders.damonare.cn的网页，以及位于damonare.cn域的其他服务器上的网页都可以访问这个cookie。</p>
</blockquote>
<p><strong>secure属性</strong></p>
<blockquote>
<p>它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输</p>
</blockquote>
<h4 id="2-5-cookie实战"><a href="#2-5-cookie实战" class="headerlink" title="2.5 cookie实战"></a>2.5 cookie实战</h4><blockquote>
<p>这里我们使用javascript来写一段cookie,借用w3cschool的demo:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">c_name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie.length&gt;<span class="number">0</span>)&#123;</div><div class="line">        c_start=<span class="built_in">document</span>.cookie.indexOf(c_name + <span class="string">"="</span>)</div><div class="line">        <span class="keyword">if</span> (c_start!=<span class="number">-1</span>)&#123;</div><div class="line">            c_start=c_start + c_name.length+<span class="number">1</span></div><div class="line">            c_end=<span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>,c_start)</div><div class="line">            <span class="keyword">if</span> (c_end==<span class="number">-1</span>) c_end=<span class="built_in">document</span>.cookie.length</div><div class="line">            <span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">document</span>.cookie.substring(c_start,c_end))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">c_name,value,expiredays</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> exdate=<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    exdate.setDate(exdate.getDate()+expiredays)</div><div class="line">    <span class="built_in">document</span>.cookie=c_name+ <span class="string">"="</span> +<span class="built_in">escape</span>(value)+</div><div class="line">            ((expiredays==<span class="literal">null</span>) ? <span class="string">""</span> : <span class="string">"; expires="</span>+exdate.toUTCString())</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    username=getCookie(<span class="string">'username'</span>)</div><div class="line">    <span class="keyword">if</span>(username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;alert(<span class="string">'Welcome again '</span>+username+<span class="string">'!'</span>)&#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        username=prompt(<span class="string">'Please enter your name:'</span>,<span class="string">""</span>)</div><div class="line">        <span class="keyword">if</span> (username!=<span class="literal">null</span> &amp;&amp; username!=<span class="string">""</span>)&#123;</div><div class="line">            setCookie(<span class="string">'username'</span>,username,<span class="number">355</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意这里对Cookie的生存期进行了定义，也就是355天</p>
</blockquote>
<h3 id="3-localStorage"><a href="#3-localStorage" class="headerlink" title="3. localStorage"></a>3. localStorage</h3><blockquote>
<p>这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。<br>它也是采用Key - Value的方式存储数据，底层数据接口是sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。</p>
</blockquote>
<h4 id="3-1-localStorage的属性方法"><a href="#3-1-localStorage的属性方法" class="headerlink" title="3.1 localStorage的属性方法"></a>3.1 localStorage的属性方法</h4><p>下表是localStorge的一些属性和方法</p>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>localStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>localStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>localStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>localStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>localStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>localStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h4 id="3-2-localStorage的缺点"><a href="#3-2-localStorage的缺点" class="headerlink" title="3.2 localStorage的缺点"></a>3.2 localStorage的缺点</h4><ul>
<li>① localStorage大小限制在500万字符左右，各个浏览器不一致</li>
<li>② localStorage在隐私模式下不可读取</li>
<li>③ localStorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）</li>
<li>④ localStorage不能被爬虫爬取，不要用它完全取代URL传参</li>
</ul>
<h3 id="4-sessionStorage"><a href="#4-sessionStorage" class="headerlink" title="4. sessionStorage"></a>4. sessionStorage</h3><blockquote>
<p>和服务器端使用的session类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。使用方法（和localStorage完全相同）：</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionStorage.length</td>
<td>获得storage中的个数</td>
</tr>
<tr>
<td>sessionStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
</tr>
<tr>
<td>sessionStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.key</td>
<td>获取键值key对应的值</td>
</tr>
<tr>
<td>sessionStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
</tr>
<tr>
<td>sessionStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
</tr>
<tr>
<td>sessionStorage.clear()</td>
<td>清除所有数据</td>
</tr>
</tbody>
</table>
<h3 id="5-sessionStorage和localStorage的区别"><a href="#5-sessionStorage和localStorage的区别" class="headerlink" title="5. sessionStorage和localStorage的区别"></a>5. sessionStorage和localStorage的区别</h3><ul>
<li><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。</p>
</li>
<li><p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。</p>
</li>
</ul>
<h4 id="5-1-测试"><a href="#5-1-测试" class="headerlink" title="5.1 测试"></a>5.1 测试</h4><p><strong>sessionStorage:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (sessionStorage.pagecount)&#123;</div><div class="line">    sessionStorage.pagecount=<span class="built_in">Number</span>(sessionStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">      sessionStorage.pagecount=<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ sessionStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>测试过程：我们在控制台输入上述代码查看打印结果</strong></p>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225014652" alt="sessionStorage测试结果"></p>
<p><strong>所谓的关闭窗口即销毁，就是这样，关闭窗口重新打开输入代码输出结果还是上面图片的样子，也就是说关闭窗口后sessionStorage.pagecount即被销毁，除非重心创建。或者从历史记录进入才会相关数据才会存在。好的，我们再来看下localStorge表现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (localStorage.pagecount)&#123;</div><div class="line">    localStorage.pagecount=<span class="built_in">Number</span>(localStorage.pagecount) +<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    localStorage.pagecount=<span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Visits "</span>+ localStorage.pagecount + <span class="string">" time(s)."</span>);</div></pre></td></tr></table></figure>
<p><strong>控制台首次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225028996" alt="localStorage测试结果1"></p>
<p><strong>关闭窗口，控制台再次输入代码：</strong></p>
<p><img src="http://img.blog.csdn.net/20161116225040575" alt="localStorage测试结果2"></p>
<h3 id="6-web-Storage和cookie的区别"><a href="#6-web-Storage和cookie的区别" class="headerlink" title="6. web Storage和cookie的区别"></a>6. web Storage和cookie的区别</h3><p>Web Storage(localStorage和sessionStorage)的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p>
<p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>博主尽可能思路清晰的理了一遍cookie，session，localStorage，sessionStorage之间的区别和联系，希望可以帮到大家。<br>参考文章：</p>
</blockquote>
<ul>
<li><a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">cookie 和session 的区别详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括:&lt;/strong&gt; 详细讲述&lt;code&gt;Cookie&lt;/code&gt;,&lt;code&gt;LocalStorge&lt;/code&gt;,&lt;code&gt;SesstionStorge&lt;/code&gt;的区别和用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more&quot;&gt;Javascript本地存储小结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生如画，岁月如歌。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="HTML5" scheme="http://damonare.github.io/tags/HTML5/"/>
    
      <category term="Cookie" scheme="http://damonare.github.io/tags/Cookie/"/>
    
      <category term="缓存" scheme="http://damonare.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="localStorage" scheme="http://damonare.github.io/tags/localStorage/"/>
    
      <category term="sessionStorage" scheme="http://damonare.github.io/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>全面理解Git</title>
    <link href="http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/11/13/Git 命令总结/</id>
    <published>2016-11-13T15:17:56.608Z</published>
    <updated>2016-11-26T10:01:57.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>总括：</strong> 本文详细讲解了Git常用命令的技巧和使用方法。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#more">Git命令总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生贵知心，定交无暮早。</strong><br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1.Git简介"></a>1.Git简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Git的诞生确实是一个有趣的故事，我们知道，当年Linus创建了开源的Linux，从此，Linux系统不断发展，现在已经成为最大的服务器系统软件了。(请不要傻傻分不清Linus和Linux)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但是随着Linux的不断壮大，就需要各种版本控制了，起初Linus带着他的小弟们使用的是BitKeeper(商业版本控制系统),之后呢由于某种原因BitKeeper的公司不让他们使用了，于是Linus自己花了两周时间写出了Git并且开源了(BitKeeper已哭晕在厕所)，阿弥陀佛，幸亏BitKeeper不让Linus他们用了，要不然我们现在也不会有这么好用的Git了，博主更不会在这写这篇博文了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;之后的岁月里，渐渐有了github,coding等一些可以使用git存储的网站，Git的江湖地位变得无可替代了，如果你是个开发者却还不会使用Git那就太out了。</p>
<p>这里先引用一张图解释Git<br>工作原理：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="Git原理"></p>
<ul>
<li>Workspace:工作区，执行<code>git add *</code>命令就把改动提交到了暂存区，执行<code>git pull</code>命令将远程仓库的数据拉到当前分支并合并，执行<code>git checkout [branch-name]</code>切换分支</li>
<li>Index:暂存区，执行<code>git commit -m &#39;说明&#39;</code> 命令就把改动提交到了仓库区（当前分支）</li>
<li>Repository:仓库区（或本地仓库），执行<code>git push origin master</code>提交到远程仓库，执行<code>git clone 地址</code>将克隆远程仓库到本地</li>
<li>Remote:远程仓库，就是类似github，coding等网站所提供的仓库</li>
</ul>
<p><strong>注</strong>：实际操作命令和上述命令会有所不同，这里这是解释清楚命令和仓库的关系。</p>
<h4 id="1-1-Git-术语"><a href="#1-1-Git-术语" class="headerlink" title="1.1  Git 术语"></a>1.1  Git 术语</h4><table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>仓库（Repository）</td>
<td>一个仓库包括了所有的版本信息、所有的分支和标记信息。在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。</td>
</tr>
<tr>
<td>分支（Branches）</td>
<td>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支执行命令<code>git checkout branch</code>.</td>
</tr>
<tr>
<td>标记（Tags）</td>
<td>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态</td>
</tr>
<tr>
<td>提交（Commit）</td>
<td>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</td>
</tr>
<tr>
<td>修订（Revision）</td>
<td>用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长，16进制标识的字符串.。最新的版本可以通过HEAD来获取。之前的版本可以通过”HEAD~1”来获取，以此类推。</td>
</tr>
</tbody>
</table>
<h4 id="1-2-忽略特定的文件"><a href="#1-2-忽略特定的文件" class="headerlink" title="1.2 忽略特定的文件"></a>1.2 忽略特定的文件</h4><p>可以配置Git忽略特定的文件或者是文件夹。这些配置都放在<code>.gitignore</code>文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。<br>比如<code>.gitignore</code>内容可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">忽略某文件</div><div class="line">npm-debug.log</div><div class="line">忽略文件夹</div><div class="line">dist/</div><div class="line">node_modules/</div><div class="line">.idea/</div></pre></td></tr></table></figure>
<p> 同时Git也提供了全局的配置，core.excludesfile。</p>
<blockquote>
<p>忽略之后的文件或是文件夹Git就不去提交里面的内容了。</p>
</blockquote>
<h4 id="1-3-使用-gitkeep来追踪空的文件夹"><a href="#1-3-使用-gitkeep来追踪空的文件夹" class="headerlink" title="1.3 使用.gitkeep来追踪空的文件夹"></a>1.3 使用.gitkeep来追踪空的文件夹</h4><p>Git会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置<code>.gitkeep</code>文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。</p>
<h4 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 显示当前的Git配置</div><div class="line">$ git config --list</div><div class="line"># 编辑Git配置文件，只是配置用户信息的话直接看下面两行命令即可</div><div class="line">$ git config -e [--global]</div><div class="line"># 设置提交代码时的用户信息，是否加上全局--global自行决定，一般是直接设置全局的。另外用户邮箱需要注意最好使用gmail,QQ也可以，需要和你远程仓库保持一致不然你的contribution是不会被记录在远程仓库的</div><div class="line">$ git config [--global] user.name &quot;[name]&quot;</div><div class="line">$ git config [--global] user.email &quot;[email address]&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
</blockquote>
<p><strong>个人觉得git是需要认真学的，虽然是个工具但不学习很容易把自己弄糊涂，希望这篇博客可以在某些时候帮到您，让您大概理解git的工作原理并把基本命令串起来。那么下面就说一下Git重要的基本命令吧。</strong></p>
<h3 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h3><p><a href="https://git-for-windows.github.io/index.html" target="_blank" rel="external">Git-for-window</a></p>
<blockquote>
<p>下载安装这个不用多说吧….</p>
</blockquote>
<h3 id="3-创建仓库"><a href="#3-创建仓库" class="headerlink" title="3.创建仓库"></a>3.创建仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 在当前目录创建一个文件夹</div><div class="line">$ mkdir [project-name]</div><div class="line"># 在当前目录新建一个Git代码库</div><div class="line">$ git init</div><div class="line"># 新建一个目录，将其初始化为Git代码库</div><div class="line">$ git init [project-name]</div><div class="line"># 下载一个项目和它的整个代码历史（各个分支提交记录等）</div><div class="line">$ git clone [url]</div></pre></td></tr></table></figure>
<blockquote>
<p><code>git init</code>后会出现.git文件夹，里面有配置文件，如果没有git bash里面输入<code>ls -lah</code>就可以看到了</p>
</blockquote>
<p><strong>关于如何关联Git和远程仓库，比如Coding，github等，可以看这两篇文章</strong>：<br><a href="http://www.cnblogs.com/plinx/archive/2013/04/08/3009159.html" target="_blank" rel="external">Git链接到自己的Github</a>&nbsp;&nbsp;&nbsp;<a href="https://coding.net/help/doc/git/getting-started.html#git-1" target="_blank" rel="external">Coding帮助中心</a></p>
<h3 id="4-提交文件"><a href="#4-提交文件" class="headerlink" title="4.提交文件"></a>4.提交文件</h3><h4 id="4-1首次推送"><a href="#4-1首次推送" class="headerlink" title="4.1首次推送"></a>4.1首次推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加当前目录的所有文件到暂存区</div><div class="line">$ git add *</div><div class="line"># 提交暂存区到仓库区</div><div class="line">$ git commit -m [message]</div><div class="line"># 为远程Git更名为origin</div><div class="line">$ git remote add origin git@github.com:abcd/tmp.git</div><div class="line"># 推送此次修改，这是首次推送需要加上-u,之后推送就可以直接git push  origin master,origin是远程Git名字，这个可以自己定义，不过一般是用origin罢了，master是默认的分支，如果不在master分支提交需要写清楚分支名称</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<blockquote>
<p>首次推送成功后可以看下下面的命令：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 添加指定文件到暂存区</div><div class="line">$ git add [file1] [file2] ...</div><div class="line"># 添加指定目录到暂存区，包括子目录</div><div class="line">$ git add [dir]</div><div class="line"># 添加当前目录的所有文件到暂存区</div><div class="line">$ git add *</div><div class="line"># 添加每个变化前，都会要求确认</div><div class="line">对于同一个文件的多处变化，可以实现分次提交</div><div class="line">$ git add -p</div><div class="line"># 删除工作区文件，并且将这次删除放入暂存区</div><div class="line">$ git rm [file1] [file2] ...</div><div class="line"># 停止追踪指定文件，但该文件会保留在工作区</div><div class="line">$ git rm --cached [file]</div><div class="line"># 改名文件，并且将这个改名放入暂存区</div><div class="line">$ git mv [file-original] [file-renamed]</div><div class="line"># 提交暂存区到仓库区</div><div class="line">$ git commit -m [message]</div><div class="line"># 提交暂存区的指定文件到仓库区</div><div class="line">$ git commit [file1] [file2] ... -m [message]</div><div class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</div><div class="line">$ git commit -a</div><div class="line"># 提交时显示所有diff信息</div><div class="line">$ git commit -v</div><div class="line"># 使用一次新的commit，替代上一次提交</div><div class="line">如果代码没有任何新变化，则用来改写上一次commit的提交信息</div><div class="line">$ git commit --amend -m [message]</div><div class="line"># 重做上一次commit，并包括指定文件的新变化</div><div class="line">$ git commit --amend [file1] [file2] ...</div><div class="line"># 提交更改到远程仓库</div><div class="line">$ git push origin master</div><div class="line"># 拉取远程更改到本地仓库默认自动合并</div><div class="line">$ git pull origin master</div></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只是维护自己的小项目的话，上面的命令已经够用了，自己一个人在master分支想咋折腾就咋折腾</p>
</blockquote>
<h4 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h4><blockquote>
<p>但如果是多人协作的话，git的魅力就开始提现出来了，每个人有自己的一个分支，各自在自己的分支上工作互不干扰。具体的看这：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">Git教程-创建合并分支</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># 列出所有本地分支</div><div class="line">$ git branch</div><div class="line"># 列出所有远程分支</div><div class="line">$ git branch -r</div><div class="line"># 列出所有本地分支和远程分支</div><div class="line">$ git branch -a</div><div class="line"># 新建一个分支，但依然停留在当前分支</div><div class="line">$ git branch [branch-name]</div><div class="line"># 新建一个分支，并切换到该分支</div><div class="line">$ git checkout -b [branch]</div><div class="line"># 新建一个分支，指向指定commit</div><div class="line">$ git branch [branch] [commit]</div><div class="line"># 新建一个分支，与指定的远程分支建立追踪关系</div><div class="line">$ git branch --track [branch] [remote-branch]</div><div class="line"># 切换到指定分支，并更新工作区</div><div class="line">$ git checkout [branch-name]</div><div class="line"># 切换到上一个分支</div><div class="line">$ git checkout -</div><div class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</div><div class="line">$ git branch --set-upstream [branch] [remote-branch]</div><div class="line"># 合并指定分支到当前分支，如果有冲突需要手动合并冲突（就是手动编辑文件保存咯），然后add,commit再提交</div><div class="line">$ git merge [branch]</div><div class="line"># 选择一个commit，合并进当前分支</div><div class="line">$ git cherry-pick [commit]</div><div class="line"># 删除分支</div><div class="line">$ git branch -d [branch-name]</div><div class="line"># 删除远程分支</div><div class="line">$ git push origin --delete [branch-name]</div><div class="line">$ git branch -dr [remote/branch]</div></pre></td></tr></table></figure>
<h4 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h4><blockquote>
<p>标签的作用主要是用来做版本回退的，关于版本回退，这也是Git的亮点之一，起到了后悔药的功能·</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 列出所有tag</div><div class="line">$ git tag</div><div class="line"># 新建一个tag在当前commit</div><div class="line">$ git tag [tag]</div><div class="line"># 新建一个tag在指定commit</div><div class="line">$ git tag [tag] [commit]</div><div class="line"># 删除本地tag</div><div class="line">$ git tag -d [tag]</div><div class="line"># 删除远程tag</div><div class="line">$ git push origin :refs/tags/[tagName]</div><div class="line"># 查看tag信息</div><div class="line">$ git show [tag]</div><div class="line"># 提交指定tag</div><div class="line">$ git push [remote] [tag]</div><div class="line"># 提交所有tag</div><div class="line">$ git push [remote] --tags</div><div class="line"># 新建一个分支，指向某个tag</div><div class="line">$ git checkout -b [branch] [tag]</div></pre></td></tr></table></figure>
<h4 id="7-后悔药"><a href="#7-后悔药" class="headerlink" title="7.后悔药"></a>7.后悔药</h4><blockquote>
<p>想一下在你写完N个文件代码后，commit到了本地仓库，突然发现整个应用崩溃了！咋整？Git给了我们吃后悔药<br>的机会：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 恢复暂存区的指定文件到工作区</div><div class="line">$ git checkout [file]</div><div class="line"># 恢复某个commit的指定文件到暂存区和工作区</div><div class="line">$ git checkout [commit] [file]</div><div class="line"># 恢复暂存区的所有文件到工作区</div><div class="line">$ git checkout .</div><div class="line"># 回退到上一个版本，在Git中，用HEAD表示当前版本</div><div class="line">$ git reset --hard HEAD^</div><div class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</div><div class="line">$ git reset [file]</div><div class="line"># 重置暂存区与工作区，与上一次commit保持一致</div><div class="line">$ git reset --hard</div><div class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</div><div class="line">$ git reset [commit]</div><div class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">$ git reset --hard [commit]</div><div class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class="line">$ git reset --keep [commit]</div><div class="line"># 新建一个commit，用来撤销指定commit</div><div class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class="line">$ git revert [commit]</div><div class="line"># 暂时将未提交的变化移除，稍后再移入</div><div class="line">$ git stash</div><div class="line">$ git stash pop</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候标签的作用就体现出来了，因为commit号太冗长了，记起来太麻烦有了标签我们相当于自定义了commit号</p>
</blockquote>
<h4 id="8-文件信息"><a href="#8-文件信息" class="headerlink" title="8. 文件信息"></a>8. 文件信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># 显示当前分支的版本历史</div><div class="line">$ git log</div><div class="line"># 显示commit历史，以及每次commit发生变更的文件</div><div class="line">$ git log --stat</div><div class="line"># 搜索提交历史，根据关键词</div><div class="line">$ git log -S [keyword]</div><div class="line"># 显示某个commit之后的所有变动，每个commit占据一行</div><div class="line">$ git log [tag] HEAD --pretty=format:%s</div><div class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</div><div class="line">$ git log [tag] HEAD --grep feature</div><div class="line"># 显示某个文件的版本历史，包括文件改名</div><div class="line">$ git log --follow [file]</div><div class="line">$ git whatchanged [file]</div><div class="line"># 显示指定文件相关的每一次diff</div><div class="line">$ git log -p [file]</div><div class="line"># 显示过去5次提交</div><div class="line">$ git log -5 --pretty --oneline</div><div class="line"># 显示所有提交过的用户，按提交次数排序</div><div class="line">$ git shortlog -sn</div><div class="line"># 显示指定文件是什么人在什么时间修改过</div><div class="line">$ git blame [file]</div><div class="line"># 显示暂存区和工作区的差异</div><div class="line">$ git diff</div><div class="line"># 显示暂存区和上一个commit的差异</div><div class="line">$ git diff --cached [file]</div><div class="line"># 显示工作区与当前分支最新commit之间的差异</div><div class="line">$ git diff HEAD</div><div class="line"># 显示两次提交之间的差异</div><div class="line">$ git diff [first-branch]...[second-branch]</div><div class="line"># 显示今天你写了多少行代码</div><div class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div><div class="line"># 显示某次提交的元数据和内容变化</div><div class="line">$ git show [commit]</div><div class="line"># 显示某次提交发生变化的文件</div><div class="line">$ git show --name-only [commit]</div><div class="line"># 显示某次提交时，某个文件的内容</div><div class="line">$ git show [commit]:[filename]</div></pre></td></tr></table></figure>
<h3 id="8-其它命令"><a href="#8-其它命令" class="headerlink" title="8.其它命令"></a>8.其它命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git blame filepath</td>
<td>git blame清楚的记录某个文件的更改历史和更改人，简直是查看背锅人的利器，filepath是需要查看的文件路径</td>
</tr>
<tr>
<td>git status</td>
<td>显示有变更的文件</td>
</tr>
<tr>
<td>git reflog</td>
<td>显示当前分支的最近几次提交</td>
</tr>
</tbody>
</table>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>要想彻底熟练使用git那需要记住的命令多了去了，起码几百个吧，不过在日常使用中，本文涉及的命令应该是足够用了，有遗漏的常用命令欢迎提出补充。另外，诚心希望您能把参考文章好好读一下，阮老师和廖老师总结的十分到位。本文好多命令也都是使用的两位老师总结的。</p>
</blockquote>
<p>参考文章：</p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">Git命令清单</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详细讲解了Git常用命令的技巧和使用方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/11/13/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#more&quot;&gt;Git命令总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生贵知心，定交无暮早。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="Git" scheme="http://damonare.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(二)——链表</title>
    <link href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <id>http://damonare.github.io/2016/11/09/学习javascript数据结构（二）——链表/</id>
    <published>2016-11-09T07:58:46.661Z</published>
    <updated>2016-11-26T09:49:06.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文详解解释了数据结构中的链表的概念并阐述了如何在javascript中如何去创建一个链表。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more">学习javascript数据结构(二)——链表</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生总是直向前行走，从不留下什么。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇博客-<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a>说了栈和队列在javascript中的实现,我们运用javascript提供的API很容易的实现了栈和队列，但这种数据结构有一个很明显的缺点，因为数组大小是固定的所以我们在移除或是添加一项数据的时候成本很高，基本都需要吧数据重排一次。(javascript的Array类方法虽然很方便但背后的原理同样是这样的)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;相比数组我们今天主角——链表就要来的随性的多，简单的理解可以是这样：在内存中，栈和队列（数组）的存在就是一个整体，如果想要对她内部某一个元素进行移除或是添加一个新元素就要动她内部所有的元素，所谓牵一发而动全身；而链表则不一样，每一个元素都是由元素本身数据和指向下一个元素的指针构成，所以添加或是移除某一个元素不需要对链表整体进行操作，只需要改变相关元素的指针指向就可以了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;链表在实际生活中的例子也有很多，比如自行车的链条，环环相扣，但添加或是移除某一个环节只需要对症下药，对相关环节进行操作就OK。再比如：火车，火车就是一个链表，每一节车厢就是元素，想要移除或是添加某一节车厢，只需要把连接车厢的链条改变一下就好了。那么，在javascript中又该怎么去实现链表结构呢？</p>
<h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><p>首先我们要创建一个链表类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//各种属性和方法的声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数据结构来保存链表里面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Node=<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.element=element;</div><div class="line">    <span class="keyword">this</span>.next=<span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Node类表示要添加的元素，他有两个属性，一个是element，表示添加到链表中的具体的值；另一个是next,表示要指向链表中下一个元素的指针。</span></div></pre></td></tr></table></figure>
<p>接下来，我们需要给链表声明一些方法：</p>
<ul>
<li>append(element):向链表尾部添加一个新的元素；</li>
<li>insert(position,element):向链表特定位置插入元素；</li>
<li>remove(element):从链表移除一项；</li>
<li>indexOf(element):返回链表中某元素的索引，如果没有返回-1；</li>
<li>removeAt(position):从特定位置移除一项；</li>
<li>isEmpty():判断链表是否为空，如果为空返回true,否则返回false;</li>
<li>size():返回链表包含的元素个数；</li>
<li>toString():重写继承自Object类的toString()方法，因为我们使用了Node类；</li>
</ul>
<h3 id="链表的完整代码："><a href="#链表的完整代码：" class="headerlink" title="链表的完整代码："></a>链表的完整代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//Node类声明</span></div><div class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//初始化链表长度</span></div><div class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化第一个元素</span></div><div class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="comment">//初始化添加的Node实例</span></div><div class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">            current;</div><div class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>)&#123;</div><div class="line">            <span class="comment">//第一个Node实例进入链表，之后在这个LinkedList实例中head就不再是null了</span></div><div class="line">            head = node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            current = head;</div><div class="line">            <span class="comment">//循环链表知道找到最后一项，循环结束current指向链表最后一项元素</span></div><div class="line">            <span class="keyword">while</span>(current.next)&#123;</div><div class="line">                current = current.next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//找到最后一项元素后，将他的next属性指向新元素node,j建立链接</span></div><div class="line">            current.next = node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新链表长度</span></div><div class="line">        length++;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>)</span>&#123;</div><div class="line">        <span class="comment">//检查是否越界，超过链表长度或是小于0肯定不符合逻辑的</span></div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current = head,</div><div class="line">                previous,</div><div class="line">                index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//在第一个位置添加</span></div><div class="line">                node.next = current;</div><div class="line">                head = node;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//循环链表，找到正确位置，循环完毕，previous，current分别是被添加元素的前一个和后一个元素</span></div><div class="line">                <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>)&#123;</span></span></div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">            &#125;</div><div class="line">            //更新链表长度</div><div class="line">            <span class="attr">length</span>++;</div><div class="line">            <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.removeAt</span> = <span class="string">function(position)&#123;</span></div><div class="line">        //检查是否越界，超过链表长度或是小于<span class="attr">0</span>肯定不符合逻辑的</div><div class="line">        <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>)&#123;</span></div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">                <span class="attr">previous</span>,</div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            //移除第一个元素</div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)&#123;</span></div><div class="line">                //移除第一项，相当于<span class="attr">head</span>=<span class="string">null;</span></div><div class="line">                <span class="attr">head</span> = <span class="string">current.next;</span></div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                //循环链表，找到正确位置，循环完毕，<span class="attr">previous</span>，<span class="attr">current</span>分别是被添加元素的前一个和后一个元素</div><div class="line">                <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>)&#123;</div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                //链接<span class="attr">previous</span>和<span class="attr">current</span>的下一个元素，也就是把<span class="attr">current</span>移除了</div><div class="line">                <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length--</span>;</div><div class="line">            <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.indexOf</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">        //循环链表找到元素位置</div><div class="line">        <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">element</span> === <span class="string">current.element)</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="attr">index</span>++;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.remove</span> = <span class="string">function(element)&#123;</span></div><div class="line">        //调用已经声明过的<span class="attr">indexOf</span>和<span class="attr">removeAt</span>方法</div><div class="line">        <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">        <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.isEmpty</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span> === <span class="string">0;</span></div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.size</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getHead</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">head</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.toString</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">string</span> = <span class="string">''</span>;</div><div class="line">        <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">            <span class="attr">string</span> += <span class="string">current.element</span> + (<span class="attr">current.next</span> ? ', ' <span class="attr">:</span> '');</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">string</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.print</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">//一个实例化后的链表，里面是添加的数个<span class="attr">Node</span>类的实例</div></pre></td></tr></table></figure>
<p>ES6版本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> LinkedList2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(element)&#123;</div><div class="line">            <span class="keyword">this</span>.element = element;</div><div class="line">            <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里我们使用WeakMap对象来记录长度状态</span></div><div class="line">    <span class="keyword">const</span> length = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="keyword">const</span> head = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkedList2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            length.set(<span class="keyword">this</span>, <span class="number">0</span>);</div><div class="line">            head.set(<span class="keyword">this</span>, <span class="literal">null</span>);</div><div class="line">        &#125;</div><div class="line">        append(element) &#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getHead() === <span class="literal">null</span>) &#123;</div><div class="line">                head.set(<span class="keyword">this</span>, node);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                current = <span class="keyword">this</span>.getHead();</div><div class="line">                <span class="keyword">while</span> (current.next) &#123;</div><div class="line">                    current = current.next;</div><div class="line">                &#125;</div><div class="line">                current.next = node;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">let</span> l = <span class="keyword">this</span>.size();</div><div class="line">            l++;</div><div class="line">            length.set(<span class="keyword">this</span>, l);</div><div class="line">        &#125;</div><div class="line">        insert(position, element) &#123;</div><div class="line">            <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= <span class="keyword">this</span>.size()) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                    current = <span class="keyword">this</span>.getHead(),</div><div class="line">                    previous,</div><div class="line">                    index = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</div><div class="line">                    node.next = current;</div><div class="line">                    head.set(<span class="keyword">this</span>, node);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></div><div class="line">                        <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                        <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">let</span> <span class="attr">l</span> = <span class="string">this.size();</span></div><div class="line">                <span class="attr">l</span>++;</div><div class="line">                <span class="attr">length.set</span>(<span class="attr">this</span>, <span class="attr">l</span>);</div><div class="line">                <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">removeAt</span>(<span class="attr">position</span>) &#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">this.size</span>()) &#123;</span></div><div class="line">                <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                    <span class="attr">previous</span>,</div><div class="line">                    <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">                <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)</span> &#123;</div><div class="line">                    <span class="attr">head.set</span>(<span class="attr">this</span>, <span class="attr">current.next</span>);</div><div class="line">                &#125; <span class="attr">else</span> &#123;</div><div class="line">                    <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>) &#123;</div><div class="line">                        <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                        <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">let</span> <span class="attr">l</span> = <span class="string">this.size();</span></div><div class="line">                <span class="attr">l--</span>;</div><div class="line">                <span class="attr">length.set</span>(<span class="attr">this</span>, <span class="attr">l</span>);</div><div class="line">                <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">remove</span>(<span class="attr">element</span>) &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">            <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">indexOf</span>(<span class="attr">element</span>) &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">                <span class="attr">if</span> (<span class="attr">element</span> === <span class="string">current.element)</span> &#123;</div><div class="line">                    <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="attr">index</span>++;</div><div class="line">                <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">isEmpty</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">this.size</span>() === <span class="string">0;</span></div><div class="line">        &#125;</div><div class="line">        <span class="attr">size</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">length.get</span>(<span class="attr">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">getHead</span>() &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">head.get</span>(<span class="attr">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="attr">toString</span>() &#123;</div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">this.getHead(),</span></div><div class="line">                <span class="attr">string</span> = <span class="string">''</span>;</div><div class="line">            <span class="attr">while</span> (<span class="attr">current</span>) &#123;</div><div class="line">                <span class="attr">string</span> += <span class="string">current.element</span> + (<span class="attr">current.next</span> ? ', ' <span class="attr">:</span> '');</div><div class="line">                <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">return</span> <span class="attr">string</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="attr">print</span>() &#123;</div><div class="line">            <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="attr">return</span> <span class="attr">LinkedList2</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//NEW</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//NEW</span></div><div class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">            current;</div><div class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>)&#123;</div><div class="line">            head = node;</div><div class="line">            tail = node; <span class="comment">//NEW</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//NEW</span></div><div class="line">            tail.next = node;</div><div class="line">            node.prev = tail;</div><div class="line">            tail = node;</div><div class="line">        &#125;</div><div class="line">        length++;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</div><div class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</div><div class="line">                current = head,</div><div class="line">                previous,</div><div class="line">                index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">if</span> (!head)&#123;       <span class="comment">//NEW</span></div><div class="line">                    head = node;</div><div class="line">                    tail = node;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    node.next = current;</div><div class="line">                    current.prev = node; <span class="comment">//NEW</span></div><div class="line">                    head = node;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (position === length) &#123; <span class="comment">////NEW</span></div><div class="line">                current = tail;   </div><div class="line">                current.next = node;</div><div class="line">                node.prev = current;</div><div class="line">                tail = node;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>)&#123;</span></span></div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">node.next</span> = <span class="string">current;</span></div><div class="line">                <span class="attr">previous.next</span> = <span class="string">node;</span></div><div class="line">                <span class="attr">current.prev</span> = <span class="string">node;</span> //<span class="attr">NEW</span></div><div class="line">                <span class="attr">node.prev</span> = <span class="string">previous;</span> //<span class="attr">NEW</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length</span>++;</div><div class="line">            <span class="attr">return</span> <span class="attr">true</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.removeAt</span> = <span class="string">function(position)&#123;</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">position</span> &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>)&#123;</span></div><div class="line">            <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">                <span class="attr">previous</span>,</div><div class="line">                <span class="attr">index</span> = <span class="string">0;</span></div><div class="line">            <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">0)&#123;</span> //<span class="attr">NEW</span></div><div class="line">                <span class="attr">if</span> (<span class="attr">length</span> === <span class="string">1)&#123;</span> //</div><div class="line">                    <span class="attr">tail</span> = <span class="string">null;</span></div><div class="line">                &#125; <span class="attr">else</span> &#123;</div><div class="line">                    <span class="attr">head.prev</span> = <span class="string">null;</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">position</span> === <span class="string">length-1)&#123;</span>  //<span class="attr">NEW</span></div><div class="line">                <span class="attr">current</span> = <span class="string">tail;</span></div><div class="line">                <span class="attr">tail</span> = <span class="string">current.prev;</span></div><div class="line">                <span class="attr">tail.next</span> = <span class="string">null;</span></div><div class="line">            &#125; <span class="attr">else</span> &#123;</div><div class="line">                <span class="attr">while</span> (<span class="attr">index</span>++ &lt; <span class="attr">position</span>)&#123;</div><div class="line">                    <span class="attr">previous</span> = <span class="string">current;</span></div><div class="line">                    <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="attr">previous.next</span> = <span class="string">current.next;</span></div><div class="line">                <span class="attr">current.next.prev</span> = <span class="string">previous;</span> //<span class="attr">NEW</span></div><div class="line">            &#125;</div><div class="line">            <span class="attr">length--</span>;</div><div class="line">            <span class="attr">return</span> <span class="attr">current.element</span>;</div><div class="line">        &#125; <span class="attr">else</span> &#123;</div><div class="line">            <span class="attr">return</span> <span class="attr">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.remove</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">index</span> = <span class="string">this.indexOf(element);</span></div><div class="line">        <span class="attr">return</span> <span class="attr">this.removeAt</span>(<span class="attr">index</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.indexOf</span> = <span class="string">function(element)&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">index</span> = <span class="string">-1;</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">            <span class="attr">return</span> <span class="attr">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">index</span>++;</div><div class="line">        <span class="attr">while</span>(<span class="attr">current.next</span>)&#123;</div><div class="line">            <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">                <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            <span class="attr">index</span>++;</div><div class="line">        &#125;</div><div class="line">        //<span class="attr">check</span> <span class="attr">last</span> <span class="attr">item</span></div><div class="line">        <span class="attr">if</span> (<span class="attr">element</span> == <span class="string">current.element)&#123;</span></div><div class="line">            <span class="attr">return</span> <span class="attr">index</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">-1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.isEmpty</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span> === <span class="string">0;</span></div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.</span> <span class="attr">size</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">return</span> <span class="attr">length</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.toString</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">head,</span></div><div class="line">            <span class="attr">s</span> = <span class="string">current</span> ? <span class="attr">current.element</span> <span class="attr">:</span> '';</div><div class="line">        <span class="attr">while</span>(<span class="attr">current</span> &amp;&amp; <span class="attr">current.next</span>)&#123;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.next;</span></div><div class="line">            <span class="attr">s</span> += <span class="string">', '</span> + <span class="attr">current.element</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">s</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.inverseToString</span> = <span class="string">function()</span> &#123;</div><div class="line">        <span class="attr">let</span> <span class="attr">current</span> = <span class="string">tail,</span></div><div class="line">            <span class="attr">s</span> = <span class="string">current</span> ? <span class="attr">current.element</span> <span class="attr">:</span> '';</div><div class="line">        <span class="attr">while</span>(<span class="attr">current</span> &amp;&amp; <span class="attr">current.prev</span>)&#123;</div><div class="line">            <span class="attr">current</span> = <span class="string">current.prev;</span></div><div class="line">            <span class="attr">s</span> += <span class="string">', '</span> + <span class="attr">current.element</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="attr">return</span> <span class="attr">s</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.print</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.toString</span>());</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.printInverse</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">console.log</span>(<span class="attr">this.inverseToString</span>());</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getHead</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">head</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="attr">this.getTail</span> = <span class="string">function()&#123;</span></div><div class="line">        <span class="attr">return</span> <span class="attr">tail</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单项比起来就是Node类多了一个prev属性，也就是每一个node不仅仅有一个指向它后面元素的指针也有一个指向它前面的指针。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;明白了前面的基础链表和双向链表之后这个肯定不在话下了，循环，其实就是整个链表实例变成了一个圈，在单项链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了单向循环链表。在双向链表中最后一个元素的next属性为null,现在让它指向第一个元素也就是head，那么他就成了双向循环链表。就那么回事…</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>说到现在一直都是线性表，就是顺序数据结构，他们都是有顺序的，数据都是一条绳子上的蚂蚱。那么，如果数据是没有顺序的呢？那又该使用哪种数据结构呢？这个放到[学习javascript数据结构(三)——集合]中学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详解解释了数据结构中的链表的概念并阐述了如何在javascript中如何去创建一个链表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/09/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/#more&quot;&gt;学习javascript数据结构(二)——链表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生总是直向前行走，从不留下什么。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Internet协议入门</title>
    <link href="http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
    <id>http://damonare.github.io/2016/11/05/互联网协议入门/</id>
    <published>2016-11-05T04:00:49.017Z</published>
    <updated>2016-11-26T06:00:37.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 博主之前写过一篇博客：<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>,在这篇博客里通过抓包，具体的分析了不同网络协议的传送的数据和传送的方式。而此篇博客则用来作为一个大纲式的内容，按照层级划分，逐步介绍各层级的协议以及他们所起的作用。若有错误之处，欢迎批评指正。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/#more">internet协议入门</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>劳于读书，逸于作文。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</strong></p>
<h4 id="1-1-模型划分"><a href="#1-1-模型划分" class="headerlink" title="1.1 模型划分"></a>1.1 模型划分</h4><p>首先我们需要明白的事互联网的实现是分层级的，那么这个层级的划分根据不同的模型又有一些不同。其中又有两个模型的划分是我们最常见到的，一个是OSI七层划分，另一个是TCP/IP五层划分。他们分别把互联网分成了七层和五层。</p>
<blockquote>
<p>OSI和TCP/IP模型是很基础但又非常重要的网络基础知识</p>
</blockquote>
<p><strong>OSI七层模型</strong></p>
<table>
<thead>
<tr>
<th>OSI的层</th>
<th>功能</th>
<th>TCP/IP协议族</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>没有协议</td>
</tr>
<tr>
<td>会话层</td>
<td>解除或建立与别的接点的联系</td>
<td>没有协议</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据包选择路由</td>
<td>IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>传输有地址的帧以及错误检测功能</td>
<td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr>
<td>物理层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
<td>ISO2110，IEEE802，IEEE802.2</td>
</tr>
</tbody>
</table>
<h4 id="1-2-层与协议"><a href="#1-2-层与协议" class="headerlink" title="1.2 层与协议"></a>1.2 层与协议</h4><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br><br>大家都遵守的规则，就叫做”协议”（protocol）。<br><br>这个协议就是我们所说的<code>互联网协议</code>（internet protocol）,每一层都有若干个协议，他们共同构成了我们所要讲的互联网协议。<br><br>由以上表格我们可以看出，在<code>OSI七层协议</code>模型里会话层和表示层是没有协议的，这里我们取的是<code>TCP/IP</code>模型，分成五层也比较容易解释。<br><br>那么这五层又都是什么呢？从上到下分别是：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>网络设备</th>
</tr>
</thead>
<tbody>
<tr>
<td> 应用层</td>
<td>　也就是用户使用的应用了。</td>
</tr>
<tr>
<td> 传输层</td>
<td>四层交换机、也有工作在四层的路由器</td>
</tr>
<tr>
<td> 网络层</td>
<td>路由器、三层交换机</td>
</tr>
<tr>
<td> 数据链路层</td>
<td>网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</td>
</tr>
<tr>
<td> 物理层</td>
<td>网卡，光纤，CAT-5线，中继器、集线器、还有我们通常说的双绞线也工作在物理层</td>
</tr>
</tbody>
</table>
<p>如上表格所示，最底下的一层叫做<code>物理层</code>（Physical Layer），最上面的一层叫做<code>应用层</code>（Application Layer），中间的三层（自下而上）分别是<code>数据链路层</code>（Data Link Layer）、<code>网络层</code>（Network Layer）和<code>传输层</code>（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。下面来介绍每一层的功能，着重介绍每一层的主要协议</p>
<h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h3><blockquote>
<p>物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性 ——<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82" target="_blank" rel="external">物理层(维基百科)</a></p>
</blockquote>
<p>上面维基百科对于物理层的解释说白了就是要把电脑连在一块，方法呢，可以用光缆、电缆、双绞线、无线电波等方式。<br></p>
<p><img src="http://img.blog.csdn.net/20161105225615088" alt="物理层连接"></p>
<p><strong><code>物理层</code>就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>
<h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h3><blockquote>
<p>在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：数据帧或帧），并对帧定界、同步、收发顺序的控制。 ——<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" target="_blank" rel="external">数据链路层(维基百科)</a></p>
</blockquote>
<h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>上面说的网络实体也就是我们日常用到的手机电脑等联网设备了，我们刚刚了解到不同网络实体之间通过一些物理手段（光缆，双绞线，无线电波等）连接在了一起，来进行传输0和1电信号。单纯的传输0和1没有任何意义，肯定是要规定电信号的解读方式，多少个电信号是一组？每一组代表的意义又是什么？</p>
<p><strong>这就是数据链路层的功能，规定这些电信号的分组方式。</strong></p>
<h4 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h4><p>刚刚开始的时候，每一家公司都有自己的一套对于电信号的解读方式，后来随着时间的推移，一种叫做<code>以太网</code>(Ethernet)的协议，占据了主导地位。</p>
<p><strong>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</strong></p>
<p><img src="http://img.blog.csdn.net/20161105231008204" alt="以太网数据包"></p>
<p><code>标头</code>包含数据包的一些说明项，比如发送者、接受者、数据类型等等；<code>数据</code>则是数据包的具体内容。</p>
<p><code>标头</code>的长度，固定为18字节。<code>数据</code>的长度，最短为46字节，最长为1500字节。因此，整个<code>帧</code>最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个<code>帧</code>进行发送。</p>
<h4 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h4><p>我想在日常上网过程中，最为熟悉的就是用一根网线连接端口和电脑了吧，网线连接电脑实际上是连接的这个玩意儿：</p>
<p><img src="http://img.blog.csdn.net/20161105225723932" alt="网卡"></p>
<p>上面就是我们所说的网卡了，它在物理层和数据链路层两个层级工作，正所谓能力越大责任越大，网卡的重要性自然不言而喻了。前面说，以太网规定每一个数据包都有一个<code>标头</code>（Head）来说明发送者，接受者信息，数据类型等信息。而网卡就是以太网规定的来标明发送者和接受者信息的工具。</p>
<p><strong>网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</strong></p>
<p>这个Mac地址自然就是发送者，接受者信息的了，通过这个每台电脑独一无二的地址计算机就能通过一些方式找到另一台电脑了。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<h4 id="3-4-广播"><a href="#3-4-广播" class="headerlink" title="3.4 广播"></a>3.4 广播</h4><p>我们现在有了网卡，也知道每一块网卡都有一个世界上独一无二的Mac地址，那发送者应该怎么去找接受者这台设备呢，换句话说发送者怎么才能知道接受者的Mac地址呢？这就需要另一个协议了叫做ARP协议，这个协议留在后面介绍。这里我们只需要知道，发送者必须要知道接受者的Mac地址才能准确的发送数据。</p>
<p>以太网采用了一种广撒网的方式，发送者发送的数据包会发送给本网络内所有的计算机，然后由接收到数据包的计算机来判断自己是不是接收方。</p>
<p><img src="http://img.blog.csdn.net/20161105192250885" alt="广播"></p>
<p>图片来自<a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF" target="_blank" rel="external">维基百科广播</a>)，如图所示，红色主机是发送方，绿色某一台是接收方，数据包会发送给同一个子网络的所有绿色主机，然后由绿色主机根据数据包的标头来判断自己是不是接收方。如果是，就接受这个包，不是则丢弃。这种发送数据的方式就是<code>广播</code>。</p>
<p>综上，有了对于数据包的定义，网卡的Mac地址，广播的发送方式，数据链路层基本就算完整了，然后不同计算机之间就可以传送数据了。</p>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><blockquote>
<p>网络层使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。  ——<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82" target="_blank" rel="external">网络层(维基百科)</a></p>
</blockquote>
<h4 id="4-1-网络层的产生"><a href="#4-1-网络层的产生" class="headerlink" title="4.1 网络层的产生"></a>4.1 网络层的产生</h4><p>走到这里我们实现的只是在一个子网络里传送数据。但我们知道，互联网实际上是由大大小小的子网络组成的：</p>
<p><img src="http://it.dgzx.net/zxkt/gaoerji/2005-2006-1N/images/lesson06_01.gif" alt="互联网"></p>
<p>大到一个ISP（因特网服务提供商，国内较大的比如移动电信等），小到一个公司的局域网，正事这些大大小小的子网络组成了庞大的互联网体系。但实际上，广播的方式只能在子网络内进行，不同子网络之间广播方式是行不通的。</p>
<p>因此我们需要一种方法能够判断两台主机是否在同一个子网络之内，如果在同一个子网络就以广播的方式传输数据，如果不在同一个子网络就以<code>路由</code>的方式传输（路由是个比较大的概念，本文不涉及），关于路由协议的了解<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">戳这里</a>，MAC地址做不到这一点，它只和厂商有关，和计算机所处的网络并没有关系。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>网址的出现，使得每台计算机都有了两个地址，一个是出生就带着不会改变的Mac地址，一个是后期网络管理员分配的可变的网络地址。网址判断两台计算机是否在同一个子网络，Mac地址则是将数据准确的传递到目标计算机中。因此逻辑上可以判断必定是先处理网络地址，再处理Mac地址。</p>
<h4 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2  IP协议"></a>4.2  IP协议</h4><p><strong>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</strong></p>
<p>现在广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成，IPV6则是64个二进制组成。</p>
<p><img src="http://img.blog.csdn.net/20161105200554600" alt="IP地址"></p>
<p>由于IPV6还没有广泛应用，这里还是用IPV4讲解。一般我们用分成四段（IPV6分成八段）的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。这个地址分成两部分，前一部分是网络部分，后一部分代表主机。But!!!网络部分具体是前16位还是前24位，我们没法从IP地址进行判断，这是我们就需要另一参数叫做<code>子网掩码</code>。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p>那么问题来了，IP地址放在哪里存储呢？是的，我们可以直接存储在前面提到的以太网数据包的Data部分。</p>
<p>IP地址长这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231405610" alt="IP数据包"></p>
<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。<br>现在把它加到以太网数据包里面：</p>
<p><img src="http://img.blog.csdn.net/20161105231536033" alt="以太网数据包"></p>
<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h4 id="4-3-ARP协议"><a href="#4-3-ARP协议" class="headerlink" title="4.3 ARP协议"></a>4.3 ARP协议</h4><p>现在为止我们必须知道两个地址，一个是IP地址，一个是Mac地址才能把数据发送到目标主机，那么IP地址是已知的（后文解释），MAC地址怎么获取呢？</p>
<p>我们需要一种能通过IP地址得知MAC地址的机制，这个极致就是ARP协议。</p>
<p>那么，这里又分成两种情况，一种是两台计算机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
<p>另一种情况是两台计算机不在同一个子网络，<br>那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关（后文解释）去处理。</p>
<h4 id="4-4总结"><a href="#4-4总结" class="headerlink" title="4.4总结"></a>4.4总结</h4><p>这一层为止，如果目标主机和本机在同一个子网络，我们通过IP地址，子网掩码比较得出在同一个子网络的结果，在通过ARP协议得到目标主机的Mac地址，发送！Success！</p>
<p>如果目标主机和本机不在同一个子网络，我们通过IP地址，子网掩码比较得出在同一个子网络的结果，然后交给本网络的网关A处理，网关A根据路由协议得到目标主机所在子网络的网关B，网关B再通过IP地址判断得出和目标主机在同一个子网络，然后再通过ARP协议获取Mac地址，发送！Success!</p>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h3><blockquote>
<p>该层的协议为应用进程提供端到端的通信服务。它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。——<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="external">传输层（维基百科）</a></p>
</blockquote>
<h4 id="5-1-传输层的产生"><a href="#5-1-传输层的产生" class="headerlink" title="5.1 传输层的产生"></a>5.1 传输层的产生</h4><p>我们现在成功的实现了主机和主机之间的通信，那么问题又来了，主机之间不同的程序该怎么区分这个数据是不是发送给自己的呢。要知道，当你正在QQ聊天的时候，微信发送过来的消息内容呈现在了QQ界面，这会让计算机懵逼的！太混乱了！</p>
<p>这个时候我们就需要一个新的参数了！这个参数就是<code>端口</code>。</p>
<blockquote>
<p>可连接两个或两个以上不同之电路装置使之能够传递电子或任何形式讯号之装置.——<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">端口（维基百科）</a></p>
</blockquote>
<p>它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>不同的程序在计算机中所占用的端口是不同的，确切的说是不能相同的，否则就混乱了。比如，HTTP所占用的端口一般是80，HTTPS所占用的端口一般是443。</p>
<p><code>端口</code>是0到65535之间的一个整数，正好16个二进制位。0到1023的<code>端口</code>被系统占用，用户只能选用大于1023的<code>端口</code>。不管是浏览网页还是在线聊天，应用程序会随机选用一个<code>端口</code>，然后与服务器的相应<code>端口</code>联系。</p>
<p><strong>确切的说，传输层实现的是端对端的服务，网络层实现的仅仅是主机到主机之间的服务。</strong>只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。</p>
<h4 id="5-2-UDP协议"><a href="#5-2-UDP协议" class="headerlink" title="5.2 UDP协议"></a>5.2 UDP协议</h4><p>现在又出了一个新的数据，就是端口信息。现在以太网数据包里已经包括发送者，接受者信息，数据类型，IP地址数据包，UDp数据包。</p>
<p>UDP数据包同样是由标头和数据组成：</p>
<p><img src="http://img.blog.csdn.net/20161105231649143" alt="UDP数据包"></p>
<p><code>标头</code>部分主要定义了发出端口和接收端口，<br><code>数据</code>部分定义了具体的内容。然后把它放在IP地址数据包的数据部分，前面我们说过IP数据包是放在以太网数据包的数据里面的，那么现在整个以太网数据包就成了这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231743213" alt="以太网数据包"></p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，一个IP数据包正好可以容纳。</p>
<h4 id="5-3-TCP协议"><a href="#5-3-TCP协议" class="headerlink" title="5.3 TCP协议"></a>5.3 TCP协议</h4><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。<br>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<p>关于TCP协议的三次握手和四次挥手过程博主在<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>这篇博客里有较为详细的说明。</p>
<h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h3><blockquote>
<p>应用层直接和应用程序接口并提供常见的网络应用服务。 ——<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="external">应用层（维基百科）</a></p>
</blockquote>
<h4 id="6-1-应用层介绍"><a href="#6-1-应用层介绍" class="headerlink" title="6.1 应用层介绍"></a>6.1 应用层介绍</h4><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样：</p>
<p><img src="http://img.blog.csdn.net/20161105231821409" alt="以太网数据包"></p>
<p>上面买的坑改填了，我们前面说过，我们对于目标主机的IP地址肯定知道的，为什么呢？还有就是当两台计算机不在同一个子网络的时候，我们需要通过本机所在子网络的网关A，再通过路由协议得到目标主机子网络的网关B，由网关B将我们要发送给目标主机的数据包发送给目标主机。那么，网关又是什么呢？</p>
<h4 id="6-2-DNS协议"><a href="#6-2-DNS协议" class="headerlink" title="6.2 DNS协议"></a>6.2 DNS协议</h4><p>我们都知道由于IP地址不方便记忆，我们创造了域名这个概念。</p>
<p>DNS（网域名称系统，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<p>例如，damonare.cn是一个域名，和IP地址119.29.180.47相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打damonare的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如 damonare.cn）转化成便于机器识别的IP地址（如119.29.180.47）。</p>
<p>已知DNS服务器为8.8.8.8（这个和IP地址一样管理员告知或是通过自行设置的），于是我们向这个地址发送一个DNS数据包（53端口）：</p>
<p><img src="http://img.blog.csdn.net/20161105231856550" alt="以太网数据包"></p>
<p>DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p>
<h4 id="6-2-网关"><a href="#6-2-网关" class="headerlink" title="6.2 网关"></a>6.2 网关</h4><blockquote>
<p>网关要区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（英语：Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。</p>
</blockquote>
<p><img src="http://image.beekka.com/blog/201206/bg2012061101.jpg" alt="网关作用"></p>
<p>前面我们已经说过发送以太网数据包，需要知道两个地址：</p>
<ul>
<li>对方的MAC地址</li>
<li>对方的IP地址</li>
</ul>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>
<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>
<h4 id="6-3-DHCP协议"><a href="#6-3-DHCP协议" class="headerlink" title="6.3 DHCP协议"></a>6.3 DHCP协议</h4><p>新买的电脑通常你必须做一些设置，才能上网，有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。如下图Window静态IP上网设置界面：</p>
<p><img src="http://nic.ysu.edu.cn/images/13/03/18/44mhv9wgmi/20112261000564.gif" alt=""></p>
<p>这样的设置很专业，但普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>
<p>动态IP地址上网使用的协议就是<code>DHCP协议</code>，这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的<code>MAC地址</code>和<code>IP地址</code>，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p><code>DHCP协议</code>做了一些巧妙的规定。</p>
<p>首先DHCP协议是建立在UDP协议之上，所以整个数据包是这样的：</p>
<p><img src="http://img.blog.csdn.net/20161105231939732" alt="以太网数据包"></p>
<ul>
<li>(1).最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</li>
<li>(2).后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</li>
<li>(3).最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</li>
</ul>
<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>
<p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
<h4 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h4><p>应用层比较重要的协议还有大名鼎鼎的HTTP协议，这个在博主的<a href="http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more">网络协议分析</a>这篇博客里对于TCP/HTTP协议有较为详细的分析，在这里就不多做介绍了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过整篇博客分析，我想整个互联网的层级划分就很清楚了，也应该明白了数据是如何发送的，大概的过程就是如此，但互联网协议浩如烟海究极一生可能也无法真正理解。此篇博客仅仅作为一个入门，也算是一个大致的思路。关于数据包数据具体的形式，路由，以及其他协议就需要读者自己去进一步发掘理解了。</p>
<p>参考文章：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">互联网协议入门（一）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 博主之前写过一篇博客：&lt;a href=&quot;http://damonare.github.io/2016/09/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#more&quot;&gt;网络协议分析&lt;/a&gt;,在这篇博客里通过抓包，具体的分析了不同网络协议的传送的数据和传送的方式。而此篇博客则用来作为一个大纲式的内容，按照层级划分，逐步介绍各层级的协议以及他们所起的作用。若有错误之处，欢迎批评指正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/05/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/#more&quot;&gt;internet协议入门&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;劳于读书，逸于作文。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="网络协议" scheme="http://damonare.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="HTTP" scheme="http://damonare.github.io/tags/HTTP/"/>
    
      <category term="TCP" scheme="http://damonare.github.io/tags/TCP/"/>
    
      <category term="IP" scheme="http://damonare.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ES6 核心功能一览</title>
    <link href="http://damonare.github.io/2016/11/03/JavaScript%20ES6%20%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A7%88/"/>
    <id>http://damonare.github.io/2016/11/03/JavaScript ES6 核心功能一览/</id>
    <published>2016-11-03T13:22:28.392Z</published>
    <updated>2016-11-26T10:04:59.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文属于转载文章</p>
</blockquote>
<ul>
<li>原文地址：<a href="http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/" target="_blank" rel="external">Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)</a></li>
<li>原文作者：<a href="http://adrianmejia.com/#about" target="_blank" rel="external">Adrian Mejia</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/L9m" target="_blank" rel="external">L9m</a></li>
<li>校对者：<a href="https://github.com/Tina92" target="_blank" rel="external">Tina92</a>，<a href="https://github.com/luoyaqifei" target="_blank" rel="external">luoyaqifei</a>，<a href="https://github.com/theJian" target="_blank" rel="external">theJian</a></li>
</ul>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）"><a href="#JavaScript-ES6-核心功能一览（ES6-亦作-ECMAScript-6-或-ES2015-）" class="headerlink" title="JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）"></a>JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+）</h3><p>JavaScript 在过去几年里发生了很大的变化。这里介绍 12 个你马上就能用的新功能。</p>
<h3 id="JavaScript-历史"><a href="#JavaScript-历史" class="headerlink" title="JavaScript 历史"></a>JavaScript 历史</h3><p>新的语言规范被称作 ECMAScript 6。也称为 ES6 或 ES2015+ 。</p>
<p>自从 1995 年 JavaScript 诞生以来，它一直在缓慢地发展。每隔几年就会增加一些新内容。1997 年，ECMAScript 成为 JavaScript 语言实现的规范。它已经有了好几个版本，比如 ES3 , ES5 , ES6 等等。</p>
<p><img src="http://adrianmejia.com/images/history-javascript-evolution-es6.png" alt="" title="JavaScript 发展史"></p>
<p>如你所见，ES3，ES5 和 ES6 之间分别存在着 10 年和 6 年的间隔。像 ES6 那样一次进行大幅修改的模式被逐年渐进式的新模式所替代。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>所有现代浏览器和环境都已支持 ES6。</p>
<p><img src="http://adrianmejia.com/images/es6-javascript-support.png" alt="" title="ES6 Support"></p>
<p>来源: <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a></p>
<p>Chrome，MS Edge，Firefox，Safari，Node 和许多其他的环境都已内置支持大多数的 JavaScript ES6 功能。所以，在本教程中你学到的每个知识，你都可以马上开始应用。</p>
<p>让我们开始学习 ECMAScript 6 吧！</p>
<h3 id="核心-ES6-功能"><a href="#核心-ES6-功能" class="headerlink" title="核心 ES6 功能"></a>核心 ES6 功能</h3><p>你可以在浏览器的控制台中测试所有下面的代码片段。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-classes-on-browser-console.png" alt="" title="Testing Javascript ES6 classes on browser console"></p>
<p>不要笃信我的话，而是要亲自去测试每一个 ES5 和 ES6 示例。让我们开始动手吧 💪</p>
<h4 id="变量的块级作用域"><a href="#变量的块级作用域" class="headerlink" title="变量的块级作用域"></a>变量的块级作用域</h4><p>使用 ES6，声明变量我们可以用 <code>var</code> ，也可以用 <code>let</code> 或 <code>const</code>。</p>
<p><code>var</code> 有什么不足？</p>
<p>使用 <code>var</code> 的问题是变量会漏入其他代码块中，诸如 <code>for</code> 循环或 <code>if</code> 代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">  if (inner) &#123;</div><div class="line">    var x = &apos;inner&apos;; // 作用于整个 function</div><div class="line">    return x;</div><div class="line">  &#125;</div><div class="line">  return x; // 因为第四行的声明提升，被重新定义</div><div class="line">&#125;</div><div class="line">test(false); // undefined 😱</div><div class="line">test(true); // inner</div></pre></td></tr></table></figure>
<p>对于 <code>test(fasle)</code> ，你期望返回 <code>outer</code>，<strong>但是</strong>，你得到的是 <code>undefined</code>。</p>
<p>为什么？</p>
<p>因为尽管没有执行 <code>if</code> 代码块，第四行中的表达式 <code>var x</code> 也会被提升。</p>
<blockquote>
<p>var <strong>提升</strong>：</p>
<ul>
<li><code>var</code> 是函数作用域。在整个函数中甚至是声明语句之前都是可用的。</li>
<li>声明被提升。所以你能在声明之前使用一个变量。</li>
<li>初始化是不被提升的。如果你使用 <code>var</code> 声明变量，请总是将它放在顶部。</li>
<li>在应用了声明提升规则之后，我们就能更容易地理解发生了什么：</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">    var x; // 声明提升</div><div class="line">    if (inner) &#123;</div><div class="line">        x = &apos;inner&apos;; // 初始化不被提升</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>ECMAScript 2015 找到了解决的办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">let x = &apos;outer&apos;;</div><div class="line">function test(inner) &#123;</div><div class="line">  if (inner) &#123;</div><div class="line">    let x = &apos;inner&apos;;</div><div class="line">    return x;</div><div class="line">  &#125;</div><div class="line">  return x; // 从第一行获取到预期结果</div><div class="line">&#125;</div><div class="line">test(false); // outer</div><div class="line">test(true); // inner</div></pre></td></tr></table></figure>
<p>将 <code>var</code> 改为 <code>let</code>，代码将像期望的那样运行。如果 <code>if</code> 代码块没有被调用，<code>x</code> 变量也就不会在代码块外被提升。</p>
<blockquote>
<p>let <strong>提升</strong> 和“暂存死区（temporal dead zone）”</p>
<ul>
<li>在 ES6 中，<code>let</code> 将变量提升到代码块的顶部（不是像 ES5 那样的函数顶部）。</li>
<li>然而，代码块中，在变量声明之前引用它会导致 <code>ReferenceError</code> 错误。</li>
<li><code>let</code> 是块级作用域。你不能在它被声明之前引用它。</li>
<li>“暂存死区（Temporal dead zone）”是指从代码块开始直到变量被声明之间的区域。</li>
</ul>
</blockquote>
<p><strong>IIFE</strong></p>
<p>在解释 IIFE 之前让我们看一个例子。来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">&#123;</div><div class="line">  var private = 1;</div><div class="line">&#125;</div><div class="line">console.log(private); // 1</div></pre></td></tr></table></figure>
<p>如你所见，<code>private</code> 漏出(代码块)。你需要使用 IIFE（immediately-invoked function expression，立即执行函数表达式）来包含它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">(function()&#123;</div><div class="line">  var private2 = 1;</div><div class="line">&#125;)();</div><div class="line">console.log(private2); // Uncaught ReferenceError</div></pre></td></tr></table></figure>
<p>如果你看一看 jQuery/loadsh 或其他开源项目，你会注意到他们用 IIFE 来避免污染全局环境而且只在全局中定义了诸如 <code>_</code>，<code>$</code>和<code>jQuery</code>。</p>
<p>在 ES6 上则一目了然，我们可以只用代码块和 <code>let</code>，也不再需要使用 IIFE了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">&#123;</div><div class="line">  let private3 = 1;</div><div class="line">&#125;</div><div class="line">console.log(private3); // Uncaught ReferenceError</div></pre></td></tr></table></figure>
<p><strong>Const</strong></p>
<p>如果你想要一个变量保持不变（常量），你也可以使用 <code>const</code>。</p>
<p><img src="http://adrianmejia.com/images/javascript-es6-const-variables-example.png" alt="" title="const variable example"></p>
<blockquote>
<p>总之：用 <code>let</code>，<code>const</code> 而不是 <code>var</code></p>
<ul>
<li>对所有引用使用 <code>const</code>；避免使用 <code>var</code>。</li>
<li>如果你必须重新指定引用，用 <code>let</code> 替代 <code>const</code>。</li>
</ul>
</blockquote>
<h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>有了模板字面量，我们就不用做多余的嵌套拼接了。来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var first = &apos;Adrian&apos;;</div><div class="line">var last = &apos;Mejia&apos;;</div><div class="line">console.log(&apos;Your name is &apos; + first + &apos; &apos; + last + &apos;.&apos;);</div></pre></td></tr></table></figure>
<p>现在你可以使用反引号 (`) 和字符串插值 <code>${}</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const first = &apos;Adrian&apos;;</div><div class="line">const last = &apos;Mejia&apos;;</div><div class="line">console.log(`Your name is $&#123;first&#125; $&#123;last&#125;.`);</div></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>我们再也不需要添加 + <code>\n</code> 来拼接字符串了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var template = &apos;&lt;li *ngFor=&quot;let todo of todos&quot; [ngClass]=&quot;&#123;completed: todo.isDone&#125;&quot; &gt;\n&apos; +</div><div class="line">&apos;  &lt;div class=&quot;view&quot;&gt;\n&apos; +</div><div class="line">&apos;    &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; [checked]=&quot;todo.isDone&quot;&gt;\n&apos; +</div><div class="line">&apos;    &lt;label&gt;&lt;/label&gt;\n&apos; +</div><div class="line">&apos;    &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;\n&apos; +</div><div class="line">&apos;  &lt;/div&gt;\n&apos; +</div><div class="line">&apos;  &lt;input class=&quot;edit&quot; value=&quot;&quot;&gt;\n&apos; +</div><div class="line">&apos;&lt;/li&gt;&apos;;</div><div class="line">console.log(template);</div></pre></td></tr></table></figure>
<p>在 ES6 上， 我们可以同样使用反引号来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const template = `&lt;li *ngFor=&quot;let todo of todos&quot; [ngClass]=&quot;&#123;completed: todo.isDone&#125;&quot; &gt;</div><div class="line">  &lt;div class=&quot;view&quot;&gt;</div><div class="line">    &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; [checked]=&quot;todo.isDone&quot;&gt;</div><div class="line">    &lt;label&gt;&lt;/label&gt;</div><div class="line">    &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;input class=&quot;edit&quot; value=&quot;&quot;&gt;</div><div class="line">&lt;/li&gt;`;</div><div class="line">console.log(template);</div></pre></td></tr></table></figure>
<p>两段代码的结果是完全一样的。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>ES6 的解构不仅实用而且很简洁。如下例所示：</p>
<p><strong>从数组中获取元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var array = [1, 2, 3, 4];</div><div class="line">var first = array[0];</div><div class="line">var third = array[2];</div><div class="line">console.log(first, third); // 1 3</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const array = [1, 2, 3, 4];</div><div class="line">const [first, ,third] = array;</div><div class="line">console.log(first, third); // 1 3</div></pre></td></tr></table></figure>
<p><strong>交换值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var a = 1;</div><div class="line">var b = 2;</div><div class="line">var tmp = a;</div><div class="line">a = b;</div><div class="line">b = tmp;</div><div class="line">console.log(a, b); // 2 1</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">let a = 1;</div><div class="line">let b = 2;</div><div class="line">[a, b] = [b, a];</div><div class="line">console.log(a, b); // 2 1</div></pre></td></tr></table></figure>
<p><strong>多个返回值的解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function margin() &#123;</div><div class="line">  var left=1, right=2, top=3, bottom=4;</div><div class="line">  return &#123; left: left, right: right, top: top, bottom: bottom &#125;;</div><div class="line">&#125;</div><div class="line">var data = margin();</div><div class="line">var left = data.left;</div><div class="line">var bottom = data.bottom;</div><div class="line">console.log(left, bottom); // 1 4</div></pre></td></tr></table></figure>
<p>在第 3 行中，你也可以用一个像这样的数组返回（同时省去了一些编码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return [left, right, top, bottom];</div></pre></td></tr></table></figure>
<p>但另一方面，调用者需要考虑返回数据的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var left = data[0];</div><div class="line">var bottom = data[3];</div></pre></td></tr></table></figure>
<p>用 ES6，调用者只需选择他们需要的数据即可（第 6 行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line"></div><div class="line">function margin() &#123;</div><div class="line">  const left=1, right=2, top=3, bottom=4;</div><div class="line">  return &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; left, bottom &#125; = margin();</div><div class="line">console.log(left, bottom); // 1 4</div></pre></td></tr></table></figure>
<p><em>注意：</em> 在第 3 行中，我们使用了一些其他的 ES6 功能。我们将 <code>{ left: left }</code> 简化到只有 <code>{ left }</code>。与 ES5 版本相比，它变得如此简洁。酷不酷？</p>
<p><strong>参数匹配的解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var user = &#123;firstName: &apos;Adrian&apos;, lastName: &apos;Mejia&apos;&#125;;</div><div class="line">function getFullName(user) &#123;</div><div class="line">  var firstName = user.firstName;</div><div class="line">  var lastName = user.lastName;</div><div class="line">  return firstName + &apos; &apos; + lastName;</div><div class="line">&#125;</div><div class="line">console.log(getFullName(user)); // Adrian Mejia</div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const user = &#123;firstName: &apos;Adrian&apos;, lastName: &apos;Mejia&apos;&#125;;</div><div class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</div><div class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</div><div class="line">&#125;</div><div class="line">console.log(getFullName(user)); // Adrian Mejia</div></pre></td></tr></table></figure>
<p><strong>深度匹配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function settings() &#123;</div><div class="line">  return &#123; display: &#123; color: &apos;red&apos; &#125;, keyboard: &#123; layout: &apos;querty&apos;&#125; &#125;;</div><div class="line">&#125;</div><div class="line">var tmp = settings();</div><div class="line">var displayColor = tmp.display.color;</div><div class="line">var keyboardLayout = tmp.keyboard.layout;</div><div class="line">console.log(displayColor, keyboardLayout); // red querty</div></pre></td></tr></table></figure>
<p>等同于（但更简洁）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function settings() &#123;</div><div class="line">  return &#123; display: &#123; color: &apos;red&apos; &#125;, keyboard: &#123; layout: &apos;querty&apos;&#125; &#125;;</div><div class="line">&#125;</div><div class="line">const &#123; display: &#123; color: displayColor &#125;, keyboard: &#123; layout: keyboardLayout &#125;&#125; = settings();</div><div class="line">console.log(displayColor, keyboardLayout); // red querty</div></pre></td></tr></table></figure>
<p>这也称作对象的解构。</p>
<p>如你所见，解构是非常实用的而且有利于促进良好的编码风格。</p>
<blockquote>
<p>最佳实践:</p>
<ul>
<li>使用数组解构去获取元素或交换值。它可以避免创建临时引用。</li>
<li>不要对多个返回值使用数组解构，而是要用对象解构。</li>
</ul>
</blockquote>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>用 ECMAScript 6，我们从“构造函数”🔨 来到了“类”🍸。</p>
<blockquote>
<p>在 JavaScript 中，每个对象都有一个原型对象。所有的 JavaScript 对象都从它们的原型对象那里继承方法和属性。</p>
</blockquote>
<p>在 ES5 中，为了实现面向对象编程（OOP），我们使用构造函数来创建对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var Animal = (function () &#123;</div><div class="line">  function MyConstructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  MyConstructor.prototype.speak = function speak() &#123;</div><div class="line">    console.log(this.name + &apos; makes a noise.&apos;);</div><div class="line">  &#125;;</div><div class="line">  return MyConstructor;</div><div class="line">&#125;)();</div><div class="line">var animal = new Animal(&apos;animal&apos;);</div><div class="line">animal.speak(); // animal makes a noise.</div></pre></td></tr></table></figure></p>
<p>ES6 中有了一些语法糖。通过像 <code>class</code> 和 <code>constructor</code> 这样的关键字和减少样板代码，我们可以做到同样的事情。另外，<code>speak()</code> 相对照 <code>constructor.prototype.speak = function ()</code>  更加清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">class Animal &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  speak() &#123;</div><div class="line">    console.log(this.name + &apos; makes a noise.&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const animal = new Animal(&apos;animal&apos;);</div><div class="line">animal.speak(); // animal makes a noise.</div></pre></td></tr></table></figure>
<p>正如你所见，两种式样（ES5 与 6）在幕后产生相同的结果而且用法一致。</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>总是使用 <code>class</code> 语法并避免直接直接操纵 <code>prototype</code>。为什么？因为它让代码更加简洁和易于理解。</li>
<li>避免使用空的构造函数。如果没有指定，类有一个默认的构造函数。</li>
</ul>
</blockquote>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>基于前面的 <code>Animal</code> 类。 让我们扩展它并定义一个 <code>Lion</code> 类。</p>
<p>在 ES5 中，它更多的与原型继承有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var Lion = (function () &#123;</div><div class="line">  function MyConstructor(name)&#123;</div><div class="line">    Animal.call(this, name);</div><div class="line">  &#125;</div><div class="line">  // 原型继承</div><div class="line">  MyConstructor.prototype = Object.create(Animal.prototype);</div><div class="line">  MyConstructor.prototype.constructor = Animal;</div><div class="line">  MyConstructor.prototype.speak = function speak() &#123;</div><div class="line">    Animal.prototype.speak.call(this);</div><div class="line">    console.log(this.name + &apos; roars 🦁&apos;);</div><div class="line">  &#125;;</div><div class="line">  return MyConstructor;</div><div class="line">&#125;)();</div><div class="line">var lion = new Lion(&apos;Simba&apos;);</div><div class="line">lion.speak(); // Simba makes a noise.</div><div class="line">// Simba roars.</div></pre></td></tr></table></figure>
<p>我不会重复所有的细节，但请注意：</p>
<ul>
<li>第 3 行中，我们添加参数显式调用了 <code>Animal</code> 构造函数。</li>
<li>第 7-8 行，我们将 <code>Lion</code> 原型指派给 <code>Animal</code> 原型。</li>
<li>第 11行中，我们调用了父类 <code>Animal</code> 的 <code>speak</code> 方法。</li>
</ul>
<p>在 ES6 中，我们有了新关键词 <code>extends</code> 和 <code>super</code> <img src="http://adrianmejia.com/images/superman_shield.svg" width="25" height="25" alt="superman shield" style="display:inline-block;" data-pin-nopin="true">。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">class Lion extends Animal &#123;</div><div class="line">  speak() &#123;</div><div class="line">    super.speak();</div><div class="line">    console.log(this.name + &apos; roars 🦁&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const lion = new Lion(&apos;Simba&apos;);</div><div class="line">lion.speak(); // Simba makes a noise.</div><div class="line">// Simba roars.</div></pre></td></tr></table></figure>
<p>虽然 ES6 和 ES5 的代码作用一致，但是 ES6 的代码显得更易读。更胜一筹！</p>
<blockquote>
<p>最佳实践：</p>
<ul>
<li>使用  <code>extends</code> 内置方法实现继承。</li>
</ul>
</blockquote>
<h4 id="原生-Promises"><a href="#原生-Promises" class="headerlink" title="原生 Promises"></a>原生 Promises</h4><p>从回调地狱 👹 到 promises 🙏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function printAfterTimeout(string, timeout, done)&#123;</div><div class="line">  setTimeout(function()&#123;</div><div class="line">    done(string);</div><div class="line">  &#125;, timeout);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(&apos;Hello &apos;, 2e3, function(result)&#123;</div><div class="line">  console.log(result);</div><div class="line">  // 嵌套回调</div><div class="line">  printAfterTimeout(result + &apos;Reader&apos;, 2e3, function(result)&#123;</div><div class="line">    console.log(result);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们有一个接收一个回调的函数，当 <code>done</code> 时执行。我们必须一个接一个地执行它两次。这也是为什么我们在回调中第二次调用  <code>printAfterTimeout</code> 的原因。</p>
<p>如果你需要第 3 次或第 4 次回调，可能很快就会变得混乱。来看看我们用 promises 的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function printAfterTimeout(string, timeout)&#123;</div><div class="line">  return new Promise((resolve, reject) =&gt; &#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      resolve(string);</div><div class="line">    &#125;, timeout);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">printAfterTimeout(&apos;Hello &apos;, 2e3).then((result) =&gt; &#123;</div><div class="line">  console.log(result);</div><div class="line">  return printAfterTimeout(result + &apos;Reader&apos;, 2e3);</div><div class="line">&#125;).then((result) =&gt; &#123;</div><div class="line">  console.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如你所见，使用 promises 我们能在函数完成后进行一些操作。不再需要嵌套函数。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 没有移除函数表达式，但是新增了一种，叫做箭头函数。</p>
<p>在 ES5 中，对于 <code>this</code> 我们有一些问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var _this = this; // 保持一个引用</div><div class="line">$(&apos;.btn&apos;).click(function(event)&#123;</div><div class="line">  _this.sendData(); // 引用的是外层的 this</div><div class="line">&#125;);</div><div class="line">$(&apos;.input&apos;).on(&apos;change&apos;,function(event)&#123;</div><div class="line">  this.sendData(); // 引用的是外层的 this</div><div class="line">&#125;.bind(this)); // 绑定到外层的 this</div></pre></td></tr></table></figure>
<p>你需要使用一个临时的 <code>this</code> 在函数内部进行引用或用 <code>bind</code> 绑定。在 ES6 中，你可以用箭头函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">// 引用的是外部的那个 this</div><div class="line">$(&apos;.btn&apos;).click((event) =&gt;  this.sendData());</div><div class="line">// 隐式返回</div><div class="line">const ids = [291, 288, 984];</div><div class="line">const messages = ids.map(value =&gt; `ID is $&#123;value&#125;`);</div></pre></td></tr></table></figure>
<h4 id="For…of"><a href="#For…of" class="headerlink" title="For…of"></a>For…of</h4><p>从 <code>for</code> 到 <code>forEach</code> 再到 <code>for...of</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">// for</div><div class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">for (var i = 0; i &lt; array.length; i++) &#123;</div><div class="line">  var element = array[i];</div><div class="line">  console.log(element);</div><div class="line">&#125;</div><div class="line">// forEach</div><div class="line">array.forEach(function (element) &#123;</div><div class="line">  console.log(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ES6 的 for…of 同样可以实现迭代。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">// for ...of</div><div class="line">const array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">for (const element of array) &#123;</div><div class="line">    console.log(element);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>从检查一个变量是否被定义到重新指定一个值再到 <code>default parameters</code>。<br>你以前写过类似这样的代码吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function point(x, y, isFlag)&#123;</div><div class="line">  x = x || 0;</div><div class="line">  y = y || -1;</div><div class="line">  isFlag = isFlag || true;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 -1 true 😱</div><div class="line">point(0, 0, false) // 0 -1 true 😱😱</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>可能有过，这是一种检查变量是否赋值的常见模式，不然则分配一个默认值。然而，这里有一些问题：</p>
<ul>
<li>第 8 行中，我们传入 <code>0, 0</code> 返回了 <code>0, -1</code>。</li>
<li>第 9 行中， 我们传入 <code>false</code> 但是返回了 <code>true</code>。</li>
</ul>
<p>如果你传入一个布尔值作为默认参数或将值设置为 0，它不能正常起作用。你知道为什么吗？在讲完 ES6 示例后我会告诉你。</p>
<p>用 ES6，现在你可以用更少的代码做到更好！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function point(x = 0, y = -1, isFlag = true)&#123;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 0 true</div><div class="line">point(0, 0, false) // 0 0 false</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>请注意第 5 行和第 6 行，我们得到了预期的结果。ES5 示例则无效。首先检查是否等于 <code>undefined</code>，因为 <code>false</code>，<code>null</code>，<code>undefined</code> 和 <code>0</code> 都是假值，我们可以避开这些数字，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function point(x, y, isFlag)&#123;</div><div class="line">  x = x || 0;</div><div class="line">  y = typeof(y) === &apos;undefined&apos; ? -1 : y;</div><div class="line">  isFlag = typeof(isFlag) === &apos;undefined&apos; ? true : isFlag;</div><div class="line">  console.log(x,y, isFlag);</div><div class="line">&#125;</div><div class="line">point(0, 0) // 0 0 true</div><div class="line">point(0, 0, false) // 0 0 false</div><div class="line">point(1) // 1 -1 true</div><div class="line">point() // 0 -1 true</div></pre></td></tr></table></figure>
<p>当我们检查是否为 <code>undefined</code> 后，获得了期望的结果。</p>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>从参数到剩余参数和扩展操作符。</p>
<p>在 ES5 中，获取任意数量的参数是非常麻烦的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">function printf(format) &#123;</div><div class="line">  var params = [].slice.call(arguments, 1);</div><div class="line">  console.log(&apos;params: &apos;, params);</div><div class="line">  console.log(&apos;format: &apos;, format);</div><div class="line">&#125;</div><div class="line">printf(&apos;%s %d %.2f&apos;, &apos;adrian&apos;, 321, Math.PI);</div></pre></td></tr></table></figure>
<p>我们可以用 rest 操作符 <code>...</code> 做到同样的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line"></div><div class="line">function printf(format, ...params) &#123;</div><div class="line">  console.log(&apos;params: &apos;, params);</div><div class="line">  console.log(&apos;format: &apos;, format);</div><div class="line">&#125;</div><div class="line">printf(&apos;%s %d %.2f&apos;, &apos;adrian&apos;, 321, Math.PI);</div></pre></td></tr></table></figure>
<h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>从 <code>apply()</code> 到展开运算符。我们同样用 <code>...</code> 来解决：</p>
<blockquote>
<p>提醒：我们使用 <code>apply()</code> 将数组转换为一列参数。例如，<code>Math.max()</code> 作用于一列参数，但是如果我们有一个数组，我们就能用 <code>apply</code> 让它生效。</p>
</blockquote>
<p><img src="http://adrianmejia.com/images/javascript-math-apply-arrays.png" alt="" title="JavaScript Math apply for arrays"></p>
<p>正如我们较早之前看过的，我们可以使用 <code>apply</code> 将数组作为参数列表传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">Math.max.apply(Math, [2,100,1,6,43]) // 100</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">Math.max(...[2,100,1,6,43]) // 100</div></pre></td></tr></table></figure>
<p>同样，从 <code>concat</code> 数组到使用展开运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">var array1 = [2,100,1,6,43];</div><div class="line">var array2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">var array3 = [false, true, null, undefined];</div><div class="line">console.log(array1.concat(array2, array3));</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以用展开运算符来压平嵌套：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">const array1 = [2,100,1,6,43];</div><div class="line">const array2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line">const array3 = [false, true, null, undefined];</div><div class="line">console.log([...array1, ...array2, ...array3]);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 经历了相当多的修改。这篇文章涵盖了每个 JavaScript 开发者都应该了解的大多数核心功能。同样，我们也介绍了一些让你的代码更加简洁，易于理解的最佳实践。</p>
<p>如果你认为还有一些没有提到的<strong>必知</strong>的功能，请在下方留言，我会更新这篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文属于转载文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;http://adrianmejia.com/blog/2016/10/19/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015/&quot;&gt;Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文作者：&lt;a href=&quot;http://adrianmejia.com/#about&quot;&gt;Adrian Mejia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/L9m&quot;&gt;L9m&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/Tina92&quot;&gt;Tina92&lt;/a&gt;，&lt;a href=&quot;https://github.com/luoyaqifei&quot;&gt;luoyaqifei&lt;/a&gt;，&lt;a href=&quot;https://github.com/theJian&quot;&gt;theJian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="转载" scheme="http://damonare.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="ES6" scheme="http://damonare.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript数据结构(一)——栈和队列</title>
    <link href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://damonare.github.io/2016/11/01/学习javascript数据结构（一）——栈和队列/</id>
    <published>2016-11-01T13:16:54.812Z</published>
    <updated>2017-01-16T07:52:08.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more">学习javascript数据结构(一)——栈和队列</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>只要你不计较得失，人生还有什么不能想法子克服的。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。javascript也有数组类型，而数组呢，其实就是一种特殊的栈或是队列，利用javascript&nbsp;Array所内置的API可以很方便的模拟栈和队列。</p>
<blockquote>
<p>我想对于数组每一个学过编程语言的都不会陌生吧，我们知道，我们可以在数组的任意位置添加或是删除元素，然而，有时候我们还需要一种在添加或是删除元素的时候有更多控制的数据结构。有两种数据结构类似于数组。但在添加或是删除元素的时候更为的可控。他们就是栈和队列。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或是待删除的元素都保存在栈的末尾。我们称作栈顶，而另一端我们称作栈底。</strong><br><br><br>在现实生活中就有很多栈的例子，比如下图的书本，这一摞书如果要取肯定是先去最上面的那一本，但它是最后一个放上去的，也就是栈顶的元素都是待添加或是待删除的。这就是后进先出的实际例子。<br></p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145616341" alt="栈"></p>
</blockquote>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><p>首先我们先创建一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//各种属性和方法的声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数据结构来保存栈里面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来，我们需要给栈声明一些方法：</p>
<ul>
<li>push(element):添加一个或是几个新元素到栈顶。</li>
<li>pop():移除栈顶的元素，同时返回被移除元素。</li>
<li>peek():返回栈顶的元素，但并不对栈顶的元素做出任何的修改。</li>
<li>isEmpty():检查栈内是否有元素，如果有返回true，没有返回false。</li>
<li>clear():清除栈里的元素。</li>
<li>size():返回栈的元素个数。</li>
<li>print():打印栈里的元素。</li>
</ul>
<h4 id="栈的完整代码"><a href="#栈的完整代码" class="headerlink" title="栈的完整代码"></a>栈的完整代码</h4><p>我们通过javascript提供的API，实现栈如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.pop();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[items.length<span class="number">-1</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.toString();</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _items = <span class="built_in">Symbol</span>();</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack2</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    push(element)&#123;</div><div class="line">        <span class="keyword">this</span>[_items].push(element);</div><div class="line">    &#125;</div><div class="line">    pop()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].pop();</div><div class="line">    &#125;</div><div class="line">    peek()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items][<span class="keyword">this</span>[_items].length<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    isEmpty()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    size()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].length;</div><div class="line">    &#125;</div><div class="line">    clear()&#123;</div><div class="line">        <span class="keyword">this</span>[_items] = [];</div><div class="line">    &#125;</div><div class="line">    print()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">    &#125;</div><div class="line">    toString()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[_items].toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>创建完了栈，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack=<span class="keyword">new</span> Stack();</div><div class="line"><span class="built_in">console</span>.log(stack.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">stack.push(<span class="number">1</span>);</div><div class="line">stack.push(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(stack.peek());</div><div class="line"><span class="comment">//输出栈顶元素3</span></div><div class="line"><span class="built_in">console</span>.log(stack.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<p>其余方法调用读者可自行尝试。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们已经接触了栈，接下来要说的队列和栈十分相似，他们都是线性表，元素都是有序的<br>。队列和栈不同的是，队列遵循的是FIFO，也就是先进先出的原则。队列从尾部添加新元素，从顶部移除元素，最新添加的元素必须排列在队列的末尾。<br><br><br>在现实生活中，最常见的队列就是排队，如下图，先进入队列的先接受服务，后进入队列的必须排在队列末尾。</p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20161102145601043" alt="队列"></p>
</blockquote>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><p>首先我们声明一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是队列的属性和方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们同样创建一个保存元素的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> items=[];</div></pre></td></tr></table></figure>
<p>接下来声明一些队列可用的方法：</p>
<ul>
<li>enqueue(element):向队列尾部添加一个（或是多个）元素。</li>
<li>dequeue():移除队列的第一个元素，并返回被移除的元素。</li>
<li>front():返回队列的第一个元素——最先被添加的也是最先被移除的元素。队列不做任何变动。</li>
<li>isEmpty():检查队列内是否有元素，如果有返回true，没有返回false。</li>
<li>size():返回队列的长度。</li>
<li>print():打印队列的元素。</li>
</ul>
<h4 id="队列的完整代码"><a href="#队列的完整代码" class="headerlink" title="队列的完整代码"></a>队列的完整代码</h4><p>我们通过javascript提供的API，实现队列如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.shift();</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6版本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Queue2 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue2</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span> () &#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        enqueue(element) &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            q.push(element);</div><div class="line">        &#125;</div><div class="line">        dequeue() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">let</span> r = q.shift();</div><div class="line">            <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        front() &#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        isEmpty()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).length == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        size()&#123;</div><div class="line">            <span class="keyword">let</span> q = items.get(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> q.length;</div><div class="line">        &#125;</div><div class="line">        clear()&#123;</div><div class="line">            items.set(<span class="keyword">this</span>, []);</div><div class="line">        &#125;</div><div class="line">        print()&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</div><div class="line">        &#125;</div><div class="line">        toString()&#123;</div><div class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Queue2;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>创建完了队列，也给他了方法，然后我们来实例化一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queue=<span class="keyword">new</span> Queue();</div><div class="line"><span class="built_in">console</span>.log(queue.isEmpty());</div><div class="line"><span class="comment">//true</span></div><div class="line">queue.enqueue(<span class="number">1</span>);</div><div class="line">queue.enqueue(<span class="number">3</span>);</div><div class="line"><span class="comment">//添加元素</span></div><div class="line"><span class="built_in">console</span>.log(queue.front());</div><div class="line"><span class="comment">//返回队列的第一个元素1</span></div><div class="line"><span class="built_in">console</span>.log(queue.size());</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//输出元素个数</span></div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>这篇博客使用javascript实现了栈和队列这两种数据结构。关于具体的应用的有机会补上。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文使用javascript数组的API定义了栈和队列并较为详细的说明了栈和队列的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/01/%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#more&quot;&gt;学习javascript数据结构(一)——栈和队列&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只要你不计较得失，人生还有什么不能想法子克服的。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构与算法" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>详解Javascript的类(单身狗请自觉进入)</title>
    <link href="http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/"/>
    <id>http://damonare.github.io/2016/11/01/详解javascript的类/</id>
    <published>2016-11-01T03:11:18.192Z</published>
    <updated>2016-11-26T09:45:40.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 本文详细讲述了javascript中类的由来实现以及一些类知识的延伸。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/#more">详解javascript的类</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>生活有度，人生添寿。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>&nbsp;&nbsp;Javascript从当初的一个“弹窗语言”，一步步发展成为现在前后端通吃的庞然大物。javascript的受欢迎程度也是与日俱增，今年最受欢迎编程语言又是花落javascript，这实在是一个充满了活力的语言。如今，随随便一个网页javascript代码量都不下数千行，要是node后端那更不止几千行了。（WTF）代码量的增加给编程带来的首要的问题就是如何去编写和维护如此庞大的代码呢？答案就是模块化思想，其实就是面向对象（OOP）编程，如今比较流行的三大前端框架（angular,react,vue）基本都实现了组件化编程，但组件化和我们所说的模块化又有所不同，应该可以这么理解，组件化是模块化的升级版，模块化是组件化的基础。那么，问题来了，javascript怎么面向对象编程呢？我想这很多老鸟也不定说的清楚吧，前端杂而活跃的各种社区，很多前端er一度依赖各种插件，根本不需要去了解这些深层的东西却照样能完成任务。但我想作为一个有追求的前端er还是很有必要去学习这些看似用不着的东西的，别的不说，就单单因为我们是前端er,只会用jquery一个稍微厉害的后端都能代替你。好吧，废话不多说，到底如何面向对象coding呢…..<br><br><br>&nbsp;&nbsp;很不幸，es5中并没有给出明确的定义‘类’的概念，所以传统的面向对象编程似乎是行不通的，那么又该肿么办呢？值得庆幸的是，前辈们通过不断探索总结，成功的用javascript模拟出了“类”。那么，javascript的类又该怎么定义呢？<br><br></p>
</blockquote>
<p><strong>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。</strong></p>
<blockquote>
<p>说到javascript中的“类”就不得不说原型链和继承了，因为javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。</p>
</blockquote>
<h4 id="1-原型链和继承"><a href="#1-原型链和继承" class="headerlink" title="1. 原型链和继承"></a>1. 原型链和继承</h4><p>“<br>    在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。<br>”<br></p>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><blockquote>
<p>实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。那么我们都是如何定义一个对象的呢，博主总结的方法如下几个：</p>
</blockquote>
<p>先初步来个demo具体解释下原型链是咋回事吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__  属性（现已弃用）。。从 ES6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个方法可以放心使用博主亲测，主流浏览器已经支持了</span></div><div class="line"><span class="comment">// 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下:</span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125;---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div></pre></td></tr></table></figure>
<p><strong>来来来，撸袖子搞出个对象！！！（马上狗节，单身狗请自觉阅读完此篇博客）</strong></p>
<ul>
<li><strong>使用普通方法来创建一个对象</strong></li>
</ul>
<p><strong>demo如下:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o=&#123;</div><div class="line">    a:<span class="number">0</span>,</div><div class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个对象</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//o---&gt;Object.prototype---&gt;null</span></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</div><div class="line"><span class="comment">//创建一个数组对象</span></div><div class="line"><span class="comment">//(indexOf, forEach等方法都是从它继承而来).</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//a---&gt;Array.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个函数对象</span></div><div class="line"><span class="comment">//(call, bind等方法都是从它继承而来):</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">//创建一个日期对象</span></div><div class="line"><span class="comment">//原型链如下：</span></div><div class="line"><span class="comment">//date---&gt;Date.prototype---&gt;Object.pprototype---&gt;null</span></div></pre></td></tr></table></figure>
<ul>
<li>使用构造函数的方法</li>
</ul>
<blockquote>
<p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。——MDN</p>
</blockquote>
<p><strong>demo如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.propA=<span class="string">'prop'</span>;</div><div class="line">    <span class="keyword">this</span>.propB=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">fun.prototype=&#123;</div><div class="line">    methodA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.propA)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> fun();</div><div class="line">o.methodA();<span class="comment">//prop</span></div><div class="line"></div><div class="line"><span class="comment">// o是生成的对象,他的自身属性有'propA'和'propB'.</span></div><div class="line"><span class="comment">// 在o被实例化时,o.[[Prototype]]指向了fun.prototype.</span></div></pre></td></tr></table></figure>
<ul>
<li>使用Object.create创建对象</li>
</ul>
<blockquote>
<p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;a: <span class="number">1</span>&#125;;</div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)继承概念下面会讲</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure>
<ul>
<li>使用 class 关键字</li>
</ul>
<blockquote>
<p>ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义一个类Polygon</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;<span class="comment">//使用super引用父类</span></div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用extends定义Squeare继承父类Polygon</span></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);<span class="comment">//实例对象</span></div><div class="line"></div><div class="line"><span class="comment">//此时的原型链为：</span></div><div class="line"><span class="comment">//square---&gt;Square.prototype---&gt;Polygon.prototype---&gt;Object.prototype---&gt;null</span></div><div class="line"><span class="comment">//如果不理解为什么是这样，不要紧接着往下看类的说明</span></div></pre></td></tr></table></figure>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>其实在上面讲原型链的时候难以避免的也提到了继承，比如来自MDN的这个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假定有一个对象 o, 其自身的属性（own properties）有 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.[[Prototype]]有属性 b 和 c：（someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__  属性（现已弃用）。。从 ES6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。）</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></div><div class="line"><span class="comment">// 综上，整个原型链如下:</span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></div><div class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></div><div class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></div><div class="line"><span class="comment">// o.[[Prototype]]上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></div><div class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.</span></div><div class="line"><span class="comment">// o.[[Prototype]].[[Prototype]]为null，停止搜索，</span></div><div class="line"><span class="comment">// 没有d属性，返回undefined</span></div></pre></td></tr></table></figure>
<p><strong>—-以上内容来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">MDN继承与原型链</a></strong></p>
<p>我想看到这里还是有些似懂非懂吧，那么来个例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object1=&#123;</div><div class="line">    a:<span class="number">1</span>,</div><div class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//定义一个对象</span></div><div class="line"><span class="keyword">var</span> object2=<span class="built_in">Object</span>.create(object1);</div><div class="line"><span class="comment">//调用Object.create来创建一个新对象,新对象的原型就是调用 create 方法时传入的第一个参数,现在的原型链是：</span></div><div class="line"><span class="comment">//object2---&gt;object1---&gt;object1.prototype---&gt;null</span></div><div class="line">object2.d=<span class="number">4</span>;</div><div class="line">object2.a;</div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="comment">//继承了object1的属性a</span></div><div class="line">object2.b();</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="comment">//继承了object1的方法b</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(object2);</div><div class="line"><span class="comment">//object1得到object2的原型object1</span></div></pre></td></tr></table></figure>
<p>我想现在应该是明白了吧，再不明白博主也是无能为力了，表达能力实在有限。</p>
<h4 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h4><blockquote>
<p>总算说到类了，由于javascript的类基于原型链和继承，因此在上面的内容中就已经定义了很多的类。咱们javascript的类同样能实现传统类的多态，封装，继承等特性，这里主要讲解了继承这个概念，但实际上很多时候不经意可能就用了这三个特性。很好玩不是么</p>
</blockquote>
<p>首先，我们先看下在ES5中定义一个类的形式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Animal(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.sleep = function() &#123;</div><div class="line">        console.log(this.name+'正在睡觉');</div><div class="line">    &#125;</div><div class="line">&#125;//定义Animal类</div><div class="line">Animal.prototype = &#123;</div><div class="line">    eat: function(food) &#123;</div><div class="line">        console.log(this.name+"正在吃"+food);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function Cat() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Cat.prototype = new Animal('Tom');</div><div class="line">var Tom = new Cat('Tom');/Cat实例对象</div><div class="line">Tom.eat('猫粮');</div><div class="line">//Tom正在吃猫粮</div><div class="line">//继承Animal方法</div><div class="line">Tom.sleep();</div><div class="line">//Tom正在睡觉</div><div class="line">//继承Animal方法</div><div class="line">//现在的原型链：</div><div class="line">//Tom(Cat实例对象)---&gt;Cat.prototype(Animal实例对象)---&gt;Animal.prototype---&gt;Object.prototype---&gt;null</div></pre></td></tr></table></figure>
<p>好的，然后我们看下在ES6中改写上面的类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sleep() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' 正在睡觉'</span>);</div><div class="line">  &#125;</div><div class="line">  eat(food)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'正在吃'</span>+food)  </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Tom = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>);</div><div class="line">Tom.eat(<span class="string">'猫粮'</span>);</div><div class="line"><span class="comment">//Tom正在吃猫粮</span></div><div class="line"><span class="comment">//继承Animal方法</span></div><div class="line">Tom.sleep();</div><div class="line"><span class="comment">//Tom正在睡觉</span></div><div class="line"><span class="comment">//继承Animal方法</span></div><div class="line"><span class="comment">//现在的原型链：</span></div><div class="line"><span class="comment">//Tom(Cat实例对象)---&gt;Cat.prototype(Animal实例对象)---&gt;Animal.prototype---&gt;Object.prototype---&gt;null</span></div></pre></td></tr></table></figure>
<p>定义一个类的方法实际上也是上面所说的定义一个对象的方法，类本身就是一个对象，只不过这个对象里面的方法和属性可以供许多实例对象调用而已。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><blockquote>
<p>总的来说对于类的理解还是需要不断探索的，路漫漫其修远兮，吾将上下而求索。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 本文详细讲述了javascript中类的由来实现以及一些类知识的延伸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/11/01/%E8%AF%A6%E8%A7%A3javascript%E7%9A%84%E7%B1%BB/#more&quot;&gt;详解javascript的类&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;生活有度，人生添寿。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="javascript" scheme="http://damonare.github.io/tags/javascript/"/>
    
      <category term="深度玄学" scheme="http://damonare.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>http://damonare.github.io/2016/10/30/前端跨域整理/</id>
    <published>2016-10-30T07:24:24.028Z</published>
    <updated>2016-12-01T13:57:50.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong> 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more">前端跨域总结</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></li>
</ul>
<p><strong>人生在勤，不索何获。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h3><blockquote>
<p> 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">URL                      说明       是否允许通信</div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名下   允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/lab/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/script/b.js 同一域名下不同文件夹 允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com:8000/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js     同一域名，不同端口  不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">https:<span class="comment">//www.a.com/b.js 同一域名，不同协议 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//70.32.92.74/b.js 域名和域名对应ip 不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.cnblogs.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js 不同域名 不允许</span></div></pre></td></tr></table></figure>
<p><strong>这里我们需要注意两点:</strong></p>
<ol>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。<br>(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ol>
<h3 id="2-通过document-domain跨域"><a href="#2-通过document-domain跨域" class="headerlink" title="2. 通过document.domain跨域"></a>2. 通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。 第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('￼ifame');</div><div class="line">        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。" target="_blank" rel="external">http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>
</blockquote>
<ul>
<li>在页面<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 中设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'￼iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>在页面<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a> 中也设置document.domain:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>修改document.domain的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="3-通过location-hash跨域"><a href="#3-通过location-hash跨域" class="headerlink" title="3. 通过location.hash跨域"></a>3. 通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明：</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。</p>
<ul>
<li>a.html传送数据到b.html<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
<li><p>b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”<a href="http://www.baidu.com/proxy.html#data" target="_blank" rel="external">http://www.baidu.com/proxy.html#data</a>“</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
</ul>
<p>b.html页面的关键代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">    parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></div><div class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy.html页面的关键代码如下 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h3 id="4-通过HTML5的postMessage方法跨域"><a href="#4-通过HTML5的postMessage方法跨域" class="headerlink" title="4. 通过HTML5的postMessage方法跨域"></a>4. 通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信</p>
</blockquote>
<p>A页面通过postMessage方法发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);  </div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">"http://www.google.com"</span>;  </div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'hello world!'</span>, targetOrigin);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>postMessage的使用方法：</p>
<ul>
<li><p>otherWindow.postMessage(message, targetOrigin);</p>
<ul>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message:   是要发送的消息，类型为 String、Object (IE8、9 不支持)</li>
<li>targetOrigin:   是限定消息接收范围，不限制请使用 ‘*</li>
</ul>
</li>
</ul>
<p>B页面通过message事件监听并接受消息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </div><div class="line">  <span class="keyword">var</span> data = event.data;<span class="comment">//消息  </span></div><div class="line">  <span class="keyword">var</span> origin = event.origin;<span class="comment">//消息来源地址  </span></div><div class="line">  <span class="keyword">var</span> source = event.source;<span class="comment">//源Window对象  </span></div><div class="line">  <span class="keyword">if</span>(origin==<span class="string">"http://www.baidu.com"</span>)&#123;  </div><div class="line"><span class="built_in">console</span>.log(data);<span class="comment">//hello world!  </span></div><div class="line">  &#125;  </div><div class="line">&#125;;  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage, <span class="literal">false</span>);  </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123;  </div><div class="line">  <span class="comment">//for ie  </span></div><div class="line">  <span class="built_in">window</span>.attachEvent(<span class="string">'onmessage'</span>, onmessage);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="5-通过jsonp跨域"><a href="#5-通过jsonp跨域" class="headerlink" title="5.通过jsonp跨域"></a>5.通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://damonare.cn/data.php,那么a.html中的代码就可以这样：" target="_blank" rel="external">http://damonare.cn/data.php,那么a.html中的代码就可以这样：</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function dosomething(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<a href="http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦" target="_blank" rel="external">http://damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦</a>):</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></div><div class="line">$data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<ul>
<li>JSONP的优缺点<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
</li>
</ul>
<h3 id="6-通过CORS跨域"><a href="#6-通过CORS跨域" class="headerlink" title="6. 通过CORS跨域"></a>6. 通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"POST"</span>, <span class="string">"/damonare"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>以上damonare部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">"￼GET"</span>, <span class="string">"http://segmentfault.com/u/trigkit4/"</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></p>
<ul>
<li><p>CORS和JSONP对比</p>
<ul>
<li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p>
</li>
<li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
</li>
<li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</p>
</li>
</ul>
</li>
</ul>
<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>
<h3 id="7-通过window-name跨域"><a href="#7-通过window-name跨域" class="headerlink" title="7. 通过window.name跨域"></a>7. 通过window.name跨域</h3><blockquote>
<p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
</blockquote>
<p>比如：我们在任意一个页面输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name = <span class="string">"My window's name"</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.location.href = <span class="string">"http://damonare.cn/"</span>;</div><div class="line">&#125;,<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>进入damonare.cn页面后我们再检测再检测 window.name :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.name; <span class="comment">// My window's name</span></div></pre></td></tr></table></figure>
<p>可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。<br>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p>
<blockquote>
<p>由于安全原因，浏览器始终会保持 window.name 是string 类型。</p>
</blockquote>
<p>同样这个方法也可以应用到和iframe的交互来：<br>比如：我的页面(<a href="http://damonare.cn/index.html)中内嵌了一个iframe：" target="_blank" rel="external">http://damonare.cn/index.html)中内嵌了一个iframe：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.google.com/iframe.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>我们在 index.html 中写了下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    data = iframe.contentWindow.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Boom!报错！肯定的，因为两个页面不同源嘛，想要解决这个问题可以这样干：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        data = iframe.contentWindow.name;</div><div class="line">    &#125;</div><div class="line">    iframe.src = <span class="string">'about:blank'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</strong></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>其它诸如中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp）不作讨论。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<ul>
<li><p><a href="https://segmentfault.com/a/1190000000718840#articleHeader1" target="_blank" rel="external">详解js跨域问题</a></p>
</li>
<li><p><a href="http://blog.csdn.net/joyhen/article/details/21631833" target="_blank" rel="external">前端解决跨域问题的8种方案（最新最全）</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 相信每一个前端er对于跨域这两个字都不会陌生，在实际项目中应用也是比较多的。但跨域方法的多种多样实在让人目不暇接。老规矩，碰到这种情况，就只能自己总结一篇博客，作为记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/10/30/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/#more&quot;&gt;前端跨域总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生在勤，不索何获。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://damonare.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="跨域" scheme="http://damonare.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/"/>
    <id>http://damonare.github.io/2016/09/16/十大经典排序算法总结（javascript描述）/</id>
    <published>2016-09-16T06:39:04.538Z</published>
    <updated>2016-12-20T04:29:55.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。</p>
<ul>
<li><p>原文博客地址：<a href="http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more">十大经典排序算法</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生有情泪沾衣，江水江花岂终极。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>读者自行尝试可以<a href="https://github.com/damonare/Sorts" target="_blank" rel="external">想看源码戳这</a>，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦</p>
<blockquote>
<ul>
<li>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，<mark>JavaScript可谓风头无两，已经坐上了头把交椅。</mark></li>
<li>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（<mark>十大排序算法或是和十大排序算法同等难度的</mark>），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</li>
<li>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。<br><img src="http://img.blog.csdn.net/20160916152402267" alt="大大"></li>
</ul>
</blockquote>
<h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an<br>输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成；<br><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。<br><strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/" target="_blank" rel="external">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="http://img.blog.csdn.net/20160916153212716" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong><br>n: 数据规模<br>k:“桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="http://img.blog.csdn.net/20160916154036887" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>.重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进冒泡排序:</strong>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">var</span> i = arr.length<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></div><div class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">var</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j= <span class="number">0</span>; j&lt; i; j++)</div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                pos= j; <span class="comment">//记录交换的位置</span></div><div class="line">                <span class="keyword">var</span> tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></div><div class="line">     &#125;</div><div class="line">     <span class="built_in">console</span>.timeEnd(<span class="string">'改进后冒泡排序耗时'</span>);</div><div class="line">     <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort3</span>(<span class="params">arr3</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> high= arr.length<span class="number">-1</span>; <span class="comment">//设置变量的初始值</span></div><div class="line">    <span class="keyword">var</span> tmp,j;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        --high;                 <span class="comment">//修改high值, 前移一位</span></div><div class="line">        <span class="keyword">for</span> (j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者</span></div><div class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</div><div class="line">                tmp = arr[j]; arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">            &#125;</div><div class="line">        ++low;                  <span class="comment">//修改low值,后移一位</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'2.改进后冒泡排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr3;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort3(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p>三种方法耗时对比：</p>
<p><img src="http://img.blog.csdn.net/20160916163126374" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916160748389" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>.初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>.n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'选择排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916164754013" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>.从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>.将新元素插入到该位置后；</5></li>
<li><6>.重复步骤2~5。</6></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i];</div><div class="line">            <span class="keyword">var</span> j = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            array[j + <span class="number">1</span>] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'插入排序耗时：'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertionSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> key = array[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">                <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</div><div class="line">                <span class="keyword">if</span> (key &lt; array[middle]) &#123;</div><div class="line">                    right = middle - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">                array[j + <span class="number">1</span>] = array[j];</div><div class="line">            &#125;</div><div class="line">            array[left] = key;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'二分插入排序耗时：'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(binaryInsertionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160916174656100" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160916173802597" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明；<br>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>.按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">5</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">5</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">5</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(shellSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160916235203417" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>.对这两个子序列分别采用归并排序；</2></li>
<li><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left.length)</div><div class="line">        result.push(left.shift());</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (right.length)</div><div class="line">        result.push(right.shift());</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'归并排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(mergeSort(arr));</div></pre></td></tr></table></figure>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="http://img.blog.csdn.net/20160917001326254" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：快速排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="comment">//方法一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (array[j] &lt;= x) &#123;</div><div class="line">                    i++;</div><div class="line">                    temp = array[i];</div><div class="line">                    array[i] = array[j];</div><div class="line">                    array[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            quickSort(array, left, i - <span class="number">1</span>);</div><div class="line">            quickSort(array, i + <span class="number">1</span>, right);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'1.快速排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array or left or right is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">var</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</div><div class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'2.快速排序耗时'</span>);</div><div class="line">　　<span class="keyword">return</span> quickSort2(left).concat([pivot], quickSort2(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div><div class="line"><span class="built_in">console</span>.log(quickSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917003004906" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：堆排序</span></div><div class="line">@param  array 待排序数组*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span>) &#123;</div><div class="line">        <span class="comment">//建堆</span></div><div class="line">        <span class="keyword">var</span> heapSize = array.length, temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            heapify(array, i, heapSize);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//堆排序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            temp = array[<span class="number">0</span>];</div><div class="line">            array[<span class="number">0</span>] = array[j];</div><div class="line">            array[j] = temp;</div><div class="line">            heapify(array, <span class="number">0</span>, --heapSize);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'array is not an Array!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*方法说明：维护堆的性质</span></div><div class="line">@param  arr 数组</div><div class="line">@param  x   数组下标</div><div class="line">@param  len 堆大小*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, x, len</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span> &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'arr is not an Array or x is not a number!'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</div><div class="line"><span class="built_in">console</span>.log(heapSort(arr));<span class="comment">//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]</span></div></pre></td></tr></table></figure>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917105502853" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>. 找出待排序的数组中最大和最小的元素；</1></li>
<li><2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = array.length,</div><div class="line">        B = [],</div><div class="line">        C = [],</div><div class="line">        min = max = array[<span class="number">0</span>];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</div><div class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</div><div class="line">        C[array[k]]--;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'计数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</div><div class="line"><span class="built_in">console</span>.log(countingSort(arr)); <span class="comment">//[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]</span></div></pre></td></tr></table></figure>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="http://img.blog.csdn.net/20160917110641479" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.设置一个定量的数组当作空桶；</1></li>
<li><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></li>
<li><3>.对每个不是空的桶进行排序；</3></li>
<li><4>.从不是空的桶里把排好序的数据拼接起来。</4></li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*方法说明：桶排序</span></div><div class="line">@param  array 数组</div><div class="line">@param  num   桶的数量*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">array, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class="number">0</span>;</div><div class="line">    num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + <span class="number">1</span>) / num;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></div><div class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'桶排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917111945979" alt="这里写图片描述"></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html" target="_blank" rel="external">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li><1>.取得数组中的最大数，并取得位数；</1></li>
<li><2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></li>
<li><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> * @author damonare</div><div class="line"> * @param  arr 待排序数组</div><div class="line"> * @param  maxDigit 最大位数</div><div class="line"> */</div><div class="line"><span class="comment">//LSD Radix Sort</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</div><div class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> counter = [];</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</div><div class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</div><div class="line">                counter[bucket] = [];</div><div class="line">            &#125;</div><div class="line">            counter[bucket].push(arr[j]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</div><div class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</div><div class="line">                      arr[pos++] = value;</div><div class="line">                &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</div><div class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></div></pre></td></tr></table></figure>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="http://img.blog.csdn.net/20160917123313659" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  本文图文并茂的详细讲述了十大经典排序算法用javascript实现的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89/#more&quot;&gt;十大经典排序算法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生有情泪沾衣，江水江花岂终极。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="JavaScript" scheme="http://damonare.github.io/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://damonare.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://damonare.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Chrome控制台实用指南</title>
    <link href="http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://damonare.github.io/2016/09/09/Chrome控制台使用总结/</id>
    <published>2016-09-09T12:43:11.000Z</published>
    <updated>2016-11-26T09:57:13.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。</p>
<ul>
<li><p>原文地址：<a href="http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/#more">Chrome控制台实用指南</a></p>
</li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生何适不艰难，赖是胸中万斛宽</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear"></a>console.clear</h3><blockquote>
<p>console.clear();清空控制台，这个应该和console.log知名度一样高吧。</p>
</blockquote>
<h3 id="console-log家族"><a href="#console-log家族" class="headerlink" title="console.log家族"></a>console.log家族</h3><blockquote>
<p>先简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台</p>
</blockquote>
<p>如果你是一位开发者，我想console.log肯定是经常使用的了，我们主要看看console.log的几个兄弟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span><span class="built_in">console</span>.log (<span class="string">'普通信息'</span>)</div><div class="line"><span class="number">2.</span><span class="built_in">console</span>.info (<span class="string">'提示性信息'</span>)</div><div class="line"><span class="number">3.</span><span class="built_in">console</span>.error (<span class="string">'错误信息'</span>)</div><div class="line"><span class="number">4.</span><span class="built_in">console</span>.warn (<span class="string">'警示信息'</span>)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909211537532" alt="控制台"></p>
<p><strong>大家都会用log，但很少有人能够很好地利用console.error , console.warn 等将输出到控制台的信息进行分类整理。他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。</strong></p>
<blockquote>
<p>如果再配合console.group 与console.groupEnd，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.bundle"</span>);</div><div class="line"><span class="built_in">console</span>.warn(<span class="string">"来自bundle模块的警告信息1"</span>);<span class="built_in">console</span>.warn(<span class="string">"来自bundle模块的警告信息2"</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.bundle"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"来自bundle模块的信息1"</span>);<span class="built_in">console</span>.log(<span class="string">"来自bundle模块的信息2"</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909212018524" alt="这里写图片描述"></p>
<p><strong>这样的控制台信息看上去就一目了然了，就不用再为了找这是属于那一行代码输出的再翻一遍源码了。</strong></p>
<blockquote>
<p>另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,\n;看下面这个炫酷的效果：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>, <span class="string">'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909213512650" alt="这里写图片描述"></p>
<p><strong>当然，图片也是可以的，读者可以自行尝试，修改上述代码即可。</strong></p>
<blockquote>
<p>另外，console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<p><img src="http://img.blog.csdn.net/20160909215338908" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h3><blockquote>
<p>看着这种“黑魔法”是不是有种坑分的感觉呢，其实还不止哦！console.table可以让我们输出表格,示例：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;code:<span class="number">200</span>,content:[&#123;<span class="string">'品名'</span>: <span class="string">'杜雷斯'</span>, <span class="string">'数量'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'品名'</span>: <span class="string">'冈本'</span>, <span class="string">'数量'</span>: <span class="number">3</span>&#125;]&#125;;</div><div class="line"><span class="built_in">console</span>.table(data.content);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909214911953" alt="这里写图片描述"></p>
<p><strong>有的时候后端传回来一大串数据，是不是觉得直接console.log或是通过抓包工具查看都会让人晕头转向呢，这个时候正事console.table发挥作用的时候了，以表格的形式呈现数据，自然一目了然。</strong></p>
<h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert"></a>console.assert</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isDebug=<span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.assert(isDebug,<span class="string">'开发中的log信息。。。'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。</p>
<p><img src="http://img.blog.csdn.net/20160909215637362" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count"></a>console.count</h3><blockquote>
<p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的console.count可以很地胜任这样的任务.</p>
<p><img src="http://img.blog.csdn.net/20160909215931738" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir"></a>console.dir</h3><blockquote>
<p>将DOM结点以JavaScript对象的形式输出到控制台<br>而console.log是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://img.blog.csdn.net/20160909220149156" alt="这里写图片描述"></p>
</blockquote>
<h3 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time &amp; console.timeEnd"></a>console.time &amp; console.timeEnd</h3><blockquote>
<p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。比如需要考量一段代码执行的耗时情况时，可以用console.time与 console.timeEnd来做此事。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">"Array耗时"</span>);</div><div class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array耗时"</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909220932148" alt="这里写代码片"></p>
<blockquote>
<p>当想要查看CPU使用相关的信息时，可以使用console.profile配合 console.profileEnd来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是Profile。使用方法和console.time基本一样，其实time开发者工具里也有个tab就是timeline。关于console.prefile博主就不做多余的介绍了。想要做更多了解的读者可以看<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="$"></a>$</h3><blockquote>
<p>讲真，米国程序员们真的很喜欢money啊（谁又不是呢），看看PHP就知道了,满屏的$符号。而在Chrome的控制台里，$用处同样是蛮多且方便的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>+<span class="number">2</span><span class="comment">//回车，再</span></div><div class="line">$_+<span class="number">1</span><span class="comment">//回车得5</span></div></pre></td></tr></table></figure>
<blockquote>
<p>上面的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$_</div></pre></td></tr></table></figure>
<blockquote>
<p>需要领悟其奥义才能使用得当，而</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$<span class="number">0</span>~$<span class="number">4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>则代表了最近5个你选择过的DOM节点。<br>什么意思呢？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909222120965" alt="这里写图片描述"></p>
<blockquote>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节点，多么滴熟悉。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'body'</span>);</div><div class="line">$$(<span class="string">'div'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909223159417" alt="这里写图片描述"></p>
<blockquote>
<p>$(selector)返回的是满足选择条件的首个DOM元素。<br>剥去她伪善的外衣，其实$(selector)是原生JavaScript document.querySelector() 的封装。<br>同时另一个命令$$(selector)返回的是所有满足选择条件的元素的一个集合，是对document.querySelectorAll() 的封装。</p>
</blockquote>
<h3 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a>$x(path)</h3><blockquote>
<p>将所匹配的节点放在一个数组里返回</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$x(<span class="string">"//p"</span>);</div><div class="line">$x(<span class="string">"//p[a]"</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909232110728" alt="这里写图片描述"></p>
<blockquote>
<p>$x(“//p”)匹配所有的p节点，$x(“//p[a]”);匹配所有子节点包含a的p节点</p>
</blockquote>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">copy(<span class="built_in">document</span>.body)</div></pre></td></tr></table></figure>
<blockquote>
<p>然后你就可以Ctrl+v了。</p>
</blockquote>
<p><strong>注意：他不依附于任何全局变量比如window，所以其实在JS代码里是访问不了这个copy方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~这样我们就可以通过js代码进行复制操作而不用再依赖Flash插件了。</strong></p>
<h3 id="keys-amp-values"><a href="#keys-amp-values" class="headerlink" title="keys &amp; values"></a>keys &amp; values</h3><blockquote>
<p>这是一对基友。前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。具体请看下面的例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tfboy=&#123;name:<span class="string">'wayou'</span>,gender:<span class="string">'unknown'</span>,hobby:<span class="string">'opposite to the gender'</span>&#125;;</div><div class="line">keys(tfboy);</div><div class="line">values(tfboy);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909225910811" alt="这里写图片描述"></p>
<h3 id="monitor-amp-unmonitor"><a href="#monitor-amp-unmonitor" class="headerlink" title="monitor &amp; unmonitor"></a>monitor &amp; unmonitor</h3><blockquote>
<p>monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。而unmonitor(function)便是用来停止这一监听。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello,'</span>+name);</div><div class="line">&#125;</div><div class="line">monitor(sayHello);</div><div class="line">sayHello(<span class="string">'damonare'</span>);</div><div class="line">sayHello(<span class="string">'tjz'</span>);</div><div class="line">unmonitor(sayHello);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160909230648805" alt="这里写图片描述"></p>
<h3 id="debug-amp-undebug"><a href="#debug-amp-undebug" class="headerlink" title="debug &amp; undebug"></a>debug &amp; undebug</h3><blockquote>
<p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。而undebug 则是解除该断点。而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160909231322130" alt=""></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><strong>本博文依据<a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#consolelogobject-object" target="_blank" rel="external">Console API文档</a>和<a href="https://developers.google.com/web/tools/chrome-devtools/debug/command-line/command-line-reference?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3#debugfunction" target="_blank" rel="external">Commond API</a>书写。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://damonare.github.io/2016/09/09/Chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/#more&quot;&gt;Chrome控制台实用指南&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生何适不艰难，赖是胸中万斛宽&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://damonare.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="工具" scheme="http://damonare.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Clip-Path</title>
    <link href="http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/"/>
    <id>http://damonare.github.io/2016/09/09/聊聊clip-path/</id>
    <published>2016-09-09T08:51:00.000Z</published>
    <updated>2016-11-26T06:00:47.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>总括：</strong>  图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！</p>
<ul>
<li>原文博客地址：<a href="http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/#more">聊聊clip-path</a></li>
<li><p>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a></p>
</li>
<li><p>博主博客地址：<a href="http://damonare.cn" target="_blank" rel="external">Damonare的个人博客</a></p>
</li>
</ul>
<p><strong>人生如画，岁月如歌。</strong></p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Flilter"><a href="#Flilter" class="headerlink" title="Flilter"></a>Flilter</h3><blockquote>
<p>filter有十种特效来处理图片，博主只放几种特效的样例给大家看一下：</p>
<p>照片反色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104748479" alt="照片反色"></p>
<p>照片褐色效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104803642" alt="照片褐色"></p>
<p>照片阴影效果：</p>
<p><img src="http://img.blog.csdn.net/20160910104818298" alt="阴影"></p>
</blockquote>
<p><strong>十种特效源码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">-webkit-filter:opacity(.6);//透明度</div><div class="line">filter:opacity(.6);</div><div class="line">-webkit-filter:blur(10px);//照片模糊</div><div class="line">filter:blur(10px);</div><div class="line">-webkit-filter:invert(1);</div><div class="line">filter:invert(1);</div><div class="line">-webkit-filter:saturate(3);//照片饱和度</div><div class="line">filter:saturate(3);</div><div class="line">-webkit-filter:grayscale(1);//照片灰度</div><div class="line">filter:grayscale(1);</div><div class="line">-webkit-filter:sepia(1);//照片褐色</div><div class="line">filter:sepia(1);</div><div class="line">-webkit-filter:hue-rotate(90deg);//色相旋转</div><div class="line">filter:hue-rotate(90deg);</div><div class="line">-webkit-filter:brightness(.5);//亮度</div><div class="line">filter:brightness(.5);</div><div class="line">-webkit-filter:contrast(2);//对比度</div><div class="line">filter:contrast(2);</div><div class="line">-webkit-filter:drop-shadow(10px 10px 10px #ccc);//阴影</div><div class="line">filter:drop-shadow(10px 10px 10px #ccc);</div></pre></td></tr></table></figure>
<blockquote>
<p>但实际上这个属性兼容性很低：</p>
<p><img src="http://img.blog.csdn.net/20160910105340845" alt="can I use"></p>
</blockquote>
<p><strong>截止博主发文日期，Filter的兼容性如上图，我们可以看到IE是完全不支持的，Edge也是部分支持。这可能也是Filter没法用在项目中的原因之一了。感兴趣的读者可以Copy博主代码本地测试一下，或是参照<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter#blur%28%29_2" target="_blank" rel="external">MDN|Filter</a>了解。博主不在这里做过多的说明了。</strong></p>
<h3 id="clip-amp-clip-path"><a href="#clip-amp-clip-path" class="headerlink" title="clip&amp;clip-path"></a>clip&amp;clip-path</h3><blockquote>
<p>这两个属性正是今天的重头戏，博主曾在<a href="http://damonare.github.io/2016/09/05/%E4%BB%8E%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E8%B0%88%E8%B5%B7/#more">从隐藏元素谈起</a>提起过，但并没做深入解释。是的，它可以用来隐藏元素，当然也就能处理图片了。</p>
</blockquote>
<ul>
<li>clip</li>
</ul>
<blockquote>
<p>clip这个属性我相信会有很大一部分人不知道，因为这个属性使用率非常的低，因为很多情况下我们会直接重新切一张新图出来代替而不会去剪裁已有的图片，但实际上这个属性用在CSS sprite简直就如同神器一般，因为在很多情况下background-position并不符合我们的需求，比如,有时我们希望Sprite图片可以延迟滚动加载，或者是可以很轻松的右键图片另存为…或是其它background-position没法满足的情景。<br>废话不多说，看样例：<br><img src="http://img.blog.csdn.net/20160910144129604" alt="这里写图片描述"></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</div><div class="line"><span class="selector-tag">clip</span><span class="selector-pseudo">:rect(50px</span> 250<span class="selector-tag">px</span> 250<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>); <span class="comment">/* IE6, IE7 */</span></div><div class="line"><span class="selector-tag">clip</span><span class="selector-pseudo">:rect(50px</span>,250<span class="selector-tag">px</span>,250<span class="selector-tag">px</span>,50<span class="selector-tag">px</span>);</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160910182933393" alt="这里写图片描述"></p>
<p><strong>注意，元素定位position必须是absolute或是fixed的，兼容IE6，IE7需要将值之间的逗号去掉。另外，react（top,right,bottom,left）；四个值分别是相对于图片左上角为原点的坐标值。Clip基本所有的浏览器都支持，可以放心使用。</strong></p>
<blockquote>
<p>让人放弃它的原因无外乎：</p>
<ul>
<li>clip 只对绝对定位的元素有效对于position:relative和position:static无效</li>
<li>clip 只能用于矩形，即rect()函数</li>
</ul>
</blockquote>
<ul>
<li>clip-path</li>
</ul>
<blockquote>
<p>其实clip在HTML5中已经被废弃了(依然可用)，取而代之的是clip-path。本来clip还有一个circle(圆)，但基本没有浏览器实现这个属性值，只有rect()可是使用，可能W3C也是等不下去了吧，直接推出了一个更牛逼的属性——clip-path,这个属性起初是SVG里面的然后被挪用到了CSS里面。关于SVG博主有时间会再另外介绍，这里按下不表。效果图：<br><img src="http://img.blog.csdn.net/20160910165910381" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160910165924100" alt="这里写图片描述"></p>
</blockquote>
<p><strong>读者可以在<a href="http://bennettfeely.com/clippy/" target="_blank" rel="external">这里自行体验</a></strong></p>
<blockquote>
<p>兼容：现在为止IE 和 Edge 不支持这个属性，Firefox 仅部分支持 clip-path ，<br>Chrome、Safari 和 Opera 需要使用 -webkit- 前缀支持此属性。<br><img src="http://img.blog.csdn.net/20160910172318567" alt="这里写图片描述"><br><strong>clip-path兼容性甚至比前面说到的filter还差，所以很难真正使用起来。更多使用效果<a href="http://codepen.io/wenbin5243/pen/iheHF" target="_blank" rel="external">戳这里</a>和<a href="http://species-in-pieces.com/#" target="_blank" rel="external">这里</a></strong></p>
</blockquote>
<p><strong>说一下它的四个属性值：</strong></p>
<ul>
<li>clip-source: 可以是内、外部的SVG的clipPath元素的URL引用;</li>
</ul>
<ul>
<li><p>basic-shape: 使用一些基本的形状函数创建的一个形状。主要包括circle()、ellipse()、inset()和polygon()。</p>
</li>
<li><p>geometry-box: 是可选参数。此参数和basic-shape函数一起使用时，可以为basic-shape的裁剪工作提供参考盒子。如果geometry-box由自身指定，那么它会使用指定盒子形状作为裁剪的路径，包括任何(由border-radius提供的)的角的形状。</p>
</li>
</ul>
<p><strong>开始使用clip-path</strong></p>
<blockquote>
<p>在开始使用clip-path绘制图形，或者说裁剪图形之前，有两点需要大家注意：</p>
<ul>
<li><p>使用clip-path要从同一个方向绘制，如果顺时针绘制就一律顺时针，逆时针就一律逆时针，因为polygon是一个连续线段，若线段彼此有交集，裁剪区域就会有相减的情况发生，当然如果你特意需要这样的效果除外。</p>
</li>
<li><p>如果绘制时采用比例的方式绘制，长宽就必须要先行设定，不然有可能绘制出来的长宽和我们想像的就会有差距，使用像素绘制就不会有这样的现象。</p>
</li>
</ul>
<p>我们就拿上面途中的六边形作为polygon()函数示例：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-clip-path</span>: <span class="selector-tag">polygon</span>(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%);</div><div class="line"><span class="selector-tag">clip-path</span>: <span class="selector-tag">polygon</span>(0% 50%, 25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%);</div></pre></td></tr></table></figure>
<p><strong>效果图:</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174638529" alt="效果图"></p>
<p><strong>讲解：</strong></p>
<p><img src="http://img.blog.csdn.net/20160910174656822" alt="这里写图片描述"></p>
<blockquote>
<p>每个点的第一个坐标值决定了它在 x 轴上的位置，第二个坐标值指定了它在 y 轴的位置，所有点是顺时针绘制的。其实一个 polygon（）就能满足所有的形状需要了，有自定义的API用更加方便不是么。</p>
</blockquote>
<p><strong>注意：inset()这个真的坑，按说同样裁剪成方形应该是和clip的rect一样用法，可不一样！</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Clip的rect</div><div class="line">position:absolute;</div><div class="line">clip:rect(50px 250px 250px 50px);</div><div class="line">//clip-path</div><div class="line">clip-path: inset(50px 50px 50px 50px);</div><div class="line">-webkit-clip-path: inset(50px 50px 50px 50px);</div></pre></td></tr></table></figure>
<p><strong>本文使用图片是300*300的。</strong></p>
<blockquote>
<p>很明显：</p>
</blockquote>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clip:rect(50px 250px 250px 50px);</div><div class="line">=clip-path: inset(50px 50px 50px 50px);</div></pre></td></tr></table></figure>
<p>好大的一个坑….</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>相信随着时代发展，clip-path会慢慢被浏览器厂商接受的。<br>本文有任何错误，欢迎评论留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt;  图片是一个网站必不可少的元素，而呈现出绚丽多彩的图片效果在很多情况下不仅仅是设计师的工作，通过代码来修饰图片也是一个前端工程师必备的技能。因为兼容性的问题，实际项目中可能用的比较少，包括博主自己也只是用过几次剪切，很多情况下都交给设计师去做了。但作为一个hacker怎么能满足于此呢，必须深入探究！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文博客地址：&lt;a href=&quot;http://damonare.github.io/2016/09/09/%E8%81%8A%E8%81%8Aclip-path/#more&quot;&gt;聊聊clip-path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;知乎专栏&amp;amp;&amp;amp;简书专题：&lt;a href=&quot;https://zhuanlan.zhihu.com/damonare&quot;&gt;前端进击者（知乎）&lt;/a&gt;&amp;amp;&amp;amp;&lt;a href=&quot;http://www.jianshu.com/collection/bbaa63e264f5&quot;&gt;前端进击者（简书）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博主博客地址：&lt;a href=&quot;http://damonare.cn&quot;&gt;Damonare的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;人生如画，岁月如歌。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://damonare.github.io/categories/learn/"/>
    
    
      <category term="CSS3" scheme="http://damonare.github.io/tags/CSS3/"/>
    
  </entry>
  
</feed>
